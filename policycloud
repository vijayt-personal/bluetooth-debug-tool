#ifndef PACKET_DEFINITIONS_HPP_
#define PACKET_DEFINITIONS_HPP_

#include <cstdint>

namespace visium {

// A generic, abstract type for data packets the application can send.
enum class PacketType {
    DeviceStatus,
    TimeSeriesData,
    CriticalAlert
};

// A native C++ struct for device status data.
struct DeviceStatusPayload {
    double battery_percent;
    uint64_t uptime_seconds;
};

// A native C++ struct for sensor data.
struct TimeSeriesPayload {
    float temperature;
    float humidity;
};

// A native C++ struct for a critical alert.
struct AlertPayload {
    uint32_t error_code;
    const char* message;
};

} // namespace visium

#endif // PACKET_DEFINITIONS_HPP_

#ifndef CLOUD_POLICY_CONFIG_HPP_
#define CLOUD_POLICY_CONFIG_HPP_

#include "aws_iot_policy.hpp"

using CloudPolicy = visium::AwsIotPolicy;

#endif

#ifndef COMMANDS_HPP_
#define COMMANDS_HPP_

#include <variant>
#include <string>

namespace visium {

// A strongly-typed enum for all possible commands received from the cloud.
enum class CommandType {
    SetPower,
    SetIntensity,
    SetConfig,
    Unknown
};

// A variant to hold the different types of data for received commands.
using CommandValue = std::variant<bool, int, std::string>;

// The Command struct that the policy creates and the application consumes.
struct Command {
    CommandType type;
    CommandValue value;
};

} // namespace visium

#endif // COMMANDS_HPP_

#ifndef CLOUD_COMMUNICATOR_HPP_
#define CLOUD_COMMUNICATOR_HPP_

#include "commands.hpp"
#include "packet_definitions.hpp"
#include <atomic>
#include <cstdint>
#include <functional>
#include <memory>
#include <string>

// --- Assumed Project Includes ---
#include "log_print.h"
#include "system_uptime.h"
#include "rapidjson/document.h"

// Forward declare the concrete FileSystem class
class FileSystem;

namespace visium {

template <typename CloudPolicy>
class CloudCommunicator {
public:
    using ControlCommandCallback = std::function<bool(const Command& command)>;
    using ConnectionStatusCallback = std::function<void(bool connected)>;

    struct Config {
        uint32_t initial_backoff_ms = 1000;
        uint32_t max_backoff_ms     = 60000;
        uint32_t connect_timeout_ms = 30000;
    };

    // Constructor now takes a concrete FileSystem reference.
    CloudCommunicator(CloudPolicy& policy, const Config& comm_config, FileSystem& fs)
        : policy_(policy),
          config_(comm_config),
          fs_(fs),
          current_state_(State::UNINITIALIZED)
    {}
    
    ~CloudCommunicator() {
        if (IsConnected()) {
            Disconnect();
        }
    }

    CloudCommunicator(const CloudCommunicator&) = delete;
    CloudCommunicator& operator=(const CloudCommunicator&) = delete;

    // Initialize is now parameter-free.
    bool Initialize() {
        if (!policy_.Initialize(fs_,
                               [this]() { this->OnPolicyConnected(); },
                               [this]() { this->OnPolicyDisconnected(); },
                               [this](const Command& cmd) { return this->OnPolicyCommandReceived(cmd); }))
        {
            LOG_PRINT(log_print::kERROR, "Policy initialization failed.");
            return false;
        }
        current_state_.store(State::DISCONNECTED);
        return true;
    }

    void Process() {
        policy_.Yield();
        const State state = current_state_.load();
        switch (state) {
            case State::DISCONNECTED:
                AttemptReconnect();
                break;
            case State::WAITING_TO_RETRY:
                if (system_uptime::ExceedsMs(last_disconnect_time_ms_, current_backoff_delay_ms_)) {
                    AttemptReconnect();
                }
                break;
            case State::CONNECTING:
                if (system_uptime::ExceedsMs(connect_start_time_ms_, config_.connect_timeout_ms)) {
                    LOG_PRINT(log_print::kERROR, "Connection attempt timed out after %u ms.", config_.connect_timeout_ms);
                    policy_.Disconnect();
                    HandleDisconnectInternal();
                }
                break;
            case State::CONNECTED:
                policy_.Process();
                break;
            case State::UNINITIALIZED:
            default:
                break;
        }
    }

    bool IsConnected() const {
        return current_state_.load(std::memory_order_relaxed) == State::CONNECTED;
    }

    bool SendData(PacketType type, const void* payload) {
        if (!IsConnected()) {
            LOG_PRINT(log_print::kWARN, "Cannot send data, not connected.");
            return false;
        }
        return policy_.SendData(type, payload);
    }

    const rapidjson::Value& GetCachedShadowState() const {
        return policy_.GetCachedShadowState();
    }

    void SetConnectionStatusCallback(ConnectionStatusCallback cb) {
        connection_status_callback_ = std::move(cb);
    }
    void SetControlCommandCallback(ControlCommandCallback cb) {
        control_command_callback_ = std::move(cb);
    }

private:
    enum class State { UNINITIALIZED, DISCONNECTED, CONNECTING, CONNECTED, WAITING_TO_RETRY };

    void AttemptReconnect() {
        State expected = State::DISCONNECTED;
        if (!current_state_.compare_exchange_strong(expected, State::CONNECTING)) {
            expected = State::WAITING_TO_RETRY;
            if (!current_state_.compare_exchange_strong(expected, State::CONNECTING)) {
                return;
            }
        }
        LOG_PRINT(log_print::kINFO, "Attempting connection (Attempt #%d)...", reconnect_attempts_ + 1);
        connect_start_time_ms_ = system_uptime::GetMs();
        reconnect_attempts_++;
        if (!policy_.Connect()) {
            HandleDisconnectInternal();
        }
    }

    void HandleDisconnectInternal() {
        State previous_state = current_state_.load();
        if (previous_state != State::CONNECTED && previous_state != State::CONNECTING) {
            return;
        }
        current_state_.store(State::WAITING_TO_RETRY);
        last_disconnect_time_ms_ = system_uptime::GetMs();
        if (previous_state == State::CONNECTED) {
            uint64_t next_delay = (uint64_t)current_backoff_delay_ms_ * 2;
            current_backoff_delay_ms_ = std::min((uint32_t)next_delay, config_.max_backoff_ms);
        } else {
             current_backoff_delay_ms_ = config_.initial_backoff_ms;
        }
        LOG_PRINT(log_print::kINFO, "Entered WAITING_TO_RETRY state. Next attempt in %u ms.", current_backoff_delay_ms_);
        if (previous_state == State::CONNECTED && connection_status_callback_) {
            connection_status_callback_(false);
        }
    }

    void OnPolicyConnected() {
        LOG_PRINT(log_print::kINFO, "Policy reported connection success!");
        current_state_.store(State::CONNECTED);
        reconnect_attempts_ = 0;
        current_backoff_delay_ms_ = config_.initial_backoff_ms;
        if (connection_status_callback_) {
            connection_status_callback_(true);
        }
    }

    void OnPolicyDisconnected() {
        LOG_PRINT(log_print::kWARN, "Policy reported disconnection.");
        HandleDisconnectInternal();
    }

    bool OnPolicyCommandReceived(const Command& command) {
        if (control_command_callback_) {
            return control_command_callback_(command);
        }
        LOG_PRINT(log_print::kWARN, "Received command but no callback is registered.");
        return false;
    }

    CloudPolicy&             policy_;
    Config                   config_;
    FileSystem&              fs_; // Now a concrete reference
    std::atomic<State>       current_state_;
    int                      reconnect_attempts_ = 0;
    uint32_t                 current_backoff_delay_ms_ = 1000;
    uint64_t                 last_disconnect_time_ms_ = 0;
    uint64_t                 connect_start_time_ms_ = 0;
    ConnectionStatusCallback connection_status_callback_{nullptr};
    ControlCommandCallback   control_command_callback_{nullptr};
};

} // namespace visium
#endif // CLOUD_COMMUNICATOR_HPP_

#ifndef AWS_IOT_POLICY_HPP_
#define AWS_IOT_POLICY_HPP_

#include "commands.hpp"
#include "packet_definitions.hpp"
#include <string>
#include <functional>
#include <memory>
#include <cstdint>
#include "rapidjson/document.h"

// Forward declarations
namespace AwsIot { class AwsIotMqttClient; }
class FileSystem; // Use forward declaration

namespace visium {

class AwsIotPolicy {
public:
    using ConnectionCallback = std::function<void()>;
    using CommandCallback = std::function<bool(const Command& command)>;

    AwsIotPolicy();
    ~AwsIotPolicy();

    // Initialize now takes a concrete FileSystem reference.
    bool Initialize(FileSystem& fs, ConnectionCallback on_conn, ConnectionCallback on_disconn, CommandCallback on_cmd);
    
    void Process();
    void Yield() {}
    bool SendData(PacketType type, const void* payload);
    bool Connect();
    void Disconnect();
    const rapidjson::Value& GetCachedShadowState() const;

private:
    struct Config; // No need for this to be public anymore
    
    bool LoadFileToString(FileSystem& fs, const char* path, std::string& out_str);

    void OnMqttConnected();
    void OnMqttDisconnected();
    void HandleShadowCallback(const std::string& update_type, std::string_view payload);
    void ProcessShadowDelta(const rapidjson::Value& delta_state);
    void PollShadow();
    bool ReportState(const std::string& state_payload, int qos = 1);

    std::unique_ptr<AwsIot::AwsIotMqttClient> client_;
    std::unique_ptr<Config> config_;
    ConnectionCallback on_connected_{nullptr};
    ConnectionCallback on_disconnected_{nullptr};
    CommandCallback on_command_{nullptr};
    
    bool initial_shadow_received_ = false;
    uint16_t get_shadow_attempts_ = 0;
    uint64_t last_get_shadow_attempt_ms_ = 0;
    uint32_t current_get_shadow_backoff_ms_ = 5000;
    uint32_t last_processed_shadow_version_ = 0;
    bool has_performed_initial_get_ = false;
    rapidjson::Document local_shadow_cache_;
    
    std::string status_topic_;
    std::string timeseries_topic_;
    std::string alerts_topic_;
};

} // namespace visium
#endif // AWS_IOT_POLICY_HPP_

#include "aws_iot_policy.hpp"
#include "packet_definitions.hpp"
#include "config_paths.hpp"
#include <cstring>
#include "aws_iot_mqtt_client.hpp"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include "log_print.h"
#include "system_uptime.h"
#include "file_system_stub.hpp"

namespace visium {

// The internal config struct is now defined only here.
struct AwsIotPolicy::Config {
    std::string aws_endpoint;
    std::string client_id;
    std::string thing_name;
    uint16_t    port = 8883;
    uint32_t    session_expiry_seconds = 86400;
    std::string root_ca_pem;
    std::string device_cert_pem;
    std::string private_key_pem;
};

AwsIotPolicy::AwsIotPolicy() {
    local_shadow_cache_.SetObject();
}
AwsIotPolicy::~AwsIotPolicy() = default;

bool AwsIotPolicy::LoadFileToString(FileSystem& fs, const char* path, std::string& out_str) {
    auto file = fs.Open(path, "r");
    if (!file) {
        LOG_PRINT(log_print::kERROR, "Failed to open file: %s", path);
        return false;
    }
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);

    if (size <= 0) {
        LOG_PRINT(log_print::kERROR, "Invalid file size for: %s", path);
        fs.Close(file);
        return false;
    }

    out_str.resize(size);
    bool success = fs.Read(file, &out_str[0], size) == (size_t)size;
    fs.Close(file);
    return success;
}

bool AwsIotPolicy::Initialize(FileSystem& fs, ConnectionCallback on_conn, ConnectionCallback on_disconn, CommandCallback on_cmd) {
    on_connected_ = std::move(on_conn);
    on_disconnected_ = std::move(on_disconn);
    on_command_ = std::move(on_cmd);
    
    config_ = std::make_unique<Config>();

    std::string config_json_str;
    if (!LoadFileToString(fs, kConfigFilePath, config_json_str)) {
        LOG_PRINT(log_print::kERROR, "Could not read config file: %s", kConfigFilePath);
        return false;
    }

    rapidjson::Document config_doc;
    config_doc.Parse(config_json_str.c_str());
    if (config_doc.HasParseError() || !config_doc.IsObject()) {
        LOG_PRINT(log_print::kERROR, "Failed to parse config.json.");
        return false;
    }

    if (config_doc.HasMember("endpoint") && config_doc["endpoint"].IsString()) {
        config_->aws_endpoint = config_doc["endpoint"].GetString();
    }
    if (config_doc.HasMember("thingName") && config_doc["thingName"].IsString()) {
        config_->thing_name = config_doc["thingName"].GetString();
        config_->client_id = config_->thing_name;
    }
    if (config_doc.HasMember("port") && config_doc["port"].IsUint()) {
        config_->port = config_doc["port"].GetUint();
    }
    if (config_doc.HasMember("sessionExpirySeconds") && config_doc["sessionExpirySeconds"].IsUint()) {
        config_->session_expiry_seconds = config_doc["sessionExpirySeconds"].GetUint();
    }

    if (config_doc.HasMember("certs") && config_doc["certs"].IsObject()) {
        const auto& certs = config_doc["certs"];
        if (!certs.HasMember("rootCaPath") || !certs["rootCaPath"].IsString() || !LoadFileToString(fs, certs["rootCaPath"].GetString(), config_->root_ca_pem)) return false;
        if (!certs.HasMember("deviceCertPath") || !certs["deviceCertPath"].IsString() || !LoadFileToString(fs, certs["deviceCertPath"].GetString(), config_->device_cert_pem)) return false;
        if (!certs.HasMember("privateKeyPath") || !certs["privateKeyPath"].IsString() || !LoadFileToString(fs, certs["privateKeyPath"].GetString(), config_->private_key_pem)) return false;
    } else {
        return false;
    }

    status_topic_ = "devices/" + config_->thing_name + "/status";
    timeseries_topic_ = "devices/" + config_->thing_name + "/data";
    alerts_topic_ = "devices/" + config_->thing_name + "/alerts";

    AwsIot::MqttConfig client_config;
    strncpy(client_config.aws_endpoint, config_->aws_endpoint.c_str(), AwsIot::kMaxEndpointLen - 1);
    strncpy(client_config.client_id, config_->client_id.c_str(), AwsIot::kMaxClientIdLen - 1);
    strncpy(client_config.thing_name, config_->thing_name.c_str(), AwsIot::kMaxThingNameLen - 1);
    client_config.port = config_->port;
    client_config.session_expiry_interval = config_->session_expiry_seconds;
    strncpy(client_config.root_ca_pem, config_->root_ca_pem.c_str(), AwsIot::kMaxCertLen - 1);
    strncpy(client_config.device_cert_pem, config_->device_cert_pem.c_str(), AwsIot::kMaxCertLen - 1);
    strncpy(client_config.private_key_pem, config_->private_key_pem.c_str(), AwsIot::kMaxCertLen - 1);
    
    client_ = std::make_unique<AwsIot::AwsIotMqttClient>();
    if (!client_->Initialize(client_config)) {
         return false;
    }
    client_->SetOnConnectedCallback([this]() { this->OnMqttConnected(); });
    client_->SetOnDisconnectedCallback([this]() { this->OnMqttDisconnected(); });
    return true;
}

const rapidjson::Value& AwsIotPolicy::GetCachedShadowState() const {
    return local_shadow_cache_;
}

void AwsIotPolicy::Process() { 
    if (client_ && client_->IsConnected()) {
        PollShadow();
    }
}

bool AwsIotPolicy::Connect() { 
    return client_ ? client_->Connect() : false;
}

void AwsIotPolicy::Disconnect() { 
    if (client_) {
        client_->Disconnect();
    }
}

bool AwsIotPolicy::SendData(PacketType type, const void* payload) {
    if (!client_ || !client_->IsConnected() || !payload) return false;
    rapidjson::Document doc;
    doc.SetObject();
    rapidjson::Document::AllocatorType& allocator = doc.GetAllocator();
    const std::string* topic_to_use = nullptr;
    int qos = 0;

    switch (type) {
        case PacketType::DeviceStatus: {
            topic_to_use = &status_topic_;
            const auto* data = static_cast<const DeviceStatusPayload*>(payload);
            doc.AddMember("battery", data->battery_percent, allocator);
            doc.AddMember("uptime", data->uptime_seconds, allocator);
            break;
        }
        case PacketType::TimeSeriesData: {
            topic_to_use = &timeseries_topic_;
            const auto* data = static_cast<const TimeSeriesPayload*>(payload);
            doc.AddMember("temp", data->temperature, allocator);
            doc.AddMember("humidity", data->humidity, allocator);
            break;
        }
        case PacketType::CriticalAlert: {
            topic_to_use = &alerts_topic_;
            qos = 1;
            const auto* data = static_cast<const AlertPayload*>(payload);
            doc.AddMember("errorCode", data->error_code, allocator);
            doc.AddMember("message", rapidjson::Value(data->message, allocator).Move(), allocator);
            break;
        }
        default:
            return false;
    }

    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    doc.Accept(writer);
    return client_->Publish(*topic_to_use, buffer.GetString(), qos);
}

void AwsIotPolicy::OnMqttConnected() {
    LOG_PRINT(log_print::kINFO, "MQTT Connected. Subscribing to shadow topics for thing: %s", config_->thing_name.c_str());
    auto shadow_handler = [this](const std::string& type, std::string_view payload) { this->HandleShadowCallback(type, payload); };
    if (client_->SubscribeToShadowUpdates(shadow_handler) && client_->SubscribeToShadowGetResponses(shadow_handler)) {
        LOG_PRINT(log_print::kINFO, "Shadow subscriptions successful.");
        initial_shadow_received_ = false;
        get_shadow_attempts_ = 0;
        current_get_shadow_backoff_ms_ = 5000;
        if (on_connected_) on_connected_();
    } else {
        LOG_PRINT(log_print::kERROR, "Failed to subscribe to shadow topics! Disconnecting.");
        client_->Disconnect();
    }
}

void AwsIotPolicy::OnMqttDisconnected() { 
    if (on_disconnected_) {
        on_disconnected_();
    }
}

void AwsIotPolicy::HandleShadowCallback(const std::string& update_type, std::string_view payload) {
    if (payload.empty()) return;
    std::string mutable_payload(payload);
    rapidjson::Document doc;
    doc.ParseInsitu(&mutable_payload[0]);
    if (doc.HasParseError()) return;

    uint32_t incoming_version = 0;
    if (doc.HasMember("version") && doc["version"].IsUint()) {
        incoming_version = doc["version"].GetUint();
    }
    if (incoming_version > 0 && incoming_version <= last_processed_shadow_version_) return;

    if (update_type == "delta") {
        if (doc.HasMember("state") && doc["state"].IsObject()) {
            last_processed_shadow_version_ = incoming_version;
            ProcessShadowDelta(doc["state"]);
        }
    } else if (update_type == "accepted") {
        if (!has_performed_initial_get_ && doc.HasMember("state")) {
            local_shadow_cache_.CopyFrom(doc["state"], local_shadow_cache_.GetAllocator());
            has_performed_initial_get_ = true;
        }
        last_processed_shadow_version_ = incoming_version;
        if (doc.HasMember("state") && doc["state"].IsObject() && doc["state"].HasMember("delta") && doc["state"]["delta"].IsObject()) {
            ProcessShadowDelta(doc["state"]["delta"]);
        }
    } else if (update_type == "rejected") {
        int error_code = 0;
        if (doc.HasMember("code") && doc["code"].IsInt()) error_code = doc["code"].GetInt();
        if (error_code == 404) {
            has_performed_initial_get_ = true;
        }
    }
}

void AwsIotPolicy::ProcessShadowDelta(const rapidjson::Value& delta_state) {
    if (!delta_state.IsObject() || !on_command_) return;
    rapidjson::Document report(rapidjson::kObjectType);
    auto& report_allocator = report.GetAllocator();
    bool command_actioned = false;

    if (!local_shadow_cache_.HasMember("reported")) {
        local_shadow_cache_.AddMember("reported", rapidjson::Value(rapidjson::kObjectType).Move(), local_shadow_cache_.GetAllocator());
    }
    auto& cached_reported = local_shadow_cache_["reported"];

    for (auto itr = delta_state.MemberBegin(); itr != delta_state.MemberEnd(); ++itr) {
        const std::string key = itr->name.GetString();
        const rapidjson::Value& raw_value = itr->value;
        Command command{CommandType::Unknown};

        if (key == "power" && raw_value.IsString()) {
            command.type = CommandType::SetPower;
            command.value = (strcmp(raw_value.GetString(), "ON") == 0);
        } else if (key == "intensity" && raw_value.IsInt()) {
            command.type = CommandType::SetIntensity;
            command.value = raw_value.GetInt();
        } else if (key == "config" && raw_value.IsObject()) {
            command.type = CommandType::SetConfig;
            rapidjson::StringBuffer buffer;
            rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
            raw_value.Accept(writer);
            command.value = std::string(buffer.GetString());
        }

        if (command.type != CommandType::Unknown) {
            if (on_command_(command)) {
                command_actioned = true;
                report.AddMember(rapidjson::Value(key.c_str(), report_allocator).Move(), rapidjson::Value(raw_value, report_allocator).Move(), report_allocator);
                rapidjson::Value cache_key(key.c_str(), local_shadow_cache_.GetAllocator());
                if (cached_reported.HasMember(cache_key)) {
                    cached_reported[cache_key].CopyFrom(raw_value, local_shadow_cache_.GetAllocator());
                } else {
                    cached_reported.AddMember(cache_key, rapidjson::Value(raw_value, local_shadow_cache_.GetAllocator()).Move(), local_shadow_cache_.GetAllocator());
                }
            }
        }
    }

    if (command_actioned) {
        rapidjson::StringBuffer buffer;
        rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
        report.Accept(writer);
        ReportState(buffer.GetString());
    }
}

void AwsIotPolicy::PollShadow() {
    if (has_performed_initial_get_) return;
    uint32_t retry_base = 5000;
    uint32_t max_retry = 30000;
    uint16_t max_attempts = 10;
    
    if (system_uptime::ExceedsMs(last_get_shadow_attempt_ms_, current_get_shadow_backoff_ms_)) {
        if (get_shadow_attempts_ >= max_attempts) {
            has_performed_initial_get_ = true;
            return;
        }
        if (client_ && client_->GetShadow()) {
            last_get_shadow_attempt_ms_ = system_uptime::GetMs();
            get_shadow_attempts_++;
            current_get_shadow_backoff_ms_ = std::min(current_get_shadow_backoff_ms_ + retry_base, max_retry);
        }
    }
}

bool AwsIotPolicy::ReportState(const std::string& state_payload, int qos) {
    if (!client_ || !client_->IsConnected()) return false;
    std::string shadow_payload = "{\"state\":{\"reported\":" + state_payload + "}}";
    return client_->UpdateShadow(shadow_payload, qos);
}

} // namespace visium
