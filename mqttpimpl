#ifndef AWS_IOT_MQTT_CLIENT_HPP_
#define AWS_IOT_MQTT_CLIENT_HPP_

#include <functional>
#include <string>
#include <string_view>
#include <vector>
#include <memory>
#include <cstdint>

// NO ESP-IDF specific headers or types here. This header is platform-agnostic.

namespace AwsIot {

// --- Constants ---
constexpr size_t kMaxEndpointLen = 256;
constexpr size_t kMaxClientIdLen = 128;
constexpr size_t kMaxThingNameLen = 128;
constexpr size_t kMaxTopicLen = 256;
constexpr size_t kMaxPayloadLen = 4096;
constexpr size_t kMaxSubs = 10;
constexpr size_t kMaxCertLen = 2048; // Using a fixed size for certificate buffers

// --- MQTT Protocol Version ---
enum class MqttProtocolVersion {
    V3_1_1,
    V5
};

// --- MQTT v5 Specific Properties ---
struct Mqtt5UserProperty {
    std::string key;
    std::string value;
};

// Forward declaration for the implementation class (PIMPL)
class AwsIotMqttClientImpl;

// --- Configuration ---
struct MqttConfig {
    // --- Connection Details (fixed-size buffers) ---
    char        aws_endpoint[kMaxEndpointLen] = {0};
    char        client_id[kMaxClientIdLen] = {0};
    char        thing_name[kMaxThingNameLen] = {0};
    uint16_t    port = 8883;

    // --- Certificate Buffers (fixed-size, require manual copy) ---
    char        root_ca_pem[kMaxCertLen] = {0};
    char        device_cert_pem[kMaxCertLen] = {0};
    char        private_key_pem[kMaxCertLen] = {0};

    // MQTT protocol version
    MqttProtocolVersion protocol_ver = MqttProtocolVersion::V3_1_1;

    // MQTT RX/TX Buffers
    int         rx_buffer_size = 4096;
    int         tx_buffer_size = 4096;

    // --- NEW: Reconnect Configuration ---
    // Set to true to disable the MQTT client's built-in automatic reconnect.
    // If disabled, the application is responsible for calling Connect() again
    // after receiving the on_disconnected callback.
    // Defaults to false (auto-reconnect enabled).
    bool        disable_auto_reconnect = false;

    // --- MQTT v5 Specific ---
    // How long, in seconds, the broker should store the session after disconnect.
    // A value of 0 means the session ends on disconnect.
    // A value of 0xFFFFFFFF means the session never expires.
    uint32_t    session_expiry_interval = 0; // Default to no persistence
};

// --- Callbacks ---
using MqttMessageCallback = std::function<void(const std::string& topic, std::string_view payload)>;
using StatusCallback = std::function<void()>;
using JobNotificationCallback = std::function<void(const std::string& job_id, const std::string& status, const std::string& document)>;
using ShadowUpdateCallback = std::function<void(const std::string& update_type, std::string_view payload)>;

// --- Main Class ---
class AwsIotMqttClient {
public: // Public Interface
    AwsIotMqttClient();
    ~AwsIotMqttClient();

    // Disable copy and move operations
    AwsIotMqttClient(const AwsIotMqttClient&) = delete;
    AwsIotMqttClient& operator=(const AwsIotMqttClient&) = delete;
    AwsIotMqttClient(AwsIotMqttClient&&) = delete;
    AwsIotMqttClient& operator=(AwsIotMqttClient&&) = delete;

    // --- Core Functionality ---
    bool Initialize(const MqttConfig& config);
    bool Connect();
    void Disconnect(uint32_t session_expiry_interval = 0); // MQTTv5 can override session expiry on disconnect
    bool IsConnected() const;

    // --- Publish/Subscribe ---
    bool Publish(const std::string& topic, const std::string& payload, int qos = 0, bool retain = false);
    bool Publish(const std::string& topic, std::string_view payload, int qos = 0, bool retain = false);
    bool Publish(const std::string& topic, const uint8_t* payload, size_t len, int qos = 0, bool retain = false);

    bool Subscribe(const std::string& topic_filter, int qos, MqttMessageCallback callback);
    bool Unsubscribe(const std::string& topic_filter);

    // --- AWS IoT Helpers ---
    // Shadow
    bool SubscribeToShadowUpdates(ShadowUpdateCallback callback);
    bool SubscribeToShadowGetResponses(ShadowUpdateCallback callback);
    bool UpdateShadow(const std::string& shadow_payload, int qos = 0);
    bool UpdateShadow(std::string_view shadow_payload, int qos = 0);
    bool GetShadow(const std::string& client_token = "");

    // Jobs
    bool SubscribeToJobs(JobNotificationCallback callback);
    bool UpdateJobStatus(const std::string& job_id, const std::string& status, const std::string& status_details_json = "{}");
    bool UpdateJobStatus(const std::string& job_id, const std::string& status, std::string_view status_details_json);

    // --- Setters for Callbacks ---
    void SetOnConnectedCallback(StatusCallback cb);
    void SetOnDisconnectedCallback(StatusCallback cb);

private:
    // Pointer to the implementation (PIMPL)
    std::unique_ptr<AwsIotMqttClientImpl> pimpl_;
};

} // namespace AwsIot

#endif // AWS_IOT_MQTT_CLIENT_HPP_
----------------------------------------

#include "aws_iot_mqtt_client.h"

// --- ESP-IDF Specific Headers ---
#include "esp_log.h"
#include "mqtt_client.h"
#include <mutex>
#include <atomic>
#include <vector>
#include <cstring>
#include <algorithm>
#include <inttypes.h> // For PRIu32 macro

// --- PIMPL Implementation ---
namespace AwsIot {

static const char* TAG = "AwsIotMqttClient";

// The implementation class holds all ESP-IDF specific details.
class AwsIotMqttClientImpl {
public:
    // --- Constructor & Destructor ---
    AwsIotMqttClientImpl();
    ~AwsIotMqttClientImpl();

    // --- Public Methods (called by the wrapper) ---
    bool Initialize(const MqttConfig& config);
    bool Connect();
    void Disconnect(uint32_t session_expiry_interval);
    bool IsConnected() const;
    bool Publish(const std::string& topic, const uint8_t* payload, size_t len, int qos, bool retain);
    bool Subscribe(const std::string& topic_filter, int qos, MqttMessageCallback callback);
    bool Unsubscribe(const std::string& topic_filter);

    // --- AWS Helpers ---
    bool GetShadowTopic(const std::string& operation, char* buffer, size_t buffer_size);
    bool GetJobsTopic(const std::string& job_id, const std::string& operation, char* buffer, size_t buffer_size);
    
    // --- Event Handler ---
    void MqttEventHandler(esp_mqtt_event_handle_t event);

    // --- Callbacks ---
    StatusCallback on_connected_cb_ = nullptr;
    StatusCallback on_disconnected_cb_ = nullptr;
    ShadowUpdateCallback shadow_update_cb_ = nullptr;
    ShadowUpdateCallback shadow_get_cb_ = nullptr;
    JobNotificationCallback job_notify_cb_ = nullptr;
    
    // --- Public Data for Wrapper Access ---
    MqttConfig config_;
    esp_mqtt_client_handle_t client_handle_{nullptr}; // Make handle accessible to the wrapper's implementation

private:
    // --- Private Data Members ---
    struct Subscription {
        std::string topic;
        int qos = 0;
        MqttMessageCallback callback;
    };

    std::mutex              mutex_;
    std::atomic<bool>       initialized_{false};
    std::atomic<bool>       connected_{false};
    std::atomic<bool>       connecting_{false};
    std::atomic<bool>       disconnect_requested_{false};
    std::vector<Subscription> subscriptions_;
    std::string             uri_;
    
    // --- Private Methods ---
    void CleanupMqttClient();
    bool ReinitEspClient();
    static void GlobalMqttEventHandler(void* handler_args, esp_event_base_t base, int32_t event_id, void* event_data);
    void OnConnected();
    void OnData(esp_mqtt_event_handle_t event);
    void OnDisconnect();
    void ResubscribePending();
};


// --- Implementation of AwsIotMqttClientImpl ---

AwsIotMqttClientImpl::AwsIotMqttClientImpl() = default;

AwsIotMqttClientImpl::~AwsIotMqttClientImpl() {
    // Ensure cleanup on destruction
    std::lock_guard<std::mutex> lock(mutex_);
    CleanupMqttClient();
}

void AwsIotMqttClientImpl::CleanupMqttClient() {
    // This function assumes the mutex is already held.
    if (client_handle_) {
        ESP_LOGI(TAG, "Cleaning up and destroying MQTT client handle.");
        esp_mqtt_client_stop(client_handle_);
        esp_mqtt_client_destroy(client_handle_);
        client_handle_ = nullptr;
    }
    connected_ = false;
    connecting_ = false;
}

// Re-initializes the ESP-IDF client. Assumes mutex is held.
bool AwsIotMqttClientImpl::ReinitEspClient() {
    // If a handle exists, it must be from a previous failed attempt or a disconnect. Clean it up.
    if (client_handle_) {
        CleanupMqttClient();
    }
    
    esp_mqtt_client_config_t mqtt_cfg = {};
    
    uri_ = "mqtts://" + std::string(config_.aws_endpoint) + ":" + std::to_string(config_.port);
    mqtt_cfg.broker.address.uri = uri_.c_str();

    mqtt_cfg.broker.verification.certificate = config_.root_ca_pem;
    mqtt_cfg.credentials.authentication.certificate = config_.device_cert_pem;
    mqtt_cfg.credentials.authentication.key = config_.private_key_pem;
    mqtt_cfg.credentials.client_id = config_.client_id;
    mqtt_cfg.buffer.size = config_.rx_buffer_size;
    mqtt_cfg.buffer.out_size = config_.tx_buffer_size;
    mqtt_cfg.network.disable_auto_reconnect = config_.disable_auto_reconnect;

    if (config_.protocol_ver == MqttProtocolVersion::V5) {
        mqtt_cfg.session.protocol_ver = MQTT_PROTOCOL_V_5;
    } else {
        mqtt_cfg.session.protocol_ver = MQTT_PROTOCOL_V_3_1_1;
    }
    
    client_handle_ = esp_mqtt_client_init(&mqtt_cfg);
    if (!client_handle_) {
        ESP_LOGE(TAG, "esp_mqtt_client_init() failed.");
        return false;
    }

    if (config_.protocol_ver == MqttProtocolVersion::V5) {
        esp_mqtt5_connection_property_config_t connect_property = {};
        connect_property.session_expiry_interval = config_.session_expiry_interval;
        connect_property.receive_maximum = 10;
        esp_mqtt5_client_set_connect_property(client_handle_, &connect_property);
    }
    
    esp_mqtt_client_register_event(client_handle_, (esp_mqtt_event_id_t)ESP_EVENT_ANY_ID, GlobalMqttEventHandler, this);
    return true;
}


bool AwsIotMqttClientImpl::Initialize(const MqttConfig& config) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (initialized_) {
        ESP_LOGW(TAG, "Already initialized.");
        return true;
    }
    
    if (config.aws_endpoint[0] == '\0' || config.client_id[0] == '\0' || 
        config.root_ca_pem[0] == '\0' || config.device_cert_pem[0] == '\0' || config.private_key_pem[0] == '\0') {
        ESP_LOGE(TAG, "Initialization failed: Endpoint, Client ID, or certificates are empty.");
        return false;
    }
    config_ = config;
    initialized_ = true;
    return true;
}

bool AwsIotMqttClientImpl::Connect() {
    std::lock_guard<std::mutex> lock(mutex_);
    if (!initialized_) {
        ESP_LOGE(TAG, "Cannot connect: Not initialized.");
        return false;
    }
    if (connected_ || connecting_) {
        ESP_LOGW(TAG, "Connect() called while already connected or connecting.");
        return true; // Return true as the goal is to be connected.
    }
    
    ESP_LOGI(TAG, "Attempting connection, re-initializing client for a clean state...");
    if (!ReinitEspClient()) {
        ESP_LOGE(TAG, "Failed to re-initialize the ESP MQTT client.");
        return false;
    }

    connecting_ = true;
    disconnect_requested_ = false;

    esp_err_t err = esp_mqtt_client_start(client_handle_);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "esp_mqtt_client_start() failed: %s", esp_err_to_name(err));
        CleanupMqttClient(); // Clean up the failed attempt.
        return false;
    }
    
    return true;
}

void AwsIotMqttClientImpl::Disconnect(uint32_t session_expiry_interval) {
    std::lock_guard<std::mutex> lock(mutex_);
    disconnect_requested_ = true;
    if (!client_handle_) {
        return;
    }
    
    if (config_.protocol_ver == MqttProtocolVersion::V5) {
        esp_mqtt5_disconnect_property_config_t disconnect_property = {};
        disconnect_property.session_expiry_interval = session_expiry_interval;
        esp_mqtt5_client_set_disconnect_property(client_handle_, &disconnect_property);
        ESP_LOGI(TAG, "MQTTv5 setting session expiry to %" PRIu32 " on disconnect.", session_expiry_interval);
    }
    
    ESP_LOGI(TAG, "User requested disconnect. Stopping and cleaning up client.");
    CleanupMqttClient();
}


bool AwsIotMqttClientImpl::IsConnected() const {
    return connected_.load();
}

bool AwsIotMqttClientImpl::Publish(const std::string& topic, const uint8_t* payload, size_t len, int qos, bool retain) {
    if (!IsConnected()) {
        ESP_LOGW(TAG, "Not connected. Cannot publish.");
        return false;
    }
    int msg_id = esp_mqtt_client_publish(client_handle_, topic.c_str(), (const char*)payload, len, qos, retain);
    if (msg_id == -1) {
        ESP_LOGE(TAG, "Failed to publish message to topic %s", topic.c_str());
        return false;
    }
    ESP_LOGD(TAG, "Published to %s, msg_id=%d", topic.c_str(), msg_id);
    return true;
}

bool AwsIotMqttClientImpl::Subscribe(const std::string& topic_filter, int qos, MqttMessageCallback callback) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = std::find_if(subscriptions_.begin(), subscriptions_.end(),
                           [&](const Subscription& s) { return s.topic == topic_filter; });

    if (it != subscriptions_.end()) {
        it->callback = std::move(callback);
        it->qos = qos;
    } else {
        if (subscriptions_.size() >= kMaxSubs) {
            ESP_LOGE(TAG, "Maximum number of subscriptions reached.");
            return false;
        }
        subscriptions_.push_back({topic_filter, qos, std::move(callback)});
    }
    
    if (IsConnected()) {
        esp_mqtt_client_subscribe(client_handle_, topic_filter.c_str(), qos);
    }
    return true;
}

bool AwsIotMqttClientImpl::Unsubscribe(const std::string& topic_filter) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = std::remove_if(subscriptions_.begin(), subscriptions_.end(),
                           [&](const Subscription& s) { return s.topic == topic_filter; });

    if (it == subscriptions_.end()) {
        ESP_LOGW(TAG, "Topic %s not found in subscriptions.", topic_filter.c_str());
        return false;
    }

    subscriptions_.erase(it, subscriptions_.end());

    if (IsConnected()) {
        esp_mqtt_client_unsubscribe(client_handle_, topic_filter.c_str());
    }
    
    return true;
}

void AwsIotMqttClientImpl::OnConnected() {
    std::lock_guard<std::mutex> lock(mutex_);
    connecting_ = false;
    connected_ = true;
    ResubscribePending();
    if (on_connected_cb_) {
        on_connected_cb_();
    }
}

void AwsIotMqttClientImpl::OnDisconnect() {
    bool was_connected = connected_.load();
    connected_ = false;
    connecting_ = false;
    
    if (was_connected && on_disconnected_cb_) {
        on_disconnected_cb_();
    }
}

void AwsIotMqttClientImpl::OnData(esp_mqtt_event_handle_t event) {
    std::string_view topic(event->topic, event->topic_len);
    std::string_view payload(event->data, event->data_len);

    std::lock_guard<std::mutex> lock(mutex_);
    bool handled = false;

    // --- AWS Shadow Topic Router ---
    char shadow_prefix_buf[kMaxTopicLen];
    snprintf(shadow_prefix_buf, sizeof(shadow_prefix_buf), "$aws/things/%s/shadow/", config_.thing_name);
    if (topic.rfind(shadow_prefix_buf, 0) == 0) {
        std::string_view suffix = topic.substr(strlen(shadow_prefix_buf));
        if (suffix.rfind("update/", 0) == 0 && shadow_update_cb_) {
            handled = true;
            shadow_update_cb_(std::string(suffix), payload);
        } else if (suffix.rfind("get/", 0) == 0 && shadow_get_cb_) {
            handled = true;
            shadow_get_cb_(std::string(suffix), payload);
        }
    }

    // --- AWS Jobs Topic Router ---
    if (!handled && job_notify_cb_) {
        char jobs_notify_buf[kMaxTopicLen];
        snprintf(jobs_notify_buf, sizeof(jobs_notify_buf), "$aws/things/%s/jobs/notify-next", config_.thing_name);
        if (topic == jobs_notify_buf) {
            handled = true;
            job_notify_cb_("unknown_job_id", "QUEUED", std::string(payload));
        }
    }

    // --- Generic Subscription Router ---
    if (!handled) {
        std::string topic_str(topic);
        for (const auto& sub : subscriptions_) {
            if (topic_str == sub.topic) {
                if (sub.callback) {
                    sub.callback(topic_str, payload);
                    handled = true;
                    break;
                }
            }
        }
    }
}


void AwsIotMqttClientImpl::ResubscribePending() {
    // This function assumes the mutex is already held.
    if (!IsConnected()) return;

    ESP_LOGI(TAG, "Resubscribing to %zu topics...", subscriptions_.size());
    for (const auto& sub : subscriptions_) {
        esp_mqtt_client_subscribe(client_handle_, sub.topic.c_str(), sub.qos);
    }
    // Also re-apply special AWS subscriptions
    if (shadow_update_cb_) {
        char topic[kMaxTopicLen];
        GetShadowTopic("update/#", topic, sizeof(topic));
        esp_mqtt_client_subscribe(client_handle_, topic, 1);
    }
    if (shadow_get_cb_) {
        char topic[kMaxTopicLen];
        GetShadowTopic("get/#", topic, sizeof(topic));
        esp_mqtt_client_subscribe(client_handle_, topic, 1);
    }
    if (job_notify_cb_) {
        char topic[kMaxTopicLen];
        snprintf(topic, sizeof(topic), "$aws/things/%s/jobs/notify-next", config_.thing_name);
        esp_mqtt_client_subscribe(client_handle_, topic, 1);
    }
}

void AwsIotMqttClientImpl::GlobalMqttEventHandler(void* handler_args, esp_event_base_t base, int32_t event_id, void* event_data) {
    auto* client = static_cast<AwsIotMqttClientImpl*>(handler_args);
    if(client) {
        client->MqttEventHandler(static_cast<esp_mqtt_event_handle_t>(event_data));
    }
}

void AwsIotMqttClientImpl::MqttEventHandler(esp_mqtt_event_handle_t event) {
    switch (event->event_id) {
        case MQTT_EVENT_CONNECTED:
            OnConnected();
            break;
        case MQTT_EVENT_DISCONNECTED:
            ESP_LOGW(TAG, "MQTT_EVENT_DISCONNECTED");
            OnDisconnect();
            break;
        case MQTT_EVENT_DATA:
             ESP_LOGD(TAG, "MQTT_EVENT_DATA received");
            OnData(event);
            break;
        case MQTT_EVENT_ERROR:
            ESP_LOGE(TAG, "MQTT_EVENT_ERROR");
            connecting_ = false; // An error during connection phase means we are no longer connecting
            if (event->error_handle && event->error_handle->error_type == MQTT_ERROR_TYPE_TCP_TRANSPORT) {
                 ESP_LOGE(TAG, "Last error from esp-tls: 0x%x", event->error_handle->esp_tls_last_esp_err);
            }
            break;
        case MQTT_EVENT_SUBSCRIBED: // Fall through
        case MQTT_EVENT_UNSUBSCRIBED: // Fall through
        case MQTT_EVENT_PUBLISHED: // Fall through
        default:
             ESP_LOGD(TAG, "Other event id: %d", (int)event->event_id);
            break;
    }
}


bool AwsIotMqttClientImpl::GetShadowTopic(const std::string& operation, char* buffer, size_t buffer_size) {
    int len = snprintf(buffer, buffer_size, "$aws/things/%s/shadow/%s", config_.thing_name, operation.c_str());
    return len > 0 && (size_t)len < buffer_size;
}

bool AwsIotMqttClientImpl::GetJobsTopic(const std::string& job_id, const std::string& operation, char* buffer, size_t buffer_size) {
    int len = snprintf(buffer, buffer_size, "$aws/things/%s/jobs/%s/%s", config_.thing_name, job_id.c_str(), operation.c_str());
    return len > 0 && (size_t)len < buffer_size;
}


// --- Implementation of AwsIotMqttClient (Public Wrapper) ---

AwsIotMqttClient::AwsIotMqttClient() : pimpl_(std::make_unique<AwsIotMqttClientImpl>()) {}
AwsIotMqttClient::~AwsIotMqttClient() = default;

bool AwsIotMqttClient::Initialize(const MqttConfig& config) {
    return pimpl_->Initialize(config);
}

bool AwsIotMqttClient::Connect() {
    return pimpl_->Connect();
}

void AwsIotMqttClient::Disconnect(uint32_t session_expiry_interval) {
    pimpl_->Disconnect(session_expiry_interval);
}

bool AwsIotMqttClient::IsConnected() const {
    return pimpl_->IsConnected();
}

bool AwsIotMqttClient::Publish(const std::string& topic, const std::string& payload, int qos, bool retain) {
    return pimpl_->Publish(topic, reinterpret_cast<const uint8_t*>(payload.c_str()), payload.length(), qos, retain);
}

bool AwsIotMqttClient::Publish(const std::string& topic, std::string_view payload, int qos, bool retain) {
    return pimpl_->Publish(topic, reinterpret_cast<const uint8_t*>(payload.data()), payload.length(), qos, retain);
}

bool AwsIotMqttClient::Publish(const std::string& topic, const uint8_t* payload, size_t len, int qos, bool retain) {
    return pimpl_->Publish(topic, payload, len, qos, retain);
}

bool AwsIotMqttClient::Subscribe(const std::string& topic_filter, int qos, MqttMessageCallback callback) {
    return pimpl_->Subscribe(topic_filter, qos, std::move(callback));
}

bool AwsIotMqttClient::Unsubscribe(const std::string& topic_filter) {
    return pimpl_->Unsubscribe(topic_filter);
}

void AwsIotMqttClient::SetOnConnectedCallback(StatusCallback cb) {
    pimpl_->on_connected_cb_ = std::move(cb);
}

void AwsIotMqttClient::SetOnDisconnectedCallback(StatusCallback cb) {
    pimpl_->on_disconnected_cb_ = std::move(cb);
}


// --- AWS IoT Helper Implementations ---

// FIX: These helpers now correctly call the public Subscribe method,
// which properly delegates to the implementation. This fixes the
// "inaccessible member" compilation error.

bool AwsIotMqttClient::SubscribeToShadowUpdates(ShadowUpdateCallback callback) {
    pimpl_->shadow_update_cb_ = std::move(callback);
    char topic[kMaxTopicLen];
    pimpl_->GetShadowTopic("update/#", topic, sizeof(topic));
    // Pass nullptr for the generic callback since the router in OnData will handle it.
    return Subscribe(topic, 1, nullptr); 
}

bool AwsIotMqttClient::SubscribeToShadowGetResponses(ShadowUpdateCallback callback) {
    pimpl_->shadow_get_cb_ = std::move(callback);
    char topic[kMaxTopicLen];
    pimpl_->GetShadowTopic("get/#", topic, sizeof(topic));
    return Subscribe(topic, 1, nullptr);
}

bool AwsIotMqttClient::SubscribeToJobs(JobNotificationCallback callback) {
    pimpl_->job_notify_cb_ = std::move(callback);
    char topic[kMaxTopicLen];
    snprintf(topic, sizeof(topic), "$aws/things/%s/jobs/notify-next", pimpl_->config_.thing_name);
    return Subscribe(topic, 1, nullptr);
}

bool AwsIotMqttClient::UpdateShadow(const std::string& shadow_payload, int qos) {
    return UpdateShadow(std::string_view(shadow_payload), qos);
}

bool AwsIotMqttClient::UpdateShadow(std::string_view shadow_payload, int qos) {
    char topic_buffer[kMaxTopicLen];
    if (!pimpl_->GetShadowTopic("update", topic_buffer, sizeof(topic_buffer))) {
        return false;
    }
    return Publish(std::string(topic_buffer), shadow_payload, qos);
}

bool AwsIotMqttClient::GetShadow(const std::string& client_token) {
    char topic_buffer[kMaxTopicLen];
    if (!pimpl_->GetShadowTopic("get", topic_buffer, sizeof(topic_buffer))) {
        return false;
    }
    return Publish(std::string(topic_buffer), std::string{}, 0);
}

bool AwsIotMqttClient::UpdateJobStatus(const std::string& job_id, const std::string& status, const std::string& status_details_json) {
    return UpdateJobStatus(job_id, status, std::string_view(status_details_json));
}

bool AwsIotMqttClient::UpdateJobStatus(const std::string& job_id, const std::string& status, std::string_view status_details_json) {
    char topic_buffer[kMaxTopicLen];
    if (!pimpl_->GetJobsTopic(job_id, "update", topic_buffer, sizeof(topic_buffer))) {
        return false;
    }
    std::string payload = "{\"status\":\"" + status + "\", \"statusDetails\": " + std::string(status_details_json) + "}";
    return Publish(std::string(topic_buffer), payload, 1);
}

} // namespace AwsIot
