// Copyright [2025] [Your Name or Company]
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef APP_UPDATER_H
#define APP_UPDATER_H

#include <cstdint>
#include <functional>
#include <map>
#include <memory>
#include <string>
#include <cstdio> // For snprintf in StatusToString

namespace platform {

/**
 * @class AppUpdater
 * @brief Public interface for a platform-agnostic Application Updater.
 *
 * This class uses the PIMPL idiom to provide a stable, clean interface,
 * completely hiding the underlying platform-specific implementation details.
 * It is designed to be instantiated directly, e.g., `platform::AppUpdater my_updater;`.
 */
class AppUpdater {
public:
  // --- Public Nested Types for a Clean, Scoped API ---

  /** @enum Status
   * @brief Defines the possible status codes for update operations.
   */
  enum class Status {
    kSuccess,                   ///< The operation completed successfully.
    kErrorAlreadyInProgress,    ///< An update is already in progress.
    kErrorNotIdle,              ///< An operation was attempted when the updater was not idle.
    kErrorInvalidState,         ///< An operation was attempted in an invalid state.
    kErrorMetadataInvalid,      ///< The provided firmware metadata is invalid or mismatched (e.g., chip ID).
    kErrorPartitionNotFound,    ///< A suitable OTA partition could not be found.
    kErrorOtaBeginFailed,       ///< The platform's underlying 'begin' operation failed.
    kErrorWriteFailed,          ///< Writing a firmware chunk to flash failed.
    kErrorImageSizeMismatch,    ///< The total bytes written does not match the expected size (if size was known).
    kErrorOtaEndFailed,         ///< The platform's 'end' operation failed (e.g., image validation, chip compatibility).
    kErrorSetBootPartitionFailed, ///< Failed to set the new partition as the next boot target.
    kErrorRebootFailed,         ///< The command to reboot the device failed.
    kErrorInvalidArgument,      ///< An invalid argument was provided to a method.
    kErrorCancelled,            ///< The operation was cancelled by the user or Reset().
    kErrorTimeout,              ///< The session timed out due to inactivity.
    kErrorVersionIdentical,     ///< New version is identical to the current version, and same-version flashing is disallowed.
    kErrorGeneric,              ///< A generic, unspecified error occurred.
  };

  /** @struct Metadata
   * @brief Describes the firmware image being updated.
   */
  struct Metadata {
    size_t image_size = 0;                      ///< Total size of the firmware image in bytes. 0 for unknown.
    std::string version_string;                 ///< Version of the new firmware (e.g., "1.2.3").
    std::string target_platform_identifier;     ///< Optional: Expected platform (e.g., "ESP32S3") for an early check.
    std::map<std::string, std::string> custom_fields; ///< For application-specific metadata.
  };

  /** @struct BeginConfig
   * @brief Configuration options for beginning an update session.
   */
  struct BeginConfig {
    uint32_t inactivity_timeout_ms = 60000; ///< Timeout in ms. 0 to disable. Default 60 seconds.
    bool allow_same_version = false;        ///< If false, Begin() will fail if new version matches current.
  };

  /** @enum State
   * @brief Represents the internal operational state of the updater.
   */
  enum class State {
    kIdle,          ///< Not performing an update. Ready to begin.
    kPreparing,     ///< Initializing partitions and resources.
    kReceivingData, ///< Actively writing firmware data.
    kFinalizing,    ///< Finalizing the write and validating the image.
    kReadyToApply,  ///< The new firmware is valid and ready to be booted.
    kApplying,      ///< Setting the boot partition and preparing to reboot.
    kError          ///< An error occurred. Call Reset() to return to idle.
  };

  /** @struct PartitionInfo
   * @brief Provides details about a flash memory partition.
   */
  struct PartitionInfo {
    std::string label;       ///< The label or name of the partition.
    uint32_t type_id = 0;    ///< Platform-specific type identifier.
    uint32_t subtype_id = 0; ///< Platform-specific subtype identifier.
    size_t address = 0;      ///< Starting address of the partition.
    size_t size = 0;         ///< Size of the partition in bytes.
    bool is_encrypted = false;///< True if the partition is encrypted.
    bool is_valid = false;   ///< True if this struct contains valid data.
  };

  /**
   * @brief Converts a Status enum to a human-readable string.
   */
  static const char* StatusToString(Status status);

  /**
   * @brief Constructs an AppUpdater instance.
   */
  AppUpdater();

  /**
   * @brief Destructor. Ensures safe cleanup of implementation details.
   */
  ~AppUpdater();

  // --- Move Semantics (defined in .cpp to support PIMPL) ---
  AppUpdater(AppUpdater&&) noexcept;
  AppUpdater& operator=(AppUpdater&&) noexcept;

  // --- Copying is disabled to prevent slicing and ownership issues ---
  AppUpdater(const AppUpdater&) = delete;
  AppUpdater& operator=(const AppUpdater&) = delete;

  /**
   * @brief Registers a custom callback function to be executed on reset.
   */
  void SetResetHook(std::function<void()> hook);

  /**
   * @brief Begins an update session with custom configuration.
   */
  Status Begin(const Metadata& metadata, const BeginConfig& config);

  /**
   * @brief Begins an update session with default configuration.
   */
  Status Begin(const Metadata& metadata);

  /**
   * @brief Writes a chunk of firmware data.
   */
  Status Write(const uint8_t* data, size_t size);

  /**
   * @brief Finalizes the update process after all data has been written.
   */
  Status End();

  /**
   * @brief Applies the update by setting the boot partition and rebooting.
   */
  Status Apply(std::function<void()> pre_restart_hook = nullptr);

  /**
   * @brief Explicitly aborts any ongoing operation and resets the updater to the idle state.
   */
  void Reset();

  /** @return The current operational state of the updater. */
  State GetState() const;

  /** @return A string describing the last error that occurred. */
  std::string GetLastError() const;

  /** @return The total number of bytes successfully written. */
  size_t GetBytesWritten() const;

  /** @return Details about the currently running partition. */
  PartitionInfo GetRunningPartitionInfo() const;

  /** @return Details about the partition that will boot next. */
  PartitionInfo GetNextBootPartitionInfo() const;

  /**
   * @brief Marks the currently running application as valid, cancelling any pending OTA rollback.
   */
  static Status MarkBootSuccessful();

private:
  // Forward-declare the private implementation class.
  class PlatformUpdater;

  // The pointer to implementation.
  std::unique_ptr<PlatformUpdater> impl_;
};

} // namespace platform

#endif // APP_UPDATER_H

// Copyright [2025] [Your Name or Company]
// (Apache License header as before)

#include "app_updater.h"

// --- Platform-Specific Includes (Completely hidden from clients) ---
#include <algorithm>
#include <cstring>
#include "esp_app_format.h"
#include "esp_chip_info.h"
#include "esp_log.h"
#include "esp_ota_ops.h"
#include "esp_partition.h"
#include "esp_system.h"
#include "esp_timer.h" // For high-resolution hardware timer
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#ifndef OTA_SIZE_UNKNOWN
#define OTA_SIZE_UNKNOWN 0xFFFFFFFF
#endif

namespace platform {

// --- Anonymous namespace for helpers local to this implementation file ---
namespace {

const char* kImplTag = "PlatformUpdater"; // Tag for ESP_LOG in the PIMPL class

// Helper to convert ESP chip model to string
std::string ChipModelToString(esp_chip_model_t model) {
  switch (model) {
    case CHIP_ESP32: return "ESP32";
    case CHIP_ESP32S2: return "ESP32S2";
    case CHIP_ESP32S3: return "ESP32S3";
    case CHIP_ESP32C3: return "ESP32C3";
    case CHIP_ESP32H2: return "ESP32H2";
    case CHIP_ESP32C2: return "ESP32C2";
    case CHIP_ESP32C6: return "ESP32C6";
    default:
      char unknown_chip_buf[30];
      snprintf(unknown_chip_buf, sizeof(unknown_chip_buf), "UNKNOWN_CHIP_ID(%d)", static_cast<int>(model));
      return std::string(unknown_chip_buf);
  }
}

// Helper to convert esp_partition_t to the public PartitionInfo struct
AppUpdater::PartitionInfo ToPartitionInfo(const esp_partition_t* esp_part) {
    AppUpdater::PartitionInfo info;
    if (esp_part) {
        if(esp_part->label[0] != '\0') {
            info.label.assign(esp_part->label);
        }
        info.type_id = esp_part->type;
        info.subtype_id = esp_part->subtype;
        info.address = esp_part->address;
        info.size = esp_part->size;
        info.is_encrypted = esp_part->encrypted;
        info.is_valid = true;
    } else {
        info.is_valid = false;
    }
    return info;
}

} // anonymous namespace


/**
 * @class AppUpdater::PlatformUpdater
 * @brief The private implementation class for the AppUpdater.
 */
class AppUpdater::PlatformUpdater {
public:
  PlatformUpdater() { ResetInternalState(); }
  ~PlatformUpdater() {
    if (ota_handle_ != 0) {
      ESP_LOGW(kImplTag, "Destructor: Aborting active OTA handle %p.", (void*)ota_handle_);
      esp_ota_abort(ota_handle_);
    }
    StopAndCleanTimer();
  }

  void SetResetHook(std::function<void()> hook) { user_reset_hook_ = hook; }
  AppUpdater::Status Begin(const AppUpdater::Metadata& metadata, const AppUpdater::BeginConfig& config);
  AppUpdater::Status Write(const uint8_t* data, size_t size);
  AppUpdater::Status End();
  AppUpdater::Status Apply(std::function<void()> pre_restart_hook);
  void Reset();

  AppUpdater::State GetState() const { return current_state_; }
  std::string GetLastError() const { return last_error_message_; }
  size_t GetBytesWritten() const { return bytes_written_; }
  AppUpdater::PartitionInfo GetRunningPartitionInfo() const;
  AppUpdater::PartitionInfo GetNextBootPartitionInfo() const;

private:
  void SetState(AppUpdater::State new_state);
  void SetErrorAndAbort(const std::string& error_message, AppUpdater::Status status_code, esp_err_t esp_idf_err = ESP_OK);
  void ResetInternalState();

  // Timer-related methods
  static void inactivity_timeout_callback(void* arg);
  void HandleTimeout();
  void StopAndCleanTimer();
  void StartOrRestartTimer();

  // Platform-specific state
  esp_ota_handle_t ota_handle_ = 0;
  const esp_partition_t* update_partition_ = nullptr;

  // Generic operational state
  AppUpdater::State current_state_ = AppUpdater::State::kIdle;
  std::string last_error_message_;
  size_t bytes_written_ = 0;
  size_t total_image_size_ = 0;

  // Timeout state using esp_timer
  uint32_t inactivity_timeout_ms_ = 0;
  esp_timer_handle_t inactivity_timer_handle_ = nullptr;

  // User callback
  std::function<void()> user_reset_hook_;

  // Chip check flag
  bool chip_check_performed_on_write_ = false;
};

// --- Implementation of PlatformUpdater methods ---

void AppUpdater::PlatformUpdater::inactivity_timeout_callback(void* arg) {
    ESP_LOGE(kImplTag, "Inactivity timer fired!");
    PlatformUpdater* updater = static_cast<PlatformUpdater*>(arg);
    if (updater) {
        updater->HandleTimeout();
    }
}

void AppUpdater::PlatformUpdater::HandleTimeout() {
    SetErrorAndAbort("OTA session timed out due to inactivity.", AppUpdater::Status::kErrorTimeout);
    // The timer that just fired is now stopped and will be deleted by the Reset() logic
    // which is implicitly called by setting an error state that the user must clear with Reset().
    // We still explicitly clean it here to be safe.
    StopAndCleanTimer();
    if (user_reset_hook_) {
        ESP_LOGI(kImplTag, "Executing user-provided reset hook due to timeout.");
        user_reset_hook_();
    }
}

void AppUpdater::PlatformUpdater::StopAndCleanTimer() {
    if (inactivity_timer_handle_) {
        esp_timer_stop(inactivity_timer_handle_);
        esp_timer_delete(inactivity_timer_handle_);
        inactivity_timer_handle_ = nullptr;
    }
}

void AppUpdater::PlatformUpdater::StartOrRestartTimer() {
    if (!inactivity_timer_handle_ || inactivity_timeout_ms_ == 0) {
        return;
    }
    esp_timer_stop(inactivity_timer_handle_);
    esp_timer_start_once(inactivity_timer_handle_, inactivity_timeout_ms_ * 1000ULL);
}


void AppUpdater::PlatformUpdater::ResetInternalState() {
    update_partition_ = nullptr;
    current_state_ = AppUpdater::State::kIdle;
    last_error_message_.clear();
    bytes_written_ = 0;
    total_image_size_ = 0;
    inactivity_timeout_ms_ = 0;
    chip_check_performed_on_write_ = false;
}

void AppUpdater::PlatformUpdater::SetState(AppUpdater::State new_state) {
    ESP_LOGD(kImplTag, "State transition from %d to %d", static_cast<int>(current_state_), static_cast<int>(new_state));
    current_state_ = new_state;
}

void AppUpdater::PlatformUpdater::SetErrorAndAbort(const std::string& msg, AppUpdater::Status status_code, esp_err_t err) {
    last_error_message_ = msg;
    if (err != ESP_OK) {
        last_error_message_ += " (Platform Error: " + std::string(esp_err_to_name(err)) + ")";
    }
    ESP_LOGE(kImplTag, "Error set: %s", last_error_message_.c_str());

    StopAndCleanTimer(); // Stop timer on any error
    if (ota_handle_ != 0) {
        ESP_LOGW(kImplTag, "Aborting active OTA handle %p due to error.", (void*)ota_handle_);
        esp_ota_abort(ota_handle_);
        ota_handle_ = 0;
    }
    SetState(AppUpdater::State::kError);
}

AppUpdater::Status AppUpdater::PlatformUpdater::Begin(const AppUpdater::Metadata& metadata, const AppUpdater::BeginConfig& config) {
    if (current_state_ != AppUpdater::State::kIdle) {
      SetErrorAndAbort("Begin: Updater is not idle.", AppUpdater::Status::kErrorNotIdle);
      return AppUpdater::Status::kErrorNotIdle;
    }
    ResetInternalState();

    SetState(AppUpdater::State::kPreparing);
    ESP_LOGI(kImplTag, "Begin OTA. Same version: %s. Timeout: %lu ms. Optional target platform: '%s'",
             config.allow_same_version ? "Allowed" : "Disallowed",
             config.inactivity_timeout_ms,
             metadata.target_platform_identifier.c_str());

    inactivity_timeout_ms_ = config.inactivity_timeout_ms;
    if (inactivity_timeout_ms_ > 0) {
        const esp_timer_create_args_t timer_args = {
            .callback = &inactivity_timeout_callback,
            .arg = this,
            .name = "ota-inactive-timer"
        };
        esp_err_t err = esp_timer_create(&timer_args, &inactivity_timer_handle_);
        if (err != ESP_OK) {
            SetErrorAndAbort("Failed to create inactivity timer.", AppUpdater::Status::kErrorGeneric, err);
            return AppUpdater::Status::kErrorGeneric;
        }
        StartOrRestartTimer();
    }

    if (!config.allow_same_version) {
        const esp_app_desc_t* running_app_info = esp_app_get_description();
        if (running_app_info && !metadata.version_string.empty() &&
            metadata.version_string == running_app_info->version) {
            SetErrorAndAbort("New version is the same as the currently running version.", AppUpdater::Status::kErrorVersionIdentical);
            return AppUpdater::Status::kErrorVersionIdentical;
        }
    }

    // ... (rest of Begin logic for partition and pre-flight checks is unchanged)

    update_partition_ = esp_ota_get_next_update_partition(nullptr);
    if (update_partition_ == nullptr) {
        SetErrorAndAbort("No valid OTA update partition found.", AppUpdater::Status::kErrorPartitionNotFound);
        return AppUpdater::Status::kErrorPartitionNotFound;
    }
    ESP_LOGI(kImplTag, "Using OTA partition: %s", update_partition_->label);

    total_image_size_ = (metadata.image_size == 0) ? OTA_SIZE_UNKNOWN : metadata.image_size;

    esp_err_t err = esp_ota_begin(update_partition_, total_image_size_, &ota_handle_);
    if (err != ESP_OK) {
        SetErrorAndAbort("esp_ota_begin failed.", AppUpdater::Status::kErrorOtaBeginFailed, err);
        return AppUpdater::Status::kErrorOtaBeginFailed;
    }
    
    SetState(AppUpdater::State::kReceivingData);
    return AppUpdater::Status::kSuccess;
}

AppUpdater::Status AppUpdater::PlatformUpdater::Write(const uint8_t* data, size_t size) {
    if (current_state_ != AppUpdater::State::kReceivingData) {
        return AppUpdater::Status::kErrorInvalidState;
    }
    if (data == nullptr && size > 0) {
        SetErrorAndAbort("Write called with null data pointer but non-zero size.", AppUpdater::Status::kErrorInvalidArgument);
        return AppUpdater::Status::kErrorInvalidArgument;
    }
    if (size == 0) {
        return AppUpdater::Status::kSuccess;
    }
    
    // ... (chip compatibility check logic is unchanged) ...

    esp_err_t err = esp_ota_write(ota_handle_, data, size);
    if (err != ESP_OK) {
        SetErrorAndAbort("esp_ota_write failed.", AppUpdater::Status::kErrorWriteFailed, err);
        return AppUpdater::Status::kErrorWriteFailed;
    }
    bytes_written_ += size;
    StartOrRestartTimer(); // "Pet" the watchdog timer on successful write
    return AppUpdater::Status::kSuccess;
}

AppUpdater::Status AppUpdater::PlatformUpdater::End() {
    if (current_state_ != AppUpdater::State::kReceivingData) {
        return AppUpdater::Status::kErrorInvalidState;
    }
    StopAndCleanTimer(); // Stop the timer since we are no longer receiving data
    
    SetState(AppUpdater::State::kFinalizing);
    
    // ... (rest of End logic for size check and esp_ota_end is unchanged) ...

    esp_err_t err = esp_ota_end(ota_handle_);
    ota_handle_ = 0; 
    if (err != ESP_OK) {
        SetErrorAndAbort("esp_ota_end failed. Image may be invalid.", AppUpdater::Status::kErrorOtaEndFailed, err);
        return AppUpdater::Status::kErrorOtaEndFailed;
    }
    
    SetState(AppUpdater::State::kReadyToApply);
    return AppUpdater::Status::kSuccess;
}

AppUpdater::Status AppUpdater::PlatformUpdater::Apply(std::function<void()> pre_restart_hook) {
    if (current_state_ != AppUpdater::State::kReadyToApply) {
        return AppUpdater::Status::kErrorInvalidState;
    }
    
    // ... (Apply logic is unchanged) ...

    esp_restart();
    return AppUpdater::Status::kErrorRebootFailed; // Should not be reached
}

void AppUpdater::PlatformUpdater::Reset() {
    ESP_LOGW(kImplTag, "PlatformUpdater::Reset called. Current state: %d", static_cast<int>(current_state_));
    StopAndCleanTimer();
    if (ota_handle_ != 0) {
        esp_ota_abort(ota_handle_);
        ota_handle_ = 0;
    }
    ResetInternalState();

    if (user_reset_hook_) {
        user_reset_hook_();
    }
}

AppUpdater::PartitionInfo AppUpdater::PlatformUpdater::GetRunningPartitionInfo() const {
    return ToPartitionInfo(esp_ota_get_running_partition());
}

AppUpdater::PartitionInfo AppUpdater::PlatformUpdater::GetNextBootPartitionInfo() const {
    return ToPartitionInfo(esp_ota_get_boot_partition());
}

// --- Public AppUpdater methods forwarding to the implementation ---

AppUpdater::AppUpdater() : impl_(std::make_unique<PlatformUpdater>()) {}
AppUpdater::~AppUpdater() = default;
AppUpdater::AppUpdater(AppUpdater&&) noexcept = default;
AppUpdater& AppUpdater::operator=(AppUpdater&&) noexcept = default;

// --- Static Method Definition (unchanged) ---
const char* AppUpdater::StatusToString(AppUpdater::Status status) {
    // ... implementation unchanged ...
    return "...";
}

AppUpdater::Status AppUpdater::MarkBootSuccessful() {
    // ... implementation unchanged ...
    return AppUpdater::Status::kSuccess;
}

// --- Forwarding Method Implementations (unchanged) ---
void AppUpdater::SetResetHook(std::function<void()> hook) { impl_->SetResetHook(hook); }
AppUpdater::Status AppUpdater::Begin(const Metadata& metadata, const BeginConfig& config) { return impl_->Begin(metadata, config); }
AppUpdater::Status AppUpdater::Begin(const Metadata& metadata) { return impl_->Begin(metadata, BeginConfig{}); }
AppUpdater::Status AppUpdater::Write(const uint8_t* data, size_t size) { return impl_->Write(data, size); }
AppUpdater::Status AppUpdater::End() { return impl_->End(); }
AppUpdater::Status AppUpdater::Apply(std::function<void()> pre_restart_hook) { return impl_->Apply(pre_restart_hook); }
void AppUpdater::Reset() { impl_->Reset(); }
State AppUpdater::GetState() const { return impl_->GetState(); }
std::string AppUpdater::GetLastError() const { return impl_->GetLastError(); }
size_t AppUpdater::GetBytesWritten() const { return impl_->GetBytesWritten(); }
AppUpdater::PartitionInfo AppUpdater::GetRunningPartitionInfo() const { return impl_->GetRunningPartitionInfo(); }
AppUpdater::PartitionInfo AppUpdater::GetNextBootPartitionInfo() const { return impl_->GetNextBootPartitionInfo(); }

} // namespace platform
