/**
 * @file https_client.h
 * @brief Defines the HttpsClient class for HTTPS communication. Platform-agnostic header.
 * This header file contains no platform-specific (e.g., ESP-IDF) types or includes.
 * @author Gemini
 * @date 2025-04-24 Current time is Friday, April 25, 2025 at 2:58:13 AM IST.
 */
#ifndef HTTPS_CLIENT_H
#define HTTPS_CLIENT_H

#include <functional>
#include <string_view>
#include <map>
#include <array>
#include <cstddef> // For size_t
#include <cstdint> // For uint8_t etc.

// --- Configuration Constants ---

/** @brief Maximum supported length for a full URL passed to request methods. */
constexpr size_t kHttpsClientMaxUrlLength = 512;
/** @brief Maximum supported length for an HTTP header key name used in internal buffers. */
constexpr size_t kHttpsClientMaxHeaderKeyLen = 64;
/** @brief Maximum supported length for an HTTP header value used in internal buffers. */
constexpr size_t kHttpsClientMaxHeaderValueLen = 256;

/**
 * @class HttpsClient
 * @brief Provides a C++ wrapper for HTTPS communication, abstracting the underlying implementation.
 *
 * Handles GET, POST, PUT, PATCH requests with optional server verification.
 * Supports persistent connections and streaming via callbacks.
 * Uses fixed-size buffers (defined by constexpr limits) for URL construction and header processing
 * to minimize heap usage within the wrapper. A temporary std::vector (heap) is used
 * internally for the chunk buffer during streaming uploads.
 * Follows Google C++ Style naming conventions.
 * The header file is platform-agnostic.
 *
 * @note Network operations performed by this client are BLOCKING the calling task.
 * For non-blocking application behavior, instantiate and call HttpsClient methods
 * from a dedicated FreeRTOS task.
 * @warning Uses std::vector for stream upload buffer; heap allocation failure during
 * its resize() operation will likely cause program termination (abort) in typical
 * embedded builds where C++ exceptions are disabled (`-fno-exceptions`). Ensure sufficient
 * heap is available.
 */
class HttpsClient {
 public:
  /**
   * @brief Status codes returned by HttpsClient methods and callbacks. Platform-agnostic.
   */
  enum class Status {
    kOk = 0,             ///< Operation successful.
    kFail,               ///< Generic failure.
    kInvalidArgument,    ///< Invalid argument provided to the HttpsClient method.
    kNotInitialized,     ///< Client handle is not initialized (Open not called or failed/closed).
    kAlreadyInitialized, ///< Open() called when already open.
    kNoMemory,           ///< Memory allocation failed (e.g., from underlying libs or internal vector).
    kTimeout,            ///< Operation timed out.
    kNetworkError,       ///< Lower-level network error (DNS, TCP, socket, etc.).
    kConnectionError,    ///< Failed to establish connection or connection lost.
    kTlsError,           ///< TLS handshake or encryption/decryption error.
    kHttpError,          ///< HTTP protocol error (parsing, redirects handled internally, etc.).
    kResponseError,      ///< Error indicated by HTTP status code (e.g., 4xx, 5xx). (Method might still return kOk)
    kStreamError,        ///< Error during request or response streaming (e.g., callback error, unexpected EOF).
    kBufferTooSmall,     ///< Provided buffer/limit was too small (e.g., URL length, Header length).
    kUnsupported         ///< Feature or operation not supported by the implementation.
  };

  /**
   * @brief Standard HTTP methods supported by the client. Platform-agnostic.
   */
  enum class HttpMethod {
      kGet,
      kPost,
      kPut,
      kPatch
      // Add kDelete, kHead, kOptions etc. here if needed and implemented
  };

  /**
   * @brief Callback function type for receiving response body data in chunks.
   * @param data Pointer to the data chunk received. Not null-terminated. May not be valid after callback returns.
   * @param len Length of the data chunk in bytes.
   * @param user_context User-provided context pointer (from Config::user_context).
   * @return HttpsClient::Status Should return HttpsClient::Status::kOk on success.
   * Returning any other status will signal an error and attempt to abort the request.
   */
  using DataReceivedCallback =
      std::function<Status(const char* data, size_t len, void* user_context)>;

  /**
   * @brief Callback function type for providing request body data in chunks for streaming uploads.
   * @param buffer Buffer to write the chunk data into.
   * @param max_len Maximum number of bytes that can be written into the buffer (equals configured TX buffer size).
   * @param user_context User-provided context pointer (from Config::user_context).
   * @return int The number of bytes written into the buffer (must be <= max_len).
   * Return 0 to indicate the end of data (EOF). All data specified by Content-Length must have been sent.
   * Return a negative value to indicate an error condition, which will abort the upload.
   */
  using DataProviderCallback =
      std::function<int(char* buffer, size_t max_len, void* user_context)>;


  /**
   * @brief Configuration structure used when calling Open(). Contains platform-agnostic settings.
   */
  struct Config {
    /** @brief RX buffer size for underlying implementation. Affects max chunk size for received data/headers. Must be > 0. */
    size_t buffer_size_rx_bytes;
    /** @brief TX buffer size for underlying implementation. Affects stream upload chunk buffer size. Must be > 0. */
    size_t buffer_size_tx_bytes;
    /** @brief Set to true to enable server certificate verification (recommended). */
    bool verify_server = true;
    /** @brief Pointer to the server's root CA certificate(s) in PEM format (required if verify_server is true). Null otherwise. String must persist. */
    const char* server_cert_pem = nullptr;
    /** @brief Connection and request timeout in milliseconds. */
    int timeout_ms = 10000;
    /** @brief TCP Keep-Alive idle time in seconds before sending probes. */
    int keep_alive_idle_sec = 5;
    /** @brief TCP Keep-Alive interval in seconds between probes. */
    int keep_alive_interval_sec = 5;
    /** @brief TCP Keep-Alive number of probes before timing out. */
    int keep_alive_count = 3;
    /** @brief Optional user context pointer passed unmodified to all callbacks. */
    void* user_context = nullptr;
  };

  /**
   * @brief Structure to hold response information obtained after a request.
   */
  struct ResponseInfo {
      /** @brief HTTP status code returned by the server (e.g., 200, 404). */
      int status_code = 0;
      /** @brief Content-Length value from the response headers (-1 if not present or chunked). */
      long long content_length = -1;
      /** @brief Flag indicating if the server sent a 'Connection: close' header. */
      bool connection_close = false;
  };

  /** @brief Type alias for HTTP request headers map. Keys/Values should be valid views. */
  using Headers = std::map<std::string_view, std::string_view>;

  /**
   * @brief Default constructor. Initializes the client state.
   */
  HttpsClient();

  /**
   * @brief Destructor. Ensures resources are released by calling Close().
   */
  ~HttpsClient();

  // Disable copy/move semantics to prevent issues with resource handling.
  HttpsClient(const HttpsClient&) = delete;
  HttpsClient& operator=(const HttpsClient&) = delete;
  HttpsClient(HttpsClient&&) = delete;
  HttpsClient& operator=(HttpsClient&&) = delete;

  // --- Public API ---

  /**
   * @brief Initializes the client, allocates underlying resources based on the platform. BLOCKING.
   * @param config Configuration settings for this client instance. Buffer sizes must be specified.
   * @return Status::kOk on success, appropriate error status otherwise.
   */
  Status Open(const Config& config);

  /**
   * @brief Closes any open connection and releases all associated resources. BLOCKING (potentially).
   * Safe to call even if already closed or never opened.
   * @return Status::kOk on success (even if already closed), appropriate error status on cleanup failure.
   */
  Status Close();

  /**
   * @brief Performs an HTTP GET request using the full URL. BLOCKING.
   * @param url The **full** URL for the request (e.g., "https://example.com/data"). Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers. Keys/Values must be <= respective max length constants.
   * @param on_data_received Callback function for response body chunks. Can be nullptr if body is ignored.
   * @param response_info Optional pointer to store response details (status code, content length).
   * @return Status::kOk if the request cycle completed without transport/protocol errors. Check response_info->status_code for HTTP success (2xx).
   */
  Status Get(std::string_view url, const Headers& headers,
             DataReceivedCallback on_data_received,
             ResponseInfo* response_info = nullptr);

  /**
   * @brief Performs an HTTP POST request using the full URL. BLOCKING.
   * @param url The **full** URL for the request. Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers (should include 'Content-Type'). Keys/Values must be <= respective max length constants.
   * @param post_data The entire request body data.
   * @param on_data_received Callback for response body chunks (can be nullptr).
   * @param response_info Optional pointer to store response details.
   * @return Status::kOk if request cycle completed, check response_info->status_code for HTTP success.
   */
  Status Post(std::string_view url, const Headers& headers,
              std::string_view post_data,
              DataReceivedCallback on_data_received,
              ResponseInfo* response_info = nullptr);

  /**
   * @brief Performs an HTTP POST request with streaming body using the full URL. BLOCKING.
   * @param url The **full** URL for the request. Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers (MUST include 'Content-Length'). Keys/Values must be <= respective max length constants.
   * @param total_body_length The total size in bytes of the request body.
   * @param data_provider Callback function to provide request body chunks. Must not be nullptr.
   * @param on_data_received Callback for response body chunks (can be nullptr).
   * @param response_info Optional pointer to store response details.
   * @return Status::kOk if request/response cycle completed, check response_info->status_code for HTTP success.
   */
  Status PostStream(std::string_view url, const Headers& headers,
                    size_t total_body_length,
                    DataProviderCallback data_provider,
                    DataReceivedCallback on_data_received,
                    ResponseInfo* response_info = nullptr);

  /**
   * @brief Performs an HTTP PUT request using the full URL. BLOCKING.
   * @param url The **full** URL for the request. Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers (should include 'Content-Type'). Keys/Values must be <= respective max length constants.
   * @param put_data The entire request body data.
   * @param on_data_received Callback for response body chunks (can be nullptr).
   * @param response_info Optional pointer to store response details.
   * @return Status::kOk if request cycle completed, check response_info->status_code for HTTP success.
   */
  Status Put(std::string_view url, const Headers& headers,
             std::string_view put_data,
             DataReceivedCallback on_data_received,
             ResponseInfo* response_info = nullptr);

  /**
   * @brief Performs an HTTP PUT request with streaming body using the full URL. BLOCKING.
   * @param url The **full** URL for the request. Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers (MUST include 'Content-Length'). Keys/Values must be <= respective max length constants.
   * @param total_body_length The total size in bytes of the request body.
   * @param data_provider Callback function to provide request body chunks. Must not be nullptr.
   * @param on_data_received Callback for response body chunks (can be nullptr).
   * @param response_info Optional pointer to store response details.
   * @return Status::kOk if request/response cycle completed, check response_info->status_code for HTTP success.
   */
  Status PutStream(std::string_view url, const Headers& headers,
                   size_t total_body_length,
                   DataProviderCallback data_provider,
                   DataReceivedCallback on_data_received,
                   ResponseInfo* response_info = nullptr);

  /**
   * @brief Performs an HTTP PATCH request using the full URL. BLOCKING.
   * @param url The **full** URL for the request. Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers (should include 'Content-Type'). Keys/Values must be <= respective max length constants.
   * @param patch_data The entire request body data.
   * @param on_data_received Callback for response body chunks (can be nullptr).
   * @param response_info Optional pointer to store response details.
   * @return Status::kOk if request cycle completed, check response_info->status_code for HTTP success.
   */
  Status Patch(std::string_view url, const Headers& headers,
               std::string_view patch_data,
               DataReceivedCallback on_data_received,
               ResponseInfo* response_info = nullptr);

  /**
   * @brief Converts an HttpsClient::Status enum value to a descriptive string literal.
   * Useful for logging.
   * @param status The status code to convert.
   * @return A null-terminated string describing the status. Never returns null.
   */
  static const char* StatusToString(Status status);


 private:
   /**
    * @brief Opaque pointer holding the underlying platform-specific client handle.
    * Managed internally, typically stores an esp_http_client_handle_t.
    * Renamed from impl_ as per user request.
    */
   void* client_handle_ = nullptr;

   /** @brief Internal structure holding context passed to platform event handlers. */
   struct RequestContext {
        /** @brief User callback for received data chunks. */
        DataReceivedCallback on_data_received = nullptr;
        /** @brief User context pointer from Config. */
        void* user_context = nullptr;
        /** @brief Pointer to user's ResponseInfo struct for the current request. */
        ResponseInfo* response_info_ptr = nullptr;
   };
   /** @brief Context for the currently executing request. */
   RequestContext current_request_ctx_;

   /** @brief Transmit buffer size configured in Open(), used for sizing stream upload buffer. */
   size_t tx_buffer_size_ = 0;

   // --- Private Member Functions (Internal Helpers) ---

  /**
   * @brief Internal helper to perform non-streaming HTTP requests.
   * Handles setting URL, method, headers, body, and executing the request.
   * @param url The full URL for the request.
   * @param method The generic HTTP method (HttpsClient::HttpMethod).
   * @param headers Request headers.
   * @param request_body Request body data (empty for GET).
   * @param response_info Pointer to store response details.
   * @return Status indicating success or failure of the operation.
   */
   Status PerformRequestInternal(std::string_view url,
                                 HttpMethod method,
                                 const Headers& headers,
                                 std::string_view request_body,
                                 ResponseInfo* response_info);

  /**
   * @brief Internal helper to perform streaming upload HTTP requests.
   * Handles setting URL, method, headers, opening connection, streaming body,
   * fetching response, and closing connection.
   * @param url The full URL for the request.
   * @param method The generic HTTP method (HttpsClient::HttpMethod).
   * @param headers Request headers (must include Content-Length).
   * @param total_body_length Total size of the request body to be sent.
   * @param data_provider Callback function to provide request body chunks.
   * @param response_info Pointer to store response details.
   * @return Status indicating success or failure of the operation.
   */
   Status PerformStreamUploadInternal(std::string_view url,
                                     HttpMethod method,
                                     const Headers& headers,
                                     size_t total_body_length,
                                     DataProviderCallback data_provider,
                                     ResponseInfo* response_info);
};

#endif // HTTPS_CLIENT_H

--------------------------------------------

/**
 * @file https_client.cpp
 * @brief Implements the HttpsClient class using ESP-IDF's esp_http_client.
 * All platform-specific code is contained within this file.
 * @author Gemini
 * @date 2025-04-24 Current time is Friday, April 25, 2025 at 2:58:13 AM IST.
 */
#include "https_client.h" // Include the platform-agnostic header

#include <cstring> // For memcpy, strlen, strcasecmp
#include <cstdio>  // For snprintf
#include <array>   // For stack arrays for headers/URL
#include <vector>  // For temporary chunk buffer (heap allocated)
#include <new>     // For std::nothrow (though not needed for client_handle_ alloc)

// --- ESP-IDF Specific Includes ---
#include "esp_http_client.h"
#include "esp_log.h"
#include "esp_err.h"
#include "errno.h" // Potentially useful for more detailed socket errors

// Logging Tag
static const char* TAG = "HttpsClient";

// --- Platform Specific Mappings and Definitions ---

/**
 * @brief Maps the platform-agnostic HttpsClient::HttpMethod to the ESP-IDF specific esp_http_client_method_t.
 * @param method The HttpsClient::HttpMethod value.
 * @return The corresponding esp_http_client_method_t value. Defaults to GET for unknown values.
 */
static esp_http_client_method_t MapHttpMethodToEspMethod(HttpsClient::HttpMethod method) {
    switch (method) {
        case HttpsClient::HttpMethod::kGet:    return HTTP_METHOD_GET;
        case HttpsClient::HttpMethod::kPost:   return HTTP_METHOD_POST;
        case HttpsClient::HttpMethod::kPut:    return HTTP_METHOD_PUT;
        case HttpsClient::HttpMethod::kPatch:  return HTTP_METHOD_PATCH;
        default:
            ESP_LOGW(TAG, "Unsupported HttpMethod enum value (%d), defaulting to GET.", static_cast<int>(method));
            return HTTP_METHOD_GET;
    }
}

/**
 * @brief Maps ESP-IDF error codes (esp_err_t) to platform-agnostic HttpsClient::Status codes.
 * @param err The esp_err_t code returned by an ESP-IDF function.
 * @return The corresponding HttpsClient::Status enum value.
 */
static HttpsClient::Status MapEspErrorToStatus(esp_err_t err) {
    switch (err) {
        case ESP_OK: return HttpsClient::Status::kOk;
        case ESP_ERR_INVALID_ARG: case ESP_ERR_HTTP_INVALID_METHOD: case ESP_ERR_HTTP_INVALID_HEADER:
            return HttpsClient::Status::kInvalidArgument;
        case ESP_ERR_NO_MEM: return HttpsClient::Status::kNoMemory;
        case ESP_ERR_TIMEOUT: return HttpsClient::Status::kTimeout;
        case ESP_ERR_HTTP_CONNECT: case ESP_ERR_HTTP_CONNECTING: case ESP_ERR_ESP_TLS_FAILED_CONNECT:
            return HttpsClient::Status::kConnectionError;
        case ESP_ERR_HTTP_SOCKET_ERR: return HttpsClient::Status::kNetworkError;
        case ESP_FAIL: return HttpsClient::Status::kFail;
        case ESP_ERR_ESP_TLS_HANDSHAKE: case ESP_ERR_ESP_TLS_PK_PARSE: case ESP_ERR_ESP_TLS_CA_CERT:
            return HttpsClient::Status::kTlsError;
        case ESP_ERR_HTTP_PARSE: case ESP_ERR_HTTP_HEADERS: case ESP_ERR_HTTP_REDIRECT:
            return HttpsClient::Status::kHttpError;
        default:
            ESP_LOGW(TAG, "Unmapped esp_err_t: %d (%s)", err, esp_err_to_name(err));
            if (err > ESP_ERR_HTTP_BASE && err <= ESP_ERR_HTTP_MAX) return HttpsClient::Status::kHttpError;
            if (err > ESP_ERR_ESP_TLS_BASE && err <= ESP_ERR_ESP_TLS_MAX) return HttpsClient::Status::kTlsError;
            return HttpsClient::Status::kFail;
    }
}

/**
 * @brief Static event handler callback passed to esp_http_client.
 * Bridges to the HttpsClient instance context and user callbacks.
 * @param evt Pointer to the HTTP client event data.
 * @return esp_err_t ESP_OK on success, ESP_FAIL to abort request.
 */
static esp_err_t PlatformEventHandler(esp_http_client_event_t *evt) {
    HttpsClient::RequestContext* req_ctx = static_cast<HttpsClient::RequestContext*>(evt->user_data);
    if (!req_ctx) { return ESP_OK; }

    switch (evt->event_id) {
        case HTTP_EVENT_ERROR: ESP_LOGD(TAG, "PlatformEventHandler: HTTP_EVENT_ERROR"); break;
        case HTTP_EVENT_ON_CONNECTED: ESP_LOGD(TAG, "PlatformEventHandler: HTTP_EVENT_ON_CONNECTED"); break;
        case HTTP_EVENT_HEADER_SENT: ESP_LOGD(TAG, "PlatformEventHandler: HTTP_EVENT_HEADER_SENT"); break;
        case HTTP_EVENT_ON_HEADER:
             ESP_LOGD(TAG, "PlatformEventHandler: ON_HEADER: %s: %s", evt->header_key, evt->header_value);
             if (req_ctx->response_info_ptr != nullptr) {
                 if (strcasecmp(evt->header_key, "Connection") == 0 && strcasecmp(evt->header_value, "close") == 0) {
                     req_ctx->response_info_ptr->connection_close = true;
                 }
             }
            break;
        case HTTP_EVENT_ON_DATA:
            ESP_LOGD(TAG, "PlatformEventHandler: ON_DATA len=%d", evt->data_len);
            if (req_ctx->on_data_received != nullptr && evt->data_len > 0 && evt->data != nullptr) {
                HttpsClient::Status user_cb_status = req_ctx->on_data_received(
                    static_cast<const char*>(evt->data), static_cast<size_t>(evt->data_len), req_ctx->user_context);
                if (user_cb_status != HttpsClient::Status::kOk) {
                    ESP_LOGE(TAG, "User data callback returned error: %s", HttpsClient::StatusToString(user_cb_status));
                    return ESP_FAIL;
                }
            }
            break;
        case HTTP_EVENT_ON_FINISH: ESP_LOGD(TAG, "PlatformEventHandler: HTTP_EVENT_ON_FINISH"); break;
        case HTTP_EVENT_DISCONNECTED: ESP_LOGD(TAG, "PlatformEventHandler: HTTP_EVENT_DISCONNECTED"); break;
        case HTTP_EVENT_REDIRECT:
             ESP_LOGD(TAG, "PlatformEventHandler: REDIRECT");
             esp_http_client_set_redirection(evt->client);
             break;
        default: ESP_LOGD(TAG, "PlatformEventHandler: Unhandled Event: %d", evt->event_id); break;
    }
    return ESP_OK;
}


// --- HttpsClient Member Function Implementations ---

HttpsClient::HttpsClient() : client_handle_(nullptr), tx_buffer_size_(0) {
    // No base_url members to initialize
    current_request_ctx_.on_data_received = nullptr;
    current_request_ctx_.user_context = nullptr;
    current_request_ctx_.response_info_ptr = nullptr;
}

HttpsClient::~HttpsClient() {
    Close();
}

HttpsClient::Status HttpsClient::Open(const Config& config) {
    if (client_handle_ != nullptr) {
        ESP_LOGW(TAG, "Open: Client already open.");
        return Status::kAlreadyInitialized;
    }
    // Validate buffer sizes first
    if (config.buffer_size_rx_bytes == 0 || config.buffer_size_tx_bytes == 0) {
        ESP_LOGE(TAG, "Open: Invalid config - Buffer sizes required and must be non-zero.");
        return Status::kInvalidArgument;
    }
    // Validate cert config if verification enabled
    if (config.verify_server && !config.server_cert_pem) {
        ESP_LOGE(TAG, "Open: Server verification enabled, but server_cert_pem is NULL.");
        return Status::kInvalidArgument;
    }

    // --- No base URL stored ---
    tx_buffer_size_ = config.buffer_size_tx_bytes; // Still need TX size for stream buffer

    // Configure ESP-IDF client
    esp_http_client_config_t esp_config = {};

    // Use an internal dummy URL just to satisfy esp_http_client_init non-NULL requirement
    const char* kInternalDummyUrl = "http://dummy.invalid/"; // Internal detail
    esp_config.url = kInternalDummyUrl;

    // Set configuration from Config struct
    esp_config.buffer_size = config.buffer_size_rx_bytes;
    esp_config.buffer_size_tx = config.buffer_size_tx_bytes;
    esp_config.timeout_ms = config.timeout_ms;
    esp_config.keep_alive_enable = true;
    esp_config.keep_alive_idle = config.keep_alive_idle_sec;
    esp_config.keep_alive_interval = config.keep_alive_interval_sec;
    esp_config.keep_alive_count = config.keep_alive_count;
    esp_config.user_data = &current_request_ctx_;
    esp_config.event_handler = PlatformEventHandler;

    if (config.verify_server) {
        esp_config.cert_pem = config.server_cert_pem;
        esp_config.skip_cert_common_name_check = false;
    } else {
        ESP_LOGW(TAG, "Open: Server certificate verification is DISABLED.");
        esp_config.cert_pem = nullptr;
        esp_config.skip_cert_common_name_check = true;
    }

    // Initialize the underlying ESP-IDF client
    esp_http_client_handle_t new_esp_handle = esp_http_client_init(&esp_config);
    if (!new_esp_handle) {
        ESP_LOGE(TAG, "Open: Failed to initialize underlying HTTP client.");
        tx_buffer_size_ = 0; // Reset stored size
        return Status::kFail;
    }

    // Store the handle directly into the void* member via cast
    client_handle_ = reinterpret_cast<void*>(new_esp_handle);

    current_request_ctx_.user_context = config.user_context;
    ESP_LOGI(TAG, "HTTPS client opened successfully.");
    return Status::kOk;
}

HttpsClient::Status HttpsClient::Close() {
    esp_err_t cleanup_err = ESP_OK;
    if (client_handle_ != nullptr) {
        esp_http_client_handle_t actual_esp_handle = reinterpret_cast<esp_http_client_handle_t>(client_handle_);
        if (actual_esp_handle != nullptr) {
            esp_http_client_set_user_data(actual_esp_handle, nullptr); // Detach context
            cleanup_err = esp_http_client_cleanup(actual_esp_handle);
             if (cleanup_err != ESP_OK) {
                 ESP_LOGE(TAG, "Close: esp_http_client_cleanup failed: %d (%s)", cleanup_err, esp_err_to_name(cleanup_err));
             }
        }
        client_handle_ = nullptr; // Reset the pointer AFTER cleanup attempt
    } else {
         ESP_LOGD(TAG, "Close: Client already closed or never opened.");
    }

    // Reset internal state
    tx_buffer_size_ = 0;
    current_request_ctx_.on_data_received = nullptr;
    current_request_ctx_.user_context = nullptr;
    current_request_ctx_.response_info_ptr = nullptr;

    if (cleanup_err == ESP_OK && client_handle_ == nullptr) { ESP_LOGI(TAG, "HTTPS client closed."); }
    return MapEspErrorToStatus(cleanup_err);
}


// --- Private Member Function Implementations ---

HttpsClient::Status HttpsClient::PerformRequestInternal(
                                        std::string_view url,
                                        HttpMethod method,
                                        const Headers& headers,
                                        std::string_view request_body,
                                        ResponseInfo* response_info) {
    // Check and cast void* handle
    if (!client_handle_) { ESP_LOGE(TAG,"PerformRequest: Client not open."); return Status::kNotInitialized; }
    esp_http_client_handle_t actual_esp_handle = reinterpret_cast<esp_http_client_handle_t>(client_handle_);
    if (!actual_esp_handle) { ESP_LOGE(TAG,"PerformRequest: Invalid internal handle state."); return Status::kNotInitialized; }

    esp_err_t err = ESP_OK;

    // Copy full URL to C-string buffer on stack
    std::array<char, kHttpsClientMaxUrlLength> url_buffer;
    int written_len = snprintf(url_buffer.data(), url_buffer.size(), "%.*s", (int)url.length(), url.data());
    if (written_len < 0 || (size_t)written_len >= url_buffer.size()) {
         ESP_LOGE(TAG, "PerformRequest: Provided URL exceeds maximum length (%zu).", url_buffer.size() - 1);
         return Status::kBufferTooSmall;
    }

    // Reset response info struct before request
    current_request_ctx_.response_info_ptr = response_info;
    if (response_info != nullptr) {
        response_info->status_code = 0;
        response_info->content_length = -1;
        response_info->connection_close = false;
    }

    // Set URL (using the copied buffer)
    err = esp_http_client_set_url(actual_esp_handle, url_buffer.data());
    if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_url failed: %d", err); return MapEspErrorToStatus(err); }

    // Set Method (using mapped value)
    err = esp_http_client_set_method(actual_esp_handle, MapHttpMethodToEspMethod(method));
    if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_method failed: %d", err); return MapEspErrorToStatus(err); }

    // Set Headers using temporary stack arrays
    std::array<char, kHttpsClientMaxHeaderKeyLen> header_key_buffer;
    std::array<char, kHttpsClientMaxHeaderValueLen> header_value_buffer;
    for (const auto& header : headers) {
        written_len = snprintf(header_key_buffer.data(), header_key_buffer.size(), "%.*s", (int)header.first.length(), header.first.data());
        if (written_len < 0 || (size_t)written_len >= header_key_buffer.size()) { ESP_LOGW(TAG, "Header key truncated: %.*s", (int)header.first.length(), header.first.data()); }
        written_len = snprintf(header_value_buffer.data(), header_value_buffer.size(), "%.*s", (int)header.second.length(), header.second.data());
        if (written_len < 0 || (size_t)written_len >= header_value_buffer.size()) { ESP_LOGW(TAG, "Header value truncated: %.*s", (int)header.second.length(), header.second.data()); }

        err = esp_http_client_set_header(actual_esp_handle, header_key_buffer.data(), header_value_buffer.data());
        if (err != ESP_OK) { ESP_LOGE(TAG, "Failed to set header '%s': %d", header_key_buffer.data(), err); return MapEspErrorToStatus(err); }
    }

    // Set Post Field / Content-Length: 0 logic
    if (!request_body.empty()) {
         err = esp_http_client_set_post_field(actual_esp_handle, request_body.data(), request_body.length());
         if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_post_field failed: %d", err); return MapEspErrorToStatus(err); }
         char* ct_header = nullptr;
         if (esp_http_client_get_header(actual_esp_handle, "Content-Type", &ct_header) != ESP_OK) {
              esp_http_client_set_header(actual_esp_handle, "Content-Type", "application/octet-stream");
         }
    } else if (method == HttpMethod::kPost || method == HttpMethod::kPut || method == HttpMethod::kPatch) {
        char* cl_header = nullptr; char* te_header = nullptr;
        bool cl_present = esp_http_client_get_header(actual_esp_handle, "Content-Length", &cl_header) == ESP_OK;
        bool te_present = esp_http_client_get_header(actual_esp_handle, "Transfer-Encoding", &te_header) == ESP_OK;
        if (!cl_present && !te_present) { esp_http_client_set_header(actual_esp_handle, "Content-Length", "0"); }
    }

    // Perform request
    err = esp_http_client_perform(actual_esp_handle);
    Status status = MapEspErrorToStatus(err);

    // Retrieve response info - check pointers before accessing
    if (response_info != nullptr && actual_esp_handle != nullptr) {
         response_info->status_code = esp_http_client_get_status_code(actual_esp_handle);
         response_info->content_length = esp_http_client_get_content_length(actual_esp_handle);
    }

    // Log final outcome
    if (status == Status::kOk && response_info != nullptr) {
        ESP_LOGI(TAG, "PerformRequest OK - Status: %d, Length: %lld", response_info->status_code, response_info->content_length);
    } else if (status != Status::kOk) {
        int temp_status_code = (response_info != nullptr) ? response_info->status_code : esp_http_client_get_status_code(actual_esp_handle);
        ESP_LOGE(TAG, "PerformRequest failed: %s. HTTP Status: %d", StatusToString(status), temp_status_code);
    }

    current_request_ctx_.response_info_ptr = nullptr; // Clear after use
    return status;
}


HttpsClient::Status HttpsClient::PerformStreamUploadInternal(
                                        std::string_view url,
                                        HttpMethod method,
                                        const Headers& headers,
                                        size_t total_body_length,
                                        DataProviderCallback data_provider,
                                        ResponseInfo* response_info) {

     if (!client_handle_) { ESP_LOGE(TAG,"StreamUpload: Client not open."); return Status::kNotInitialized; }
     esp_http_client_handle_t actual_esp_handle = reinterpret_cast<esp_http_client_handle_t>(client_handle_);
     if (!actual_esp_handle) { ESP_LOGE(TAG,"StreamUpload: Invalid internal handle."); return Status::kNotInitialized; }

     if (!data_provider) { ESP_LOGE(TAG,"StreamUpload: Data provider is null."); return Status::kInvalidArgument; }
     if (tx_buffer_size_ == 0) { ESP_LOGE(TAG, "StreamUpload: TX buffer size not configured."); return Status::kInvalidArgument; }

    esp_err_t err = ESP_OK;
    Status status = Status::kOk;

    // Copy full URL to C-string buffer
    std::array<char, kHttpsClientMaxUrlLength> url_buffer;
    int written_len = snprintf(url_buffer.data(), url_buffer.size(), "%.*s", (int)url.length(), url.data());
    if (written_len < 0 || (size_t)written_len >= url_buffer.size()) {
        ESP_LOGE(TAG, "StreamUpload: Provided URL exceeds maximum length (%zu).", url_buffer.size() - 1);
        return Status::kBufferTooSmall;
    }

    // Reset response info struct
    current_request_ctx_.response_info_ptr = response_info;
    if (response_info != nullptr) {
        response_info->status_code = 0;
        response_info->content_length = -1;
        response_info->connection_close = false;
    }

    // Set URL, Method, Headers, check Content-Length
    err = esp_http_client_set_url(actual_esp_handle, url_buffer.data());
    if (err != ESP_OK) return MapEspErrorToStatus(err);
    err = esp_http_client_set_method(actual_esp_handle, MapHttpMethodToEspMethod(method));
    if (err != ESP_OK) return MapEspErrorToStatus(err);

    bool content_length_found = false;
    std::array<char, kHttpsClientMaxHeaderKeyLen> header_key_buffer;
    std::array<char, kHttpsClientMaxHeaderValueLen> header_value_buffer;
    for (const auto& header : headers) {
        written_len = snprintf(header_key_buffer.data(), header_key_buffer.size(), "%.*s", (int)header.first.length(), header.first.data());
        if (written_len < 0 || (size_t)written_len >= header_key_buffer.size()) { ESP_LOGW(TAG, "Header key truncated"); }
        written_len = snprintf(header_value_buffer.data(), header_value_buffer.size(), "%.*s", (int)header.second.length(), header.second.data());
        if (written_len < 0 || (size_t)written_len >= header_value_buffer.size()) { ESP_LOGW(TAG, "Header value truncated"); }
        if (strcasecmp(header_key_buffer.data(), "Content-Length") == 0) { content_length_found = true; }
        err = esp_http_client_set_header(actual_esp_handle, header_key_buffer.data(), header_value_buffer.data());
        if (err != ESP_OK) { ESP_LOGE(TAG, "StreamUpload: Failed to set header %s: %d", header_key_buffer.data(), err); return MapEspErrorToStatus(err); }
    }
    if (!content_length_found) { ESP_LOGE(TAG, "StreamUpload: 'Content-Length' header required."); return Status::kInvalidArgument; }

    // Open connection
    err = esp_http_client_open(actual_esp_handle, total_body_length);
    if (err != ESP_OK) { ESP_LOGE(TAG, "StreamUpload: esp_http_client_open failed: %d", err); return MapEspErrorToStatus(err); }

    // --- Stream Request Body ---
    // Use std::vector allocated temporarily on heap. Size is member tx_buffer_size_.
    std::vector<char> chunk_buffer;
    // Assume resize works or aborts (no try-catch for std::bad_alloc)
    chunk_buffer.resize(tx_buffer_size_);
    // Optional: Basic check after resize (unlikely to catch abort but harmless)
    if (chunk_buffer.capacity() < tx_buffer_size_ && tx_buffer_size_ > 0) {
        ESP_LOGE(TAG, "StreamUpload: Chunk buffer vector allocation/resize failed (capacity check).");
        status = Status::kNoMemory;
        esp_http_client_close(actual_esp_handle); // Attempt cleanup before returning
        current_request_ctx_.response_info_ptr = nullptr;
        return status;
    }

    size_t bytes_written_total = 0;
    int chunk_len_provided = 0;
    int bytes_written_chunk = 0;

    // Stream write loop
    while (bytes_written_total < total_body_length) {
        chunk_len_provided = data_provider(chunk_buffer.data(), chunk_buffer.size(), current_request_ctx_.user_context);
        if (chunk_len_provided < 0) { ESP_LOGE(TAG,"Data provider error %d", chunk_len_provided); status = Status::kStreamError; break; }
        if (chunk_len_provided == 0 && bytes_written_total < total_body_length) { ESP_LOGE(TAG,"Data provider EOF before Content-Length reached"); status = Status::kStreamError; break; }
        if (chunk_len_provided == 0 && bytes_written_total == total_body_length) { break; } // Normal EOF at expected length

        size_t current_chunk_size = static_cast<size_t>(chunk_len_provided);
        if (current_chunk_size > chunk_buffer.size()) { ESP_LOGW(TAG, "Provider chunk %zu > buffer %zu", current_chunk_size, chunk_buffer.size()); current_chunk_size = chunk_buffer.size();}
        size_t remaining_total = total_body_length - bytes_written_total;
        if (current_chunk_size > remaining_total) { ESP_LOGW(TAG, "Provider chunk %zu > remaining %zu", current_chunk_size, remaining_total); current_chunk_size = remaining_total;}

        bytes_written_chunk = esp_http_client_write(actual_esp_handle, chunk_buffer.data(), current_chunk_size);
        if (bytes_written_chunk < 0) { status = MapEspErrorToStatus(static_cast<esp_err_t>(bytes_written_chunk)); break; }
        if (static_cast<size_t>(bytes_written_chunk) != current_chunk_size) { ESP_LOGW(TAG, "Partial write %d/%zu", bytes_written_chunk, current_chunk_size); status = Status::kConnectionError; break; }
        bytes_written_total += bytes_written_chunk;
    } // End while

    if (status == Status::kOk && bytes_written_total != total_body_length) {
        ESP_LOGE(TAG, "StreamUpload: Write loop finished but total bytes %zu != Content-Length %zu", bytes_written_total, total_body_length);
        status = Status::kStreamError;
    }

    // --- Fetch Response ---
    if (status == Status::kOk) {
        long long response_content_length = esp_http_client_fetch_headers(actual_esp_handle);
        if (response_content_length < 0) {
            ESP_LOGE(TAG, "StreamUpload: Failed fetch headers: %lld (%s)", response_content_length, esp_err_to_name(static_cast<esp_err_t>(response_content_length)));
            status = MapEspErrorToStatus(static_cast<esp_err_t>(response_content_length));
            // Attempt to get status code even if fetch fails
             if (response_info != nullptr && actual_esp_handle != nullptr) {
                response_info->status_code = esp_http_client_get_status_code(actual_esp_handle);
             }
        } else {
            // Fetch headers succeeded, get status and length
            if (response_info != nullptr) {
                response_info->status_code = esp_http_client_get_status_code(actual_esp_handle);
                response_info->content_length = response_content_length;
                 ESP_LOGI(TAG, "StreamUpload: Response Status = %d, Length = %lld", response_info->status_code, response_info->content_length);
            } else {
                 // Log even if user didn't provide response_info struct
                 ESP_LOGI(TAG, "StreamUpload: Response Status = %d, Length = %lld", esp_http_client_get_status_code(actual_esp_handle), response_content_length);
            }
        }
    }

    // Close connection (always attempt)
    err = esp_http_client_close(actual_esp_handle);
    if (err != ESP_OK && status == Status::kOk) {
        ESP_LOGE(TAG, "StreamUpload: Failed to close connection: %d (%s)", err, esp_err_to_name(err));
        status = MapEspErrorToStatus(err); // Update status only if operation was OK but close failed
    }

    // chunk_buffer automatically destroyed/memory freed here by RAII
    current_request_ctx_.response_info_ptr = nullptr; // Clear context pointer
    return status;
}


// --- Public Method Implementations ---
// Call the private member functions

HttpsClient::Status HttpsClient::Get(std::string_view url, const Headers& headers,
                                     DataReceivedCallback on_data_received,
                                     ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(url, HttpMethod::kGet, headers, "", response_info);
}
HttpsClient::Status HttpsClient::Post(std::string_view url, const Headers& headers,
                                      std::string_view post_data,
                                      DataReceivedCallback on_data_received,
                                      ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(url, HttpMethod::kPost, headers, post_data, response_info);
}
HttpsClient::Status HttpsClient::Put(std::string_view url, const Headers& headers,
                                     std::string_view put_data,
                                     DataReceivedCallback on_data_received,
                                     ResponseInfo* response_info) {
     current_request_ctx_.on_data_received = on_data_received;
     return PerformRequestInternal(url, HttpMethod::kPut, headers, put_data, response_info);
}
HttpsClient::Status HttpsClient::Patch(std::string_view url, const Headers& headers,
                                       std::string_view patch_data,
                                       DataReceivedCallback on_data_received,
                                       ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(url, HttpMethod::kPatch, headers, patch_data, response_info);
}
HttpsClient::Status HttpsClient::PostStream(std::string_view url, const Headers& headers,
                                            size_t total_body_length,
                                            DataProviderCallback data_provider,
                                            DataReceivedCallback on_data_received,
                                            ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformStreamUploadInternal(url, HttpMethod::kPost, headers, total_body_length, data_provider, response_info);
}
HttpsClient::Status HttpsClient::PutStream(std::string_view url, const Headers& headers,
                                           size_t total_body_length,
                                           DataProviderCallback data_provider,
                                           DataReceivedCallback on_data_received,
                                           ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformStreamUploadInternal(url, HttpMethod::kPut, headers, total_body_length, data_provider, response_info);
}


// StatusToString (Fully Implemented)
const char* HttpsClient::StatusToString(Status status) {
    switch (status) {
        case Status::kOk: return "Ok";
        case Status::kFail: return "Fail";
        case Status::kInvalidArgument: return "InvalidArgument";
        case Status::kNotInitialized: return "NotInitialized";
        case Status::kAlreadyInitialized: return "AlreadyInitialized";
        case Status::kNoMemory: return "NoMemory";
        case Status::kTimeout: return "Timeout";
        case Status::kNetworkError: return "NetworkError";
        case Status::kConnectionError: return "ConnectionError";
        case Status::kTlsError: return "TlsError";
        case Status::kHttpError: return "HttpError";
        case Status::kResponseError: return "ResponseError";
        case Status::kStreamError: return "StreamError";
        case Status::kBufferTooSmall: return "BufferTooSmall";
        case Status::kUnsupported: return "Unsupported";
        default: return "UnknownStatus";
    }
}

------------------------------------------
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"

#include "https_client.h" // Include the final client class
#include <vector>
#include <string>
#include <cstring>
#include <cstdlib> // For std::to_string

static const char* kMainAppTag = "HTTP_EXAMPLE";

// Callbacks and Provider (signatures unchanged)
HttpsClient::Status OnDataReceivedPrint(const char* data, size_t len, void* user_context) {
    ESP_LOGI(kMainAppTag, "Received chunk (%zu bytes):", len);
    fwrite(data, 1, len, stdout); printf("\n");
    return HttpsClient::Status::kOk;
}
HttpsClient::Status OnDataReceivedCollect(const char* data, size_t len, void* user_context) {
    std::string* response_buffer = static_cast<std::string*>(user_context);
    try { response_buffer->append(data, len); } catch (const std::bad_alloc&) { return HttpsClient::Status::kNoMemory; }
    ESP_LOGD(kMainAppTag, "Collected %zu bytes, total %zu", len, response_buffer->length());
    return HttpsClient::Status::kOk;
}
struct StreamUploadContext { const uint8_t* data_ptr = nullptr; size_t total_size = 0; size_t sent_size = 0; };
int ProvideDataChunk(char* buffer, size_t max_len, void* user_context) {
    StreamUploadContext* upload_ctx = static_cast<StreamUploadContext*>(user_context);
    if (!upload_ctx || upload_ctx->sent_size >= upload_ctx->total_size) return 0;
    size_t remaining = upload_ctx->total_size - upload_ctx->sent_size;
    size_t chunk = (remaining > max_len) ? max_len : remaining;
    memcpy(buffer, upload_ctx->data_ptr + upload_ctx->sent_size, chunk);
    upload_ctx->sent_size += chunk;
    ESP_LOGD(kMainAppTag, "Provided chunk %zu bytes, total sent %zu / %zu", chunk, upload_ctx->sent_size, upload_ctx->total_size);
    return static_cast<int>(chunk);
}

extern "C" void app_main(void) {
    ESP_ERROR_CHECK(nvs_flash_init());
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    ESP_LOGI(kMainAppTag, "WiFi Connected (Assuming...)");
    vTaskDelay(pdMS_TO_TICKS(2000));

    HttpsClient https_client;
    HttpsClient::Config client_config = {};

    // Set Config - ** MUST SET BUFFER SIZES **
    client_config.buffer_size_rx_bytes = 2048;
    client_config.buffer_size_tx_bytes = 1024;
    client_config.verify_server = false; // Production: true + provide cert
    client_config.timeout_ms = 20000;

    // Example 1: GET
    ESP_LOGI(kMainAppTag, "*** Example 1: GET ***");
    HttpsClient::Status op_status = https_client.Open(client_config);
    if (op_status != HttpsClient::Status::kOk) { ESP_LOGE(kMainAppTag, "Open failed: %s", HttpsClient::StatusToString(op_status)); return; }

    std::string get_response_body;
    HttpsClient::ResponseInfo get_resp_info;
    HttpsClient::Headers get_headers = {{"User-Agent", "ESP-IDF HttpsClient Final V6"}};
    const char* get_url = "https://httpbin.org/get?client=final_v6";
    op_status = https_client.Get(get_url, get_headers,
                         [&](const char* d, size_t l, void* c){ return OnDataReceivedCollect(d, l, &get_response_body); },
                         &get_resp_info);
    if (op_status == HttpsClient::Status::kOk) { ESP_LOGI(kMainAppTag, "GET OK, Status: %d", get_resp_info.status_code); }
    else { ESP_LOGE(kMainAppTag, "GET failed: %s, Status: %d", HttpsClient::StatusToString(op_status), get_resp_info.status_code); }
    get_response_body.clear();

    // Example 2: PUT Stream
    ESP_LOGI(kMainAppTag, "\n*** Example 2: PUT Stream ***");
    const char* dummy_file_content = "Final content V6";
    StreamUploadContext upload_context = {}; /* Init context */
    upload_context.data_ptr = reinterpret_cast<const uint8_t*>(dummy_file_content);
    upload_context.total_size = strlen(dummy_file_content);
    HttpsClient::Headers put_headers = { {"Content-Type", "text/plain"}, {"Content-Length", std::to_string(upload_context.total_size)} };
    std::string put_response_body;
    HttpsClient::ResponseInfo put_resp_info;
    HttpsClient::DataProviderCallback data_provider_lambda = [&](char* b, size_t l, void* c){ return ProvideDataChunk(b, l, &upload_context); };
    HttpsClient::DataReceivedCallback response_handler_lambda = [&](const char* d, size_t l, void* c){ return OnDataReceivedCollect(d, l, &put_response_body); };
    const char* put_url = "https://httpbin.org/put";

    op_status = https_client.PutStream(put_url, put_headers, upload_context.total_size, data_provider_lambda, response_handler_lambda, &put_resp_info);
    if (op_status == HttpsClient::Status::kOk) { ESP_LOGI(kMainAppTag, "PUT OK, Status: %d", put_resp_info.status_code); }
    else { ESP_LOGE(kMainAppTag, "PUT failed: %s, Status: %d", HttpsClient::StatusToString(op_status), put_resp_info.status_code); }
    put_response_body.clear();

    // Clean up
    ESP_LOGI(kMainAppTag, "Closing client.");
    op_status = https_client.Close();
    if (op_status != HttpsClient::Status::kOk) { ESP_LOGE(kMainAppTag, "Close failed: %s", HttpsClient::StatusToString(op_status)); }

    ESP_LOGI(kMainAppTag, "Example finished.");
}
