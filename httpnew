#ifndef HTTPS_CLIENT_H
#define HTTPS_CLIENT_H

#include <functional>
#include <string_view>
#include <map>
#include <array>     // For fixed-size arrays
#include <cstddef>
#include <cstdint>

// Define hard limits directly in the code for URL and Headers
constexpr size_t kHttpsClientMaxUrlLength = 512;   // Max length for Base URL + Path
constexpr size_t kHttpsClientMaxHeaderKeyLen = 64;    // Max length for an HTTP header key
constexpr size_t kHttpsClientMaxHeaderValueLen = 256; // Max length for an HTTP header value

/**
 * @class HttpsClient
 * @brief Provides a C++ wrapper for HTTPS communication using ESP-IDF.
 *
 * Handles GET, POST, PUT, PATCH requests with optional server verification.
 * Supports persistent connections and streaming via callbacks.
 * Uses fixed buffers for URL/Headers and a temporary std::vector for stream chunks.
 * Follows Google C++ Style naming conventions.
 * NOTE: Network operations are BLOCKING. Run in a dedicated task for non-blocking app behavior.
 * NOTE: Uses std::vector for stream upload buffer; allocation failure without exceptions
 * will likely cause program termination (abort).
 */
class HttpsClient {
 public:
  /**
   * @brief Status codes returned by HttpsClient methods and callbacks.
   */
  enum class Status {
    kOk = 0,             ///< Operation successful.
    kFail,               ///< Generic failure.
    kInvalidArgument,    ///< Invalid argument provided.
    kNotInitialized,     ///< Client handle is not initialized (Open not called or failed).
    kAlreadyInitialized, ///< Open() called when already open.
    kNoMemory,           ///< Memory allocation failed (e.g., from underlying libs or malloc).
    kTimeout,            ///< Operation timed out.
    kNetworkError,       ///< Lower-level network error (DNS, TCP, etc.).
    kConnectionError,    ///< Failed to establish connection or connection lost.
    kTlsError,           ///< TLS handshake or encryption/decryption error.
    kHttpError,          ///< HTTP protocol error (parsing, redirects, etc.).
    kResponseError,      ///< Error indicated by HTTP status code (e.g., 4xx, 5xx).
    kStreamError,        ///< Error during request or response streaming (e.g., callback error).
    kBufferTooSmall,     ///< Provided buffer/limit was too small (e.g., URL, Header).
    kUnsupported         ///< Feature or operation not supported.
  };

  /**
   * @brief Callback function type for receiving response body data in chunks.
   * @return HttpsClient::Status Should return HttpsClient::Status::kOk on success, or an error code to abort.
   */
  using DataReceivedCallback =
      std::function<Status(const char* data, size_t len, void* user_context)>;

  /**
   * @brief Callback function type for providing request body data in chunks for streaming uploads.
   * @return int Bytes written (positive), 0 (EOF), or negative (error).
   */
  using DataProviderCallback =
      std::function<int(char* buffer, size_t max_len, void* user_context)>;


  /**
   * @brief Configuration structure - Requires buffer sizes to be set explicitly.
   */
  struct Config {
    std::string_view base_url;
    // Buffer sizes MUST be provided by the caller for underlying esp_http_client
    size_t buffer_size_rx_bytes;
    size_t buffer_size_tx_bytes;
    // Other config options
    bool verify_server = true;
    const char* server_cert_pem = nullptr;
    int timeout_ms = 10000;
    int keep_alive_idle_sec = 5;
    int keep_alive_interval_sec = 5;
    int keep_alive_count = 3;
    void* user_context = nullptr;
  };

  /**
   * @brief Structure to hold response information.
   */
  struct ResponseInfo {
      int status_code = 0;
      long long content_length = -1;
      bool connection_close = false;
      // std::string content_type; // Optional
  };

  using Headers = std::map<std::string_view, std::string_view>;

  HttpsClient();
  ~HttpsClient();

  // Disable copy/move semantics
  HttpsClient(const HttpsClient&) = delete;
  HttpsClient& operator=(const HttpsClient&) = delete;
  HttpsClient(HttpsClient&&) = delete;
  HttpsClient& operator=(HttpsClient&&) = delete;

  // --- Public API ---

  Status Open(const Config& config);
  Status Close();
  Status Get(std::string_view path, const Headers& headers,
             DataReceivedCallback on_data_received,
             ResponseInfo* response_info = nullptr);
  Status Post(std::string_view path, const Headers& headers,
              std::string_view post_data,
              DataReceivedCallback on_data_received,
              ResponseInfo* response_info = nullptr);
  Status PostStream(std::string_view path, const Headers& headers,
                    size_t total_body_length,
                    DataProviderCallback data_provider,
                    DataReceivedCallback on_data_received,
                    ResponseInfo* response_info = nullptr);
  Status Put(std::string_view path, const Headers& headers,
             std::string_view put_data,
             DataReceivedCallback on_data_received,
             ResponseInfo* response_info = nullptr);
  Status PutStream(std::string_view path, const Headers& headers,
                   size_t total_body_length,
                   DataProviderCallback data_provider,
                   DataReceivedCallback on_data_received,
                   ResponseInfo* response_info = nullptr);
  Status Patch(std::string_view path, const Headers& headers,
               std::string_view patch_data,
               DataReceivedCallback on_data_received,
               ResponseInfo* response_info = nullptr);

  static const char* StatusToString(Status status);


 private:
   // PIMPL struct forward declaration
   struct HttpsClientImpl;
   // Direct member implementation
   HttpsClientImpl impl_;

   // RequestContext struct
   struct RequestContext {
        DataReceivedCallback on_data_received;
        void* user_context = nullptr;
        ResponseInfo* response_info_ptr = nullptr;
   };
   RequestContext current_request_ctx_;

   // Fixed array for base URL storage
   std::array<char, kHttpsClientMaxUrlLength> base_url_storage_ = {};
   size_t base_url_len_ = 0;

   // Store configured TX buffer size (needed for stream chunk buffer size)
   size_t tx_buffer_size_ = 0;
};

#endif // HTTPS_CLIENT_H
-----------------------------------------------------------
#include "https_client.h"

#include <cstring> // For memcpy, strlen, strcasecmp
#include <cstdio>  // For snprintf
#include <array>   // For stack arrays for headers/URL
#include <vector>  // For temporary chunk buffer (heap allocated)

// ESP-IDF specific headers
#include "esp_http_client.h"
#include "esp_log.h"
#include "esp_check.h"
#include "esp_err.h"
#include "errno.h"

static const char* TAG = "HttpsClient";

// --- MapEspErrorToStatus helper ---
static HttpsClient::Status MapEspErrorToStatus(esp_err_t err) {
    switch (err) {
        case ESP_OK:                        return HttpsClient::Status::kOk;
        case ESP_ERR_INVALID_ARG:           return HttpsClient::Status::kInvalidArgument;
        case ESP_ERR_HTTP_INVALID_METHOD:   return HttpsClient::Status::kInvalidArgument;
        case ESP_ERR_HTTP_INVALID_HEADER:   return HttpsClient::Status::kInvalidArgument;
        case ESP_ERR_NO_MEM:                return HttpsClient::Status::kNoMemory; // From ESP-IDF layers
        case ESP_ERR_TIMEOUT:               return HttpsClient::Status::kTimeout;
        case ESP_ERR_HTTP_CONNECT:          return HttpsClient::Status::kConnectionError;
        case ESP_ERR_HTTP_CONNECTING:       return HttpsClient::Status::kConnectionError;
        case ESP_ERR_HTTP_SOCKET_ERR:       return HttpsClient::Status::kNetworkError; // Or ConnectionError?
        case ESP_ERR_ESP_TLS_FAILED_CONNECT:return HttpsClient::Status::kConnectionError;
        case ESP_FAIL:                      return HttpsClient::Status::kFail; // Generic ESP-IDF failure
        case ESP_ERR_ESP_TLS_HANDSHAKE:     return HttpsClient::Status::kTlsError;
        case ESP_ERR_ESP_TLS_PK_PARSE:      return HttpsClient::Status::kTlsError;
        case ESP_ERR_ESP_TLS_CA_CERT:       return HttpsClient::Status::kTlsError;
        case ESP_ERR_HTTP_PARSE:            return HttpsClient::Status::kHttpError;
        case ESP_ERR_HTTP_HEADERS:          return HttpsClient::Status::kHttpError;
        case ESP_ERR_HTTP_REDIRECT:         return HttpsClient::Status::kHttpError;
        default:
            ESP_LOGW(TAG, "Unmapped esp_err_t: %d (%s)", err, esp_err_to_name(err));
            if (err > ESP_ERR_HTTP_BASE && err <= ESP_ERR_HTTP_MAX) return HttpsClient::Status::kHttpError;
            if (err > ESP_ERR_ESP_TLS_BASE && err <= ESP_ERR_ESP_TLS_MAX) return HttpsClient::Status::kTlsError;
            return HttpsClient::Status::kFail;
    }
}


// --- PIMPL Structure Definition ---
struct HttpsClient::HttpsClientImpl {
    esp_http_client_handle_t handle = nullptr;
};


// --- Static Event Handler (ESP-IDF specific) ---
static esp_err_t PlatformEventHandler(esp_http_client_event_t *evt) {
    HttpsClient::RequestContext* req_ctx = static_cast<HttpsClient::RequestContext*>(evt->user_data);
    if (!req_ctx) { return ESP_FAIL; }

    switch (evt->event_id) {
        case HTTP_EVENT_ON_HEADER:
             if (req_ctx->response_info_ptr) {
                 if (strcasecmp(evt->header_key, "Connection") == 0 && strcasecmp(evt->header_value, "close") == 0) {
                     req_ctx->response_info_ptr->connection_close = true;
                 }
             }
            break;
        case HTTP_EVENT_ON_DATA:
            if (req_ctx->on_data_received && evt->data_len > 0) {
                HttpsClient::Status user_cb_status = req_ctx->on_data_received(
                    static_cast<const char*>(evt->data),
                    static_cast<size_t>(evt->data_len),
                    req_ctx->user_context);
                if (user_cb_status != HttpsClient::Status::kOk) {
                    ESP_LOGE(TAG, "User data callback returned error: %d", static_cast<int>(user_cb_status));
                    return ESP_FAIL; // Signal underlying client to stop
                }
            }
            break;
        case HTTP_EVENT_REDIRECT:
            ESP_LOGD(TAG, "HTTP_EVENT_REDIRECT");
            esp_http_client_set_redirection(evt->client);
            break;
        // Other cases (ERROR, CONNECTED, FINISH, DISCONNECTED etc.) can be added for logging if needed
        default:
            break;
    }
    return ESP_OK;
}


// --- HttpsClient Member Functions ---

HttpsClient::HttpsClient() : impl_{nullptr}, base_url_storage_{}, base_url_len_(0), tx_buffer_size_(0) {
     current_request_ctx_.on_data_received = nullptr;
     current_request_ctx_.user_context = nullptr;
     current_request_ctx_.response_info_ptr = nullptr;
}

HttpsClient::~HttpsClient() {
    Close();
}

HttpsClient::Status HttpsClient::Open(const Config& config) {
    if (impl_.handle) {
        ESP_LOGW(TAG, "Client already open.");
        return Status::kAlreadyInitialized;
    }
    // Validate required config values
    if (config.base_url.empty() || config.buffer_size_rx_bytes == 0 || config.buffer_size_tx_bytes == 0) {
         ESP_LOGE(TAG, "Invalid config: Base URL and buffer sizes must be non-zero.");
        return Status::kInvalidArgument;
    }
     if (config.verify_server && !config.server_cert_pem) {
         ESP_LOGE(TAG, "Server verification enabled, but server_cert_pem is NULL.");
         return Status::kInvalidArgument;
     }

    // Copy base URL to fixed array storage
    if (config.base_url.length() >= base_url_storage_.size()) {
        ESP_LOGE(TAG, "Base URL length (%zu) exceeds maximum (%zu)", config.base_url.length(), base_url_storage_.size() - 1);
        return Status::kBufferTooSmall;
    }
    memcpy(base_url_storage_.data(), config.base_url.data(), config.base_url.length());
    base_url_storage_[config.base_url.length()] = '\0';
    base_url_len_ = config.base_url.length();

    // Store configured TX buffer size
    tx_buffer_size_ = config.buffer_size_tx_bytes;

    // Configure ESP-IDF client
    esp_http_client_config_t esp_config = {};
    esp_config.url = base_url_storage_.data();
    esp_config.buffer_size = config.buffer_size_rx_bytes; // From Config struct
    esp_config.buffer_size_tx = config.buffer_size_tx_bytes; // From Config struct
    esp_config.timeout_ms = config.timeout_ms;
    esp_config.keep_alive_enable = true;
    esp_config.keep_alive_idle = config.keep_alive_idle_sec;
    esp_config.keep_alive_interval = config.keep_alive_interval_sec;
    esp_config.keep_alive_count = config.keep_alive_count;
    esp_config.user_data = &current_request_ctx_;
    esp_config.event_handler = PlatformEventHandler;

    if (config.verify_server) {
        esp_config.cert_pem = config.server_cert_pem;
        esp_config.skip_cert_common_name_check = false;
    } else {
        ESP_LOGW(TAG, "Server certificate verification is DISABLED.");
        esp_config.cert_pem = nullptr;
        esp_config.skip_cert_common_name_check = true;
    }

    // Initialize directly into impl_.handle
    impl_.handle = esp_http_client_init(&esp_config);
    if (!impl_.handle) {
        ESP_LOGE(TAG, "Failed to initialize underlying HTTP client");
        base_url_storage_[0] = '\0';
        base_url_len_ = 0;
        tx_buffer_size_ = 0;
        return Status::kFail;
    }

    current_request_ctx_.user_context = config.user_context;
    ESP_LOGI(TAG, "HTTPS client opened for base URL: %s", base_url_storage_.data());
    return Status::kOk;
}

HttpsClient::Status HttpsClient::Close() {
    esp_err_t err = ESP_OK;
    if (impl_.handle) {
        err = esp_http_client_cleanup(impl_.handle);
        impl_.handle = nullptr;
         if (err != ESP_OK) {
             ESP_LOGE(TAG, "Cleanup failed: %d (%s)", err, esp_err_to_name(err));
         }
    }
    base_url_storage_[0] = '\0';
    base_url_len_ = 0;
    tx_buffer_size_ = 0;

    if (err == ESP_OK) { ESP_LOGI(TAG, "HTTPS client closed."); }
    return MapEspErrorToStatus(err);
}


// --- Internal Helper: Perform non-streaming request ---
static HttpsClient::Status PerformRequestInternal(
                                        HttpsClient::HttpsClientImpl& client_impl,
                                        HttpsClient::RequestContext* req_ctx,
                                        const char* base_url_data,
                                        size_t base_url_len,
                                        std::string_view path,
                                        esp_http_client_method_t method,
                                        const HttpsClient::Headers& headers,
                                        std::string_view request_body,
                                        HttpsClient::ResponseInfo* response_info) {

    if (!client_impl.handle) { return HttpsClient::Status::kNotInitialized; }
    esp_http_client_handle_t client_handle = client_impl.handle;
    esp_err_t err = ESP_OK;

    // Construct full URL using stack array and snprintf
    std::array<char, kHttpsClientMaxUrlLength> full_url_buffer;
    int written_len = snprintf(full_url_buffer.data(), full_url_buffer.size(),
                               "%.*s%.*s", (int)base_url_len, base_url_data, (int)path.length(), path.data());
    if (written_len < 0 || (size_t)written_len >= full_url_buffer.size()) {
         ESP_LOGE(TAG, "URL construction failed/truncated (%d/%zu).", written_len, full_url_buffer.size());
         return HttpsClient::Status::kBufferTooSmall;
    }

    req_ctx->response_info_ptr = response_info;
    if (response_info) {
        response_info->status_code = 0;
        response_info->content_length = -1;
        response_info->connection_close = false;
    }

    // Set URL
    err = esp_http_client_set_url(client_handle, full_url_buffer.data());
    if (err != ESP_OK) return MapEspErrorToStatus(err);

    // Set Method
    err = esp_http_client_set_method(client_handle, method);
    if (err != ESP_OK) return MapEspErrorToStatus(err);

    // Set Headers using temporary stack arrays
    std::array<char, kHttpsClientMaxHeaderKeyLen> header_key_buffer;
    std::array<char, kHttpsClientMaxHeaderValueLen> header_value_buffer;

    for (const auto& header : headers) {
        written_len = snprintf(header_key_buffer.data(), header_key_buffer.size(), "%.*s", (int)header.first.length(), header.first.data());
        if (written_len < 0 || (size_t)written_len >= header_key_buffer.size()) { ESP_LOGW(TAG, "Header key truncated: %.*s", (int)header.first.length(), header.first.data()); }
        written_len = snprintf(header_value_buffer.data(), header_value_buffer.size(), "%.*s", (int)header.second.length(), header.second.data());
        if (written_len < 0 || (size_t)written_len >= header_value_buffer.size()) { ESP_LOGW(TAG, "Header value truncated: %.*s", (int)header.second.length(), header.second.data()); }

        err = esp_http_client_set_header(client_handle, header_key_buffer.data(), header_value_buffer.data());
        if (err != ESP_OK) { ESP_LOGE(TAG, "Failed to set header %s", header_key_buffer.data()); return MapEspErrorToStatus(err); }
    }

    // Set Post Field / Content-Length: 0 logic
    if (!request_body.empty()) {
         err = esp_http_client_set_post_field(client_handle, request_body.data(), request_body.length());
         if (err != ESP_OK) return MapEspErrorToStatus(err);
         char* ct_header = nullptr;
         if (esp_http_client_get_header(client_handle, "Content-Type", &ct_header) != ESP_OK) {
              esp_http_client_set_header(client_handle, "Content-Type", "application/octet-stream");
         }
    } else if (method == HTTP_METHOD_POST || method == HTTP_METHOD_PUT || method == HTTP_METHOD_PATCH) {
        char* cl_header = nullptr; char* te_header = nullptr;
        bool cl_present = esp_http_client_get_header(client_handle, "Content-Length", &cl_header) == ESP_OK;
        bool te_present = esp_http_client_get_header(client_handle, "Transfer-Encoding", &te_header) == ESP_OK;
        if (!cl_present && !te_present) { esp_http_client_set_header(client_handle, "Content-Length", "0"); }
    }

    // Perform request
    err = esp_http_client_perform(client_handle);
    HttpsClient::Status status = MapEspErrorToStatus(err);

    // Retrieve response info
    if (client_handle) {
         int http_status_code = esp_http_client_get_status_code(client_handle);
         long long http_content_length = esp_http_client_get_content_length(client_handle);
         if (response_info) {
             response_info->status_code = http_status_code;
             response_info->content_length = http_content_length;
         }
         if (err == ESP_OK) { ESP_LOGI(TAG, "HTTPS Status = %d, content_length = %lld", http_status_code, http_content_length); }
         else { ESP_LOGE(TAG, "HTTP perform failed: %d (%s). Status Code: %d", err, esp_err_to_name(err), http_status_code); }
    } else { status = HttpsClient::Status::kFail; }

    return status;
}


// --- Internal Helper: Perform streaming upload request ---
static HttpsClient::Status PerformStreamUploadInternal(
                                        HttpsClient::HttpsClientImpl& client_impl,
                                        HttpsClient::RequestContext* req_ctx,
                                        const char* base_url_data,
                                        size_t base_url_len,
                                        size_t tx_buffer_size, // From config
                                        std::string_view path,
                                        esp_http_client_method_t method,
                                        const HttpsClient::Headers& headers,
                                        size_t total_body_length,
                                        HttpsClient::DataProviderCallback data_provider,
                                        HttpsClient::ResponseInfo* response_info) {

     if (!client_impl.handle) { return HttpsClient::Status::kNotInitialized; }
     if (!data_provider) { return HttpsClient::Status::kInvalidArgument; }
     if (tx_buffer_size == 0) { ESP_LOGE(TAG, "Stream: TX buffer size configured as 0."); return HttpsClient::Status::kInvalidArgument; }

    esp_http_client_handle_t client_handle = client_impl.handle;
    esp_err_t err = ESP_OK;
    HttpsClient::Status status = HttpsClient::Status::kOk;

    // Construct full URL using stack array and snprintf
    std::array<char, kHttpsClientMaxUrlLength> full_url_buffer;
    int written_len = snprintf(full_url_buffer.data(), full_url_buffer.size(), "%.*s%.*s", (int)base_url_len, base_url_data, (int)path.length(), path.data());
    if (written_len < 0 || (size_t)written_len >= full_url_buffer.size()) { ESP_LOGE(TAG, "Stream URL construct failed/truncated."); return HttpsClient::Status::kBufferTooSmall; }

    req_ctx->response_info_ptr = response_info;
    if (response_info) { /* Reset */ }

    // --- Manual Request Construction ---
    err = esp_http_client_set_url(client_handle, full_url_buffer.data());
    if (err != ESP_OK) return MapEspErrorToStatus(err);
    err = esp_http_client_set_method(client_handle, method);
    if (err != ESP_OK) return MapEspErrorToStatus(err);

    // Set Headers using temporary stack arrays
    std::array<char, kHttpsClientMaxHeaderKeyLen> header_key_buffer;
    std::array<char, kHttpsClientMaxHeaderValueLen> header_value_buffer;
    bool content_length_found = false;
    for (const auto& header : headers) {
        written_len = snprintf(header_key_buffer.data(), header_key_buffer.size(), "%.*s", (int)header.first.length(), header.first.data());
        if (written_len < 0 || (size_t)written_len >= header_key_buffer.size()) { /* Log truncation */ }
        written_len = snprintf(header_value_buffer.data(), header_value_buffer.size(), "%.*s", (int)header.second.length(), header.second.data());
        if (written_len < 0 || (size_t)written_len >= header_value_buffer.size()) { /* Log truncation */ }
        if (strcasecmp(header_key_buffer.data(), "Content-Length") == 0) content_length_found = true;
        err = esp_http_client_set_header(client_handle, header_key_buffer.data(), header_value_buffer.data());
        if (err != ESP_OK) return MapEspErrorToStatus(err);
    }
     if (!content_length_found) { ESP_LOGE(TAG, "Stream: Content-Length required."); return HttpsClient::Status::kInvalidArgument; }

    // Open connection
    err = esp_http_client_open(client_handle, total_body_length);
    if (err != ESP_OK) return MapEspErrorToStatus(err);

    // --- Stream Request Body ---
    // Use std::vector allocated temporarily on heap. Size is tx_buffer_size.
    // NOTE: resize() failure likely causes abort() if exceptions disabled.
    std::vector<char> chunk_buffer;
    try {
         chunk_buffer.resize(tx_buffer_size);
    } catch (const std::bad_alloc& e) {
         // Should not happen if exceptions disabled, resize likely calls abort() directly.
         ESP_LOGE(TAG, "Stream: Heap alloc failed for chunk buffer via vector::resize (std::bad_alloc).");
         status = HttpsClient::Status::kNoMemory;
         esp_http_client_close(client_handle); // Attempt cleanup before returning
         return status;
    }
    // Check if resize caused abort (only possible if exceptions somehow enabled or platform specific)
    // This check is speculative, resize likely aborts before returning on failure without exceptions.
    // if (chunk_buffer.capacity() < tx_buffer_size) { // Indirect check? Unreliable.
    //     ESP_LOGE(TAG, "Stream: Chunk buffer vector alloc failed (capacity check).");
    //     status = HttpsClient::Status::kNoMemory;
    //     esp_http_client_close(client_handle);
    //     return status;
    // }


    size_t bytes_written_total = 0;
    int chunk_len_provided = 0;
    int bytes_written_chunk = 0;

    // Stream write loop
    while (bytes_written_total < total_body_length) {
        chunk_len_provided = data_provider(chunk_buffer.data(), chunk_buffer.size(), req_ctx->user_context);
        if (chunk_len_provided < 0) { status = HttpsClient::Status::kStreamError; break; }
        if (chunk_len_provided == 0) { status = HttpsClient::Status::kStreamError; break; }

        size_t current_chunk_size = static_cast<size_t>(chunk_len_provided);
        if (current_chunk_size > chunk_buffer.size()) { ESP_LOGW(TAG, "Provider chunk %zu > buffer %zu", current_chunk_size, chunk_buffer.size()); current_chunk_size = chunk_buffer.size();}
        size_t remaining_total = total_body_length - bytes_written_total;
        if (current_chunk_size > remaining_total) { ESP_LOGW(TAG, "Provider chunk %zu > remaining %zu", current_chunk_size, remaining_total); current_chunk_size = remaining_total;}

        bytes_written_chunk = esp_http_client_write(client_handle, chunk_buffer.data(), current_chunk_size);
        if (bytes_written_chunk < 0) { status = MapEspErrorToStatus(static_cast<esp_err_t>(bytes_written_chunk)); break; }
        if (static_cast<size_t>(bytes_written_chunk) != current_chunk_size) { status = HttpsClient::Status::kConnectionError; break; }
        bytes_written_total += bytes_written_chunk;
    } // End while

    if (status == HttpsClient::Status::kOk && bytes_written_total != total_body_length) { status = HttpsClient::Status::kStreamError; }

    // --- Fetch Response ---
    if (status == HttpsClient::Status::kOk) {
        long long response_content_length = esp_http_client_fetch_headers(client_handle);
        if (response_content_length < 0) {
            status = MapEspErrorToStatus(static_cast<esp_err_t>(response_content_length));
        } else {
            int http_status_code = esp_http_client_get_status_code(client_handle);
            ESP_LOGI(TAG, "Stream: Response Status = %d, content_length = %lld", http_status_code, response_content_length);
            if (response_info) {
                response_info->status_code = http_status_code;
                response_info->content_length = response_content_length;
            }
        }
    }

    // Close connection
    err = esp_http_client_close(client_handle);
    if (err != ESP_OK && status == HttpsClient::Status::kOk) { status = MapEspErrorToStatus(err); }

    // chunk_buffer is automatically destroyed/memory freed here by RAII
    return status;
}


// --- Public Method Implementations ---
// Call internal helpers, passing necessary members by const ref or value

HttpsClient::Status HttpsClient::Get(std::string_view path, const Headers& headers,
                                     DataReceivedCallback on_data_received,
                                     ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    // Pass base URL info from members
    return PerformRequestInternal(impl_, &current_request_ctx_,
                                  base_url_storage_.data(), base_url_len_,
                                  path, HTTP_METHOD_GET, headers, "", response_info);
}

HttpsClient::Status HttpsClient::Post(std::string_view path, const Headers& headers,
                                      std::string_view post_data,
                                      DataReceivedCallback on_data_received,
                                      ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
     return PerformRequestInternal(impl_, &current_request_ctx_,
                                   base_url_storage_.data(), base_url_len_,
                                   path, HTTP_METHOD_POST, headers, post_data, response_info);
}

HttpsClient::Status HttpsClient::Put(std::string_view path, const Headers& headers,
                                     std::string_view put_data,
                                     DataReceivedCallback on_data_received,
                                     ResponseInfo* response_info) {
     current_request_ctx_.on_data_received = on_data_received;
     return PerformRequestInternal(impl_, &current_request_ctx_,
                                   base_url_storage_.data(), base_url_len_,
                                   path, HTTP_METHOD_PUT, headers, put_data, response_info);
}

HttpsClient::Status HttpsClient::Patch(std::string_view path, const Headers& headers,
                                       std::string_view patch_data,
                                       DataReceivedCallback on_data_received,
                                       ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(impl_, &current_request_ctx_,
                                  base_url_storage_.data(), base_url_len_,
                                  path, HTTP_METHOD_PATCH, headers, patch_data, response_info);
}


HttpsClient::Status HttpsClient::PostStream(std::string_view path, const Headers& headers,
                                            size_t total_body_length,
                                            DataProviderCallback data_provider,
                                            DataReceivedCallback on_data_received,
                                            ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    // Pass tx_buffer_size_ member
    return PerformStreamUploadInternal(impl_, &current_request_ctx_,
                                       base_url_storage_.data(), base_url_len_, tx_buffer_size_,
                                       path, HTTP_METHOD_POST, headers, total_body_length,
                                       data_provider, response_info);
}

HttpsClient::Status HttpsClient::PutStream(std::string_view path, const Headers& headers,
                                           size_t total_body_length,
                                           DataProviderCallback data_provider,
                                           DataReceivedCallback on_data_received,
                                           ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
     // Pass tx_buffer_size_ member
    return PerformStreamUploadInternal(impl_, &current_request_ctx_,
                                       base_url_storage_.data(), base_url_len_, tx_buffer_size_,
                                       path, HTTP_METHOD_PUT, headers, total_body_length,
                                       data_provider, response_info);
}


// StatusToString (unchanged)
const char* HttpsClient::StatusToString(Status status) {
    switch (status) {
        case Status::kOk: return "Ok";
        case Status::kFail: return "Fail";
        case Status::kInvalidArgument: return "InvalidArgument";
        case Status::kNotInitialized: return "NotInitialized";
        case Status::kAlreadyInitialized: return "AlreadyInitialized";
        case Status::kNoMemory: return "NoMemory";
        case Status::kTimeout: return "Timeout";
        case Status::kNetworkError: return "NetworkError";
        case Status::kConnectionError: return "ConnectionError";
        case Status::kTlsError: return "TlsError";
        case Status::kHttpError: return "HttpError";
        case Status::kResponseError: return "ResponseError";
        case Status::kStreamError: return "StreamError";
        case Status::kBufferTooSmall: return "BufferTooSmall";
        case Status::kUnsupported: return "Unsupported";
        default: return "UnknownStatus";
    }
}

------------------------------------------------------------------------------------------

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"

#include "https_client.h" // Include the final client class
#include <vector>          // Keep for example response buffer
#include <string>          // Keep for example response buffer
#include <cstring>         // For strlen, memcpy

static const char* kMainAppTag = "MAIN_APP";

// --- Example Callbacks (Unchanged) ---
HttpsClient::Status OnDataReceivedPrint(const char* data, size_t len, void* user_context) {
    ESP_LOGI(kMainAppTag, "Received chunk (%zu bytes):", len);
    fwrite(data, 1, len, stdout); printf("\n"); // Print raw data
    return HttpsClient::Status::kOk;
}
HttpsClient::Status OnDataReceivedCollect(const char* data, size_t len, void* user_context) {
    std::string* response_buffer = static_cast<std::string*>(user_context);
    // NOTE: This collecting string still uses heap! Use with caution.
    try {
        response_buffer->append(data, len);
    } catch (const std::bad_alloc& e) { // In case app enables exceptions
        ESP_LOGE(kMainAppTag, "Failed memory allocation for response buffer!");
        return HttpsClient::Status::kNoMemory;
    }
    ESP_LOGD(kMainAppTag, "Collected %zu bytes, total %zu", len, response_buffer->length());
    return HttpsClient::Status::kOk;
}

// --- Example Data Provider (Unchanged) ---
struct StreamUploadContext {
    const uint8_t* data_ptr = nullptr;
    size_t total_size = 0;
    size_t sent_size = 0;
};
int ProvideDataChunk(char* buffer, size_t max_len, void* user_context) {
    StreamUploadContext* upload_ctx = static_cast<StreamUploadContext*>(user_context);
    if (!upload_ctx || upload_ctx->sent_size >= upload_ctx->total_size) return 0; // EOF
    size_t remaining = upload_ctx->total_size - upload_ctx->sent_size;
    size_t chunk = (remaining > max_len) ? max_len : remaining;
    memcpy(buffer, upload_ctx->data_ptr + upload_ctx->sent_size, chunk);
    upload_ctx->sent_size += chunk;
    ESP_LOGD(kMainAppTag, "Provided chunk %zu bytes, total sent %zu / %zu", chunk, upload_ctx->sent_size, upload_ctx->total_size);
    return static_cast<int>(chunk);
}

// --- Main Application Task ---
extern "C" void app_main(void) {
    ESP_ERROR_CHECK(nvs_flash_init());
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    // Connect to WiFi... (replace with your actual connection code)
    ESP_LOGI(kMainAppTag, "WiFi Connected (Assuming...)");
    vTaskDelay(pdMS_TO_TICKS(2000)); // Allow time for connection

    HttpsClient https_client;
    HttpsClient::Config client_config = {}; // Zero initialize

    // --- Set Config ---
    client_config.base_url = "https://httpbin.org";
    // ** Caller MUST provide buffer sizes now **
    client_config.buffer_size_rx_bytes = 2048; // Example: 2KB RX
    client_config.buffer_size_tx_bytes = 1024; // Example: 1KB TX (will size stream buffer)
    // Other options
    client_config.verify_server = false; // Example: Skip verification
    client_config.timeout_ms = 20000;    // Increase timeout slightly

    // --- EXAMPLE 1: GET ---
    ESP_LOGI(kMainAppTag, "*** Example 1: GET ***");
    HttpsClient::Status op_status = https_client.Open(client_config);
    if (op_status != HttpsClient::Status::kOk) {
        ESP_LOGE(kMainAppTag, "Failed to open client: %s", HttpsClient::StatusToString(op_status));
        // Handle error (e.g., reboot or retry)
        return;
    }

    std::string get_response_body; // Caution: Still uses heap
    HttpsClient::ResponseInfo get_resp_info;
    HttpsClient::Headers get_headers = {{"User-Agent", "ESP-IDF HttpsClient Final"}};

    op_status = https_client.Get("/get?client=final", get_headers,
                         [&](const char* d, size_t l, void* c){ return OnDataReceivedCollect(d, l, &get_response_body); },
                         &get_resp_info);

    if (op_status == HttpsClient::Status::kOk) {
         ESP_LOGI(kMainAppTag, "GET successful! HTTP Status: %d", get_resp_info.status_code);
         // Process body...
    } else {
        ESP_LOGE(kMainAppTag, "GET failed: %s", HttpsClient::StatusToString(op_status));
    }
    get_response_body.clear(); // Clear for next example


    // --- EXAMPLE 2: PUT Stream ---
    ESP_LOGI(kMainAppTag, "\n*** Example 2: PUT Stream ***");
    const char* dummy_file_content = "Final content, hard limits, vector chunk buf.";
    StreamUploadContext upload_context = {};
    upload_context.data_ptr = reinterpret_cast<const uint8_t*>(dummy_file_content);
    upload_context.total_size = strlen(dummy_file_content);

    HttpsClient::Headers put_headers = {
        {"Content-Type", "text/plain"},
        {"Content-Length", std::to_string(upload_context.total_size)} // C++11 required for std::to_string
    };
    std::string put_response_body; // Caution: Still uses heap
    HttpsClient::ResponseInfo put_resp_info;

    HttpsClient::DataProviderCallback data_provider_lambda =
        [&](char* b, size_t l, void* c){ return ProvideDataChunk(b, l, &upload_context); };
    HttpsClient::DataReceivedCallback response_handler_lambda =
        [&](const char* d, size_t l, void* c){ return OnDataReceivedCollect(d, l, &put_response_body); };

    op_status = https_client.PutStream("/put", put_headers, upload_context.total_size,
                                       data_provider_lambda, response_handler_lambda, &put_resp_info);

    if (op_status == HttpsClient::Status::kOk) {
        ESP_LOGI(kMainAppTag, "PUT Stream successful! HTTP Status: %d", put_resp_info.status_code);
        // Process body...
    } else {
        ESP_LOGE(kMainAppTag, "PUT Stream failed: %s", HttpsClient::StatusToString(op_status));
    }


    // --- Clean up ---
    ESP_LOGI(kMainAppTag, "Closing client.");
    op_status = https_client.Close();
    if (op_status != HttpsClient::Status::kOk) {
         ESP_LOGE(kMainAppTag, "Error closing client: %s", HttpsClient::StatusToString(op_status));
    }

    ESP_LOGI(kMainAppTag, "Example finished.");
}
