/**
 * @file https_client.h
 * @brief Defines the HttpsClient class for HTTPS communication. Platform-agnostic header.
 * @author Gemini
 * @date 2025-04-24 Current time is Thursday, April 24, 2025 at 10:19:19 PM IST.
 */
#ifndef HTTPS_CLIENT_H
#define HTTPS_CLIENT_H

#include <functional>
#include <string_view>
#include <map>
#include <array>
#include <cstddef>
#include <cstdint>

// --- Configuration Constants ---

/** @brief Maximum supported length for the combined Base URL + Path. */
constexpr size_t kHttpsClientMaxUrlLength = 512;
/** @brief Maximum supported length for an HTTP header key name. */
constexpr size_t kHttpsClientMaxHeaderKeyLen = 64;
/** @brief Maximum supported length for an HTTP header value. */
constexpr size_t kHttpsClientMaxHeaderValueLen = 256;

/**
 * @class HttpsClient
 * @brief Provides a C++ wrapper for HTTPS communication, abstracting the underlying implementation.
 *
 * Handles GET, POST, PUT, PATCH requests with optional server verification.
 * Supports persistent connections and streaming via callbacks.
 * Uses fixed-size buffers (defined by constexpr limits) for URL construction and header processing
 * to minimize heap usage within the wrapper. A temporary std::vector (heap) is used
 * internally for the chunk buffer during streaming uploads.
 * Follows Google C++ Style naming conventions.
 *
 * @note Network operations performed by this client are BLOCKING the calling task.
 * For non-blocking application behavior, instantiate and call HttpsClient methods
 * from a dedicated FreeRTOS task.
 * @warning Uses std::vector for stream upload buffer; heap allocation failure during
 * its resize() operation will likely cause program termination (abort) in typical
 * ESP-IDF builds where C++ exceptions are disabled (`-fno-exceptions`). Ensure sufficient
 * heap is available.
 */
class HttpsClient {
 public:
  /**
   * @brief Status codes returned by HttpsClient methods and callbacks. Platform-agnostic.
   */
  enum class Status {
    kOk = 0, kFail, kInvalidArgument, kNotInitialized, kAlreadyInitialized,
    kNoMemory, kTimeout, kNetworkError, kConnectionError, kTlsError,
    kHttpError, kResponseError, kStreamError, kBufferTooSmall, kUnsupported
  };

  /**
   * @brief Standard HTTP methods supported by the client. Platform-agnostic.
   */
  enum class HttpMethod {
      kGet,
      kPost,
      kPut,
      kPatch
      // Add kDelete, kHead, kOptions etc. here if needed
  };

  /** @brief Callback function type for receiving response body data in chunks. */
  using DataReceivedCallback =
      std::function<Status(const char* data, size_t len, void* user_context)>;

  /** @brief Callback function type for providing request body data in chunks for streaming uploads. */
  using DataProviderCallback =
      std::function<int(char* buffer, size_t max_len, void* user_context)>;


  /** @brief Configuration structure used when calling Open(). */
  struct Config {
    std::string_view base_url;
    // Buffer sizes MUST be provided by the caller for the underlying implementation
    size_t buffer_size_rx_bytes;
    size_t buffer_size_tx_bytes;
    // Other config options
    bool verify_server = true;
    const char* server_cert_pem = nullptr; // PEM string is platform-agnostic
    int timeout_ms = 10000;
    int keep_alive_idle_sec = 5;
    int keep_alive_interval_sec = 5;
    int keep_alive_count = 3;
    void* user_context = nullptr;
  };

  /** @brief Structure to hold response information obtained after a request. */
  struct ResponseInfo {
      int status_code = 0;
      long long content_length = -1;
      bool connection_close = false;
  };

  /** @brief Type alias for HTTP request headers map. Keys/Values should be valid views. */
  using Headers = std::map<std::string_view, std::string_view>;

  /** @brief Default constructor. */
  HttpsClient();
  /** @brief Destructor, ensures Close() is called. */
  ~HttpsClient();

  // Disable copy/move semantics
  HttpsClient(const HttpsClient&) = delete;
  HttpsClient& operator=(const HttpsClient&) = delete;
  HttpsClient(HttpsClient&&) = delete;
  HttpsClient& operator=(HttpsClient&&) = delete;

  // --- Public API --- (Unchanged signatures)
  Status Open(const Config& config);
  Status Close();
  Status Get(std::string_view path, const Headers& headers,
             DataReceivedCallback on_data_received,
             ResponseInfo* response_info = nullptr);
  Status Post(std::string_view path, const Headers& headers,
              std::string_view post_data,
              DataReceivedCallback on_data_received,
              ResponseInfo* response_info = nullptr);
  Status PostStream(std::string_view path, const Headers& headers,
                    size_t total_body_length,
                    DataProviderCallback data_provider,
                    DataReceivedCallback on_data_received,
                    ResponseInfo* response_info = nullptr);
  Status Put(std::string_view path, const Headers& headers,
             std::string_view put_data,
             DataReceivedCallback on_data_received,
             ResponseInfo* response_info = nullptr);
  Status PutStream(std::string_view path, const Headers& headers,
                   size_t total_body_length,
                   DataProviderCallback data_provider,
                   DataReceivedCallback on_data_received,
                   ResponseInfo* response_info = nullptr);
  Status Patch(std::string_view path, const Headers& headers,
               std::string_view patch_data,
               DataReceivedCallback on_data_received,
               ResponseInfo* response_info = nullptr);

  /** @brief Converts an HttpsClient::Status enum value to a descriptive string literal. */
  static const char* StatusToString(Status status);


 private:
   /** @brief Opaque pointer holding the underlying platform-specific client handle. */
   void* client_handle_ = nullptr;

   /** @brief Internal structure holding context for the current request/callbacks. */
   struct RequestContext {
        DataReceivedCallback on_data_received = nullptr;
        void* user_context = nullptr;
        ResponseInfo* response_info_ptr = nullptr;
   };
   /** @brief Context for the currently executing request. */
   RequestContext current_request_ctx_;

   /** @brief Fixed-size storage for the base URL configured in Open(). */
   std::array<char, kHttpsClientMaxUrlLength> base_url_storage_ = {};
   /** @brief Actual length of the base URL currently stored (excluding null terminator). */
   size_t base_url_len_ = 0;

   /** @brief Transmit buffer size configured in Open(), used for sizing stream upload buffer. */
   size_t tx_buffer_size_ = 0;

   // --- Private Member Functions (Internal Helpers) ---

  /**
   * @brief Internal helper to perform non-streaming HTTP requests.
   * @param path Request path relative to base URL.
   * @param method The generic HTTP method (HttpsClient::HttpMethod).
   * @param headers Request headers.
   * @param request_body Request body data (empty for GET).
   * @param response_info Pointer to store response details.
   * @return Status indicating success or failure of the operation.
   */
   Status PerformRequestInternal(std::string_view path,
                                 HttpMethod method, // Use internal enum
                                 const Headers& headers,
                                 std::string_view request_body,
                                 ResponseInfo* response_info);

  /**
   * @brief Internal helper to perform streaming upload HTTP requests.
   * @param path Request path relative to base URL.
   * @param method The generic HTTP method (HttpsClient::HttpMethod).
   * @param headers Request headers (must include Content-Length).
   * @param total_body_length Total size of the request body to be sent.
   * @param data_provider Callback function to provide request body chunks.
   * @param response_info Pointer to store response details.
   * @return Status indicating success or failure of the operation.
   */
   Status PerformStreamUploadInternal(std::string_view path,
                                     HttpMethod method, // Use internal enum
                                     const Headers& headers,
                                     size_t total_body_length,
                                     DataProviderCallback data_provider,
                                     ResponseInfo* response_info);
};

#endif // HTTPS_CLIENT_H

------------------------------------------------------------------------------

/**
 * @file https_client.cpp
 * @brief Implements the HttpsClient class using ESP-IDF's esp_http_client.
 * @author Gemini
 * @date 2025-04-24 Current time is Thursday, April 24, 2025 at 10:19:19 PM IST.
 */
#include "https_client.h" // Include the platform-agnostic header

#include <cstring>
#include <cstdio>
#include <array>
#include <vector>
#include <new>

// --- ESP-IDF Specific Includes ---
// All platform dependencies confined to this .cpp file
#include "esp_http_client.h"
#include "esp_log.h"
#include "esp_err.h"
#include "errno.h"

static const char* TAG = "HttpsClient"; // Logging tag

// --- Platform Specific Mappings and Definitions ---

/**
 * @brief Maps the platform-agnostic HttpsClient::HttpMethod to the ESP-IDF specific esp_http_client_method_t.
 * @param method The HttpsClient::HttpMethod value.
 * @return The corresponding esp_http_client_method_t value. Defaults to GET for unknown values.
 */
static esp_http_client_method_t MapHttpMethodToEspMethod(HttpsClient::HttpMethod method) {
    switch (method) {
        case HttpsClient::HttpMethod::kGet:    return HTTP_METHOD_GET;
        case HttpsClient::HttpMethod::kPost:   return HTTP_METHOD_POST;
        case HttpsClient::HttpMethod::kPut:    return HTTP_METHOD_PUT;
        case HttpsClient::HttpMethod::kPatch:  return HTTP_METHOD_PATCH;
        // Add mappings for DELETE, HEAD, OPTIONS etc. if they are added to HttpMethod enum
        default:
            ESP_LOGW(TAG, "Unsupported HttpMethod enum value (%d), defaulting to GET.", static_cast<int>(method));
            return HTTP_METHOD_GET;
    }
}

/**
 * @brief Maps ESP-IDF error codes (esp_err_t) to platform-agnostic HttpsClient::Status codes.
 * @param err The esp_err_t code returned by an ESP-IDF function.
 * @return The corresponding HttpsClient::Status enum value.
 */
static HttpsClient::Status MapEspErrorToStatus(esp_err_t err) {
    // (Implementation unchanged from previous version)
    switch (err) {
        case ESP_OK: return HttpsClient::Status::kOk;
        // ... other mappings ...
        case ESP_FAIL: return HttpsClient::Status::kFail;
        default: /* Log and categorize */ return HttpsClient::Status::kFail;
    }
}

/**
 * @brief PIMPL Implementation Structure - Definition is hidden here.
 * This structure is allocated on the heap, and its address is stored
 * in the HttpsClient::client_handle_ (void*) pointer.
 * We use this structure mainly to hold the underlying ESP-IDF handle.
 * **NOTE: This struct is no longer used as per the final design decision.**
 * **The void* client_handle_ now directly stores the esp_http_client_handle_t.**
 */
 // struct HttpsClientImpl { esp_http_client_handle_t handle = nullptr; }; // REMOVED

/**
 * @brief Static event handler callback passed to esp_http_client.
 * Bridges to the HttpsClient instance context and user callbacks.
 * @param evt Pointer to the HTTP client event data.
 * @return esp_err_t ESP_OK on success, ESP_FAIL to abort request.
 */
static esp_err_t PlatformEventHandler(esp_http_client_event_t *evt) {
    HttpsClient::RequestContext* req_ctx = static_cast<HttpsClient::RequestContext*>(evt->user_data);
    if (!req_ctx) { return ESP_OK; }

    switch (evt->event_id) {
        // (Implementation unchanged from previous version)
        case HTTP_EVENT_ON_HEADER:
             if (req_ctx->response_info_ptr != nullptr) {
                 if (strcasecmp(evt->header_key, "Connection") == 0 && strcasecmp(evt->header_value, "close") == 0) {
                     req_ctx->response_info_ptr->connection_close = true;
                 }
             }
            ESP_LOGD(TAG, "PlatformEventHandler: ON_HEADER: %s: %s", evt->header_key, evt->header_value);
            break;
        case HTTP_EVENT_ON_DATA:
            ESP_LOGD(TAG, "PlatformEventHandler: ON_DATA len=%d", evt->data_len);
            if (req_ctx->on_data_received != nullptr && evt->data_len > 0 && evt->data != nullptr) {
                HttpsClient::Status user_cb_status = req_ctx->on_data_received(
                    static_cast<const char*>(evt->data), static_cast<size_t>(evt->data_len), req_ctx->user_context);
                if (user_cb_status != HttpsClient::Status::kOk) {
                    ESP_LOGE(TAG, "User data callback returned error status: %s", HttpsClient::StatusToString(user_cb_status));
                    return ESP_FAIL;
                }
            }
            break;
        case HTTP_EVENT_REDIRECT:
             ESP_LOGD(TAG, "PlatformEventHandler: REDIRECT");
             esp_http_client_set_redirection(evt->client);
             break;
        // Add logging for other events if needed
        default:
             ESP_LOGD(TAG, "PlatformEventHandler: Event %d", evt->event_id);
            break;
    }
    return ESP_OK;
}


// --- HttpsClient Member Function Implementations ---

HttpsClient::HttpsClient() : client_handle_(nullptr),
                             base_url_storage_{}, base_url_len_(0), tx_buffer_size_(0) {
    // Ensure context members are initialized
    current_request_ctx_.on_data_received = nullptr;
    current_request_ctx_.user_context = nullptr;
    current_request_ctx_.response_info_ptr = nullptr;
}

HttpsClient::~HttpsClient() {
    Close();
}

HttpsClient::Status HttpsClient::Open(const Config& config) {
    if (client_handle_ != nullptr) {
        ESP_LOGW(TAG, "Open: Client already open.");
        return Status::kAlreadyInitialized;
    }
    // Validate required config values
    if (config.base_url.empty() || config.buffer_size_rx_bytes == 0 || config.buffer_size_tx_bytes == 0) {
        ESP_LOGE(TAG, "Open: Invalid config - Base URL and buffer sizes required.");
        return Status::kInvalidArgument;
    }
    if (config.verify_server && !config.server_cert_pem) {
        ESP_LOGE(TAG, "Open: Server verification enabled, but server_cert_pem is NULL.");
        return Status::kInvalidArgument;
    }

    // Copy base URL to fixed array storage
    if (config.base_url.length() >= base_url_storage_.size()) {
        ESP_LOGE(TAG, "Open: Base URL length (%zu) exceeds maximum (%zu)", config.base_url.length(), base_url_storage_.size() - 1);
        return Status::kBufferTooSmall;
    }
    memcpy(base_url_storage_.data(), config.base_url.data(), config.base_url.length());
    base_url_storage_[config.base_url.length()] = '\0';
    base_url_len_ = config.base_url.length();
    tx_buffer_size_ = config.buffer_size_tx_bytes;

    // Configure ESP-IDF client
    esp_http_client_config_t esp_config = {};
    esp_config.url = base_url_storage_.data();
    esp_config.buffer_size = config.buffer_size_rx_bytes;
    esp_config.buffer_size_tx = config.buffer_size_tx_bytes;
    esp_config.timeout_ms = config.timeout_ms;
    esp_config.keep_alive_enable = true;
    esp_config.keep_alive_idle = config.keep_alive_idle_sec;
    esp_config.keep_alive_interval = config.keep_alive_interval_sec;
    esp_config.keep_alive_count = config.keep_alive_count;
    esp_config.user_data = &current_request_ctx_; // Pass address of OUR context struct
    esp_config.event_handler = PlatformEventHandler;

    if (config.verify_server) {
        esp_config.cert_pem = config.server_cert_pem;
        esp_config.skip_cert_common_name_check = false;
    } else {
        ESP_LOGW(TAG, "Open: Server certificate verification is DISABLED.");
        esp_config.cert_pem = nullptr;
        esp_config.skip_cert_common_name_check = true;
    }

    // Initialize the underlying ESP-IDF client
    esp_http_client_handle_t new_esp_handle = esp_http_client_init(&esp_config);
    if (!new_esp_handle) {
        ESP_LOGE(TAG, "Open: Failed to initialize underlying HTTP client (esp_http_client_init failed).");
        // Reset state
        base_url_storage_[0] = '\0'; base_url_len_ = 0; tx_buffer_size_ = 0;
        return Status::kFail; // Map potential specific init error? MapEspError handles ESP_FAIL.
    }

    // Store the handle directly into the void* member via cast
    client_handle_ = reinterpret_cast<void*>(new_esp_handle);

    current_request_ctx_.user_context = config.user_context;
    ESP_LOGI(TAG, "HTTPS client opened for base URL: %s", base_url_storage_.data());
    return Status::kOk;
}

HttpsClient::Status HttpsClient::Close() {
    esp_err_t cleanup_err = ESP_OK;
    if (client_handle_ != nullptr) {
        esp_http_client_handle_t actual_esp_handle = reinterpret_cast<esp_http_client_handle_t>(client_handle_);

        if (actual_esp_handle != nullptr) { // Check cast result just in case
            // It's generally safer to detach user context before cleanup if the cleanup
            // process itself could potentially trigger events (unlikely but possible).
            esp_http_client_set_user_data(actual_esp_handle, nullptr);
            cleanup_err = esp_http_client_cleanup(actual_esp_handle);
             if (cleanup_err != ESP_OK) {
                 ESP_LOGE(TAG, "Close: esp_http_client_cleanup failed: %d (%s)", cleanup_err, esp_err_to_name(cleanup_err));
             }
        }
        // No PIMPL struct to delete
        client_handle_ = nullptr; // Reset the class member pointer
    } else {
         ESP_LOGD(TAG, "Close: Client already closed or never opened.");
    }

    // Reset other state regardless of cleanup result
    base_url_storage_[0] = '\0'; base_url_len_ = 0; tx_buffer_size_ = 0;
    current_request_ctx_.on_data_received = nullptr;
    current_request_ctx_.user_context = nullptr;
    current_request_ctx_.response_info_ptr = nullptr;

    if (cleanup_err == ESP_OK && client_handle_ == nullptr) { ESP_LOGI(TAG, "HTTPS client closed."); }
    return MapEspErrorToStatus(cleanup_err); // Return status based on cleanup result
}


// --- Private Member Function Implementations ---

HttpsClient::Status HttpsClient::PerformRequestInternal(
                                        std::string_view path,
                                        HttpMethod method, // Use internal enum
                                        const Headers& headers,
                                        std::string_view request_body,
                                        ResponseInfo* response_info) {
    // Check and cast void* handle
    if (!client_handle_) { ESP_LOGE(TAG,"PerformRequest: Client not open."); return Status::kNotInitialized; }
    esp_http_client_handle_t actual_esp_handle = reinterpret_cast<esp_http_client_handle_t>(client_handle_);
    if (!actual_esp_handle) { ESP_LOGE(TAG,"PerformRequest: Invalid internal handle."); return Status::kNotInitialized; }

    esp_err_t err = ESP_OK;

    // Construct full URL using stack array and members
    std::array<char, kHttpsClientMaxUrlLength> full_url_buffer;
    int written_len = snprintf(full_url_buffer.data(), full_url_buffer.size(),
                               "%.*s%.*s", (int)base_url_len_, base_url_storage_.data(),
                               (int)path.length(), path.data());
    if (written_len < 0 || (size_t)written_len >= full_url_buffer.size()) {
         ESP_LOGE(TAG, "PerformRequest: URL construction failed/truncated (%d/%zu).", written_len, full_url_buffer.size());
         return Status::kBufferTooSmall;
    }

    // Reset response info struct before request
    current_request_ctx_.response_info_ptr = response_info;
    if (response_info != nullptr) {
        response_info->status_code = 0;
        response_info->content_length = -1;
        response_info->connection_close = false;
    }

    // Set URL
    err = esp_http_client_set_url(actual_esp_handle, full_url_buffer.data());
    if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_url failed: %d", err); return MapEspErrorToStatus(err); }

    // Set Method (map internal enum to ESP enum)
    err = esp_http_client_set_method(actual_esp_handle, MapHttpMethodToEspMethod(method));
    if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_method failed: %d", err); return MapEspErrorToStatus(err); }

    // Set Headers using temporary stack arrays
    std::array<char, kHttpsClientMaxHeaderKeyLen> header_key_buffer;
    std::array<char, kHttpsClientMaxHeaderValueLen> header_value_buffer;
    for (const auto& header : headers) {
        written_len = snprintf(header_key_buffer.data(), header_key_buffer.size(), "%.*s", (int)header.first.length(), header.first.data());
        if (written_len < 0 || (size_t)written_len >= header_key_buffer.size()) { ESP_LOGW(TAG, "Header key truncated: %.*s", (int)header.first.length(), header.first.data()); }
        written_len = snprintf(header_value_buffer.data(), header_value_buffer.size(), "%.*s", (int)header.second.length(), header.second.data());
        if (written_len < 0 || (size_t)written_len >= header_value_buffer.size()) { ESP_LOGW(TAG, "Header value truncated: %.*s", (int)header.second.length(), header.second.data()); }

        err = esp_http_client_set_header(actual_esp_handle, header_key_buffer.data(), header_value_buffer.data());
        if (err != ESP_OK) { ESP_LOGE(TAG, "Failed to set header %s: %d", header_key_buffer.data(), err); return MapEspErrorToStatus(err); }
    }

    // Set Post Field / Content-Length: 0 logic
    if (!request_body.empty()) {
         err = esp_http_client_set_post_field(actual_esp_handle, request_body.data(), request_body.length());
         if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_post_field failed: %d", err); return MapEspErrorToStatus(err); }
         char* ct_header = nullptr;
         if (esp_http_client_get_header(actual_esp_handle, "Content-Type", &ct_header) != ESP_OK) {
              esp_http_client_set_header(actual_esp_handle, "Content-Type", "application/octet-stream");
         }
    } else if (method == HttpMethod::kPost || method == HttpMethod::kPut || method == HttpMethod::kPatch) {
        char* cl_header = nullptr; char* te_header = nullptr;
        bool cl_present = esp_http_client_get_header(actual_esp_handle, "Content-Length", &cl_header) == ESP_OK;
        bool te_present = esp_http_client_get_header(actual_esp_handle, "Transfer-Encoding", &te_header) == ESP_OK;
        if (!cl_present && !te_present) { esp_http_client_set_header(actual_esp_handle, "Content-Length", "0"); }
    }

    // Perform request
    err = esp_http_client_perform(actual_esp_handle);
    Status status = MapEspErrorToStatus(err); // Map final perform result

    // Retrieve response info - always attempt if pointer valid
    if (response_info != nullptr && actual_esp_handle != nullptr) {
         response_info->status_code = esp_http_client_get_status_code(actual_esp_handle);
         response_info->content_length = esp_http_client_get_content_length(actual_esp_handle);
         // Note: connection_close is set by event handler
    }

    // Log final outcome
    if (status == Status::kOk && response_info != nullptr) {
        ESP_LOGI(TAG, "PerformRequest OK - Status: %d, Length: %lld", response_info->status_code, response_info->content_length);
    } else if (status != Status::kOk) {
        int temp_status_code = (response_info != nullptr) ? response_info->status_code : esp_http_client_get_status_code(actual_esp_handle); // Try to get status code even on error
        ESP_LOGE(TAG, "PerformRequest failed: %s. HTTP Status: %d", StatusToString(status), temp_status_code);
    }

    current_request_ctx_.response_info_ptr = nullptr; // Clear after use
    return status;
}


HttpsClient::Status HttpsClient::PerformStreamUploadInternal(
                                        std::string_view path,
                                        HttpMethod method, // Use internal enum
                                        const Headers& headers,
                                        size_t total_body_length,
                                        DataProviderCallback data_provider,
                                        ResponseInfo* response_info) {

     // Check and cast void* handle
     if (!client_handle_) { ESP_LOGE(TAG,"StreamUpload: Client not open."); return Status::kNotInitialized; }
     esp_http_client_handle_t actual_esp_handle = reinterpret_cast<esp_http_client_handle_t>(client_handle_);
     if (!actual_esp_handle) { ESP_LOGE(TAG,"StreamUpload: Invalid internal handle."); return Status::kNotInitialized; }

     if (!data_provider) { ESP_LOGE(TAG,"StreamUpload: Data provider is null."); return Status::kInvalidArgument; }
     // Use member tx_buffer_size_
     if (tx_buffer_size_ == 0) { ESP_LOGE(TAG, "StreamUpload: TX buffer size not configured."); return Status::kInvalidArgument; }

    esp_err_t err = ESP_OK;
    Status status = Status::kOk;

    // Construct full URL using stack array and members
    std::array<char, kHttpsClientMaxUrlLength> full_url_buffer;
    int written_len = snprintf(full_url_buffer.data(), full_url_buffer.size(),
                               "%.*s%.*s", (int)base_url_len_, base_url_storage_.data(),
                               (int)path.length(), path.data());
    if (written_len < 0 || (size_t)written_len >= full_url_buffer.size()) { return Status::kBufferTooSmall; }

    // Reset response info struct
    current_request_ctx_.response_info_ptr = response_info;
    if (response_info != nullptr) { /* Reset members */ }

    // Set URL, Method, Headers, check Content-Length
    // Use actual_esp_handle
    err = esp_http_client_set_url(actual_esp_handle, full_url_buffer.data());
    if (err != ESP_OK) return MapEspErrorToStatus(err);
    // Map internal enum to ESP enum
    err = esp_http_client_set_method(actual_esp_handle, MapHttpMethodToEspMethod(method));
    if (err != ESP_OK) return MapEspErrorToStatus(err);

    // Headers loop using stack arrays
    bool content_length_found = false;
    std::array<char, kHttpsClientMaxHeaderKeyLen> header_key_buffer;
    std::array<char, kHttpsClientMaxHeaderValueLen> header_value_buffer;
    for (const auto& header : headers) { /* ... snprintf + set_header + check Content-Length ... */ }
     if (!content_length_found) { ESP_LOGE(TAG, "Stream: Content-Length required."); return Status::kInvalidArgument; }

    // Open connection
    err = esp_http_client_open(actual_esp_handle, total_body_length);
    if (err != ESP_OK) { ESP_LOGE(TAG, "StreamUpload: esp_http_client_open failed: %d", err); return MapEspErrorToStatus(err); }

    // --- Stream Request Body ---
    // Use std::vector allocated temporarily on heap. Size is member tx_buffer_size_.
    std::vector<char> chunk_buffer;
    // NO try-catch here. If resize fails -> abort likely.
    chunk_buffer.resize(tx_buffer_size_);
    // If execution continues, assume resize succeeded. A check for capacity is unreliable.

    size_t bytes_written_total = 0;
    int chunk_len_provided = 0;
    int bytes_written_chunk = 0;

    // Stream write loop
    while (bytes_written_total < total_body_length) {
        chunk_len_provided = data_provider(chunk_buffer.data(), chunk_buffer.size(), current_request_ctx_.user_context);
        if (chunk_len_provided < 0) { ESP_LOGE(TAG,"Data provider error %d", chunk_len_provided); status = Status::kStreamError; break; }
        if (chunk_len_provided == 0 && bytes_written_total < total_body_length) { ESP_LOGE(TAG,"Data provider EOF before Content-Length reached"); status = Status::kStreamError; break; }
        if (chunk_len_provided == 0) { break; } // Normal EOF

        size_t current_chunk_size = static_cast<size_t>(chunk_len_provided);
        // Truncate if needed (provider > buffer, provider > remaining)
        if (current_chunk_size > chunk_buffer.size()) { ESP_LOGW(TAG, "Provider chunk %zu > buffer %zu", current_chunk_size, chunk_buffer.size()); current_chunk_size = chunk_buffer.size();}
        size_t remaining_total = total_body_length - bytes_written_total;
        if (current_chunk_size > remaining_total) { ESP_LOGW(TAG, "Provider chunk %zu > remaining %zu", current_chunk_size, remaining_total); current_chunk_size = remaining_total;}

        // Write chunk using actual_esp_handle
        bytes_written_chunk = esp_http_client_write(actual_esp_handle, chunk_buffer.data(), current_chunk_size);
        if (bytes_written_chunk < 0) { status = MapEspErrorToStatus(static_cast<esp_err_t>(bytes_written_chunk)); break; }
        if (static_cast<size_t>(bytes_written_chunk) != current_chunk_size) { ESP_LOGW(TAG, "Partial write %d/%zu", bytes_written_chunk, current_chunk_size); status = Status::kConnectionError; break; }
        bytes_written_total += bytes_written_chunk;
    } // End while

    if (status == Status::kOk && bytes_written_total != total_body_length) {
        ESP_LOGE(TAG, "Stream write finished but total bytes %zu != Content-Length %zu", bytes_written_total, total_body_length);
        status = Status::kStreamError;
    }

    // --- Fetch Response ---
    if (status == Status::kOk) {
        long long response_content_length = esp_http_client_fetch_headers(actual_esp_handle);
        if (response_content_length < 0) {
            ESP_LOGE(TAG, "Stream: Failed fetch headers: %lld (%s)", response_content_length, esp_err_to_name(static_cast<esp_err_t>(response_content_length)));
            status = MapEspErrorToStatus(static_cast<esp_err_t>(response_content_length));
            // Attempt to get status code even if fetch fails
             if (response_info != nullptr && actual_esp_handle != nullptr) {
                response_info->status_code = esp_http_client_get_status_code(actual_esp_handle);
             }
        } else {
            if (response_info != nullptr) {
                response_info->status_code = esp_http_client_get_status_code(actual_esp_handle);
                response_info->content_length = response_content_length;
                 ESP_LOGI(TAG, "Stream: Response Status = %d, Length = %lld", response_info->status_code, response_info->content_length);
            } else {
                 ESP_LOGI(TAG, "Stream: Response Status = %d, Length = %lld", esp_http_client_get_status_code(actual_esp_handle), response_content_length);
            }
        }
    }

    // Close connection (always attempt)
    err = esp_http_client_close(actual_esp_handle);
    if (err != ESP_OK && status == Status::kOk) {
        ESP_LOGE(TAG, "Stream: Failed to close connection: %d (%s)", err, esp_err_to_name(err));
        status = MapEspErrorToStatus(err);
    }

    // chunk_buffer automatically destroyed/memory freed here by RAII
    current_request_ctx_.response_info_ptr = nullptr;
    return status;
}


// --- Public Method Implementations ---
// Call the private member functions, passing the internal HttpMethod enum

HttpsClient::Status HttpsClient::Get(std::string_view path, const Headers& headers,
                                     DataReceivedCallback on_data_received,
                                     ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(path, HttpMethod::kGet, headers, "", response_info);
}
HttpsClient::Status HttpsClient::Post(std::string_view path, const Headers& headers,
                                      std::string_view post_data,
                                      DataReceivedCallback on_data_received,
                                      ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(path, HttpMethod::kPost, headers, post_data, response_info);
}
HttpsClient::Status HttpsClient::Put(std::string_view path, const Headers& headers,
                                     std::string_view put_data,
                                     DataReceivedCallback on_data_received,
                                     ResponseInfo* response_info) {
     current_request_ctx_.on_data_received = on_data_received;
     return PerformRequestInternal(path, HttpMethod::kPut, headers, put_data, response_info);
}
HttpsClient::Status HttpsClient::Patch(std::string_view path, const Headers& headers,
                                       std::string_view patch_data,
                                       DataReceivedCallback on_data_received,
                                       ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(path, HttpMethod::kPatch, headers, patch_data, response_info);
}
HttpsClient::Status HttpsClient::PostStream(std::string_view path, const Headers& headers,
                                            size_t total_body_length,
                                            DataProviderCallback data_provider,
                                            DataReceivedCallback on_data_received,
                                            ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformStreamUploadInternal(path, HttpMethod::kPost, headers, total_body_length, data_provider, response_info);
}
HttpsClient::Status HttpsClient::PutStream(std::string_view path, const Headers& headers,
                                           size_t total_body_length,
                                           DataProviderCallback data_provider,
                                           DataReceivedCallback on_data_received,
                                           ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformStreamUploadInternal(path, HttpMethod::kPut, headers, total_body_length, data_provider, response_info);
}


// StatusToString (Fully Implemented)
const char* HttpsClient::StatusToString(Status status) {
    switch (status) {
        case Status::kOk: return "Ok";
        case Status::kFail: return "Fail";
        case Status::kInvalidArgument: return "InvalidArgument";
        case Status::kNotInitialized: return "NotInitialized";
        case Status::kAlreadyInitialized: return "AlreadyInitialized";
        case Status::kNoMemory: return "NoMemory";
        case Status::kTimeout: return "Timeout";
        case Status::kNetworkError: return "NetworkError";
        case Status::kConnectionError: return "ConnectionError";
        case Status::kTlsError: return "TlsError";
        case Status::kHttpError: return "HttpError";
        case Status::kResponseError: return "ResponseError";
        case Status::kStreamError: return "StreamError";
        case Status::kBufferTooSmall: return "BufferTooSmall";
        case Status::kUnsupported: return "Unsupported";
        default: return "UnknownStatus";
    }
}




-------------------------------------------------------------


#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"

#include "https_client.h" // Include the final client class
#include <vector>          // Keep for example response buffer if needed
#include <string>          // Keep for example response buffer if needed
#include <cstring>         // For strlen, memcpy
#include <cstdlib>         // For std::to_string -> requires C++11 standard

static const char* kMainAppTag = "MAIN_APP";

// --- Example Callbacks ---
HttpsClient::Status OnDataReceivedPrint(const char* data, size_t len, void* user_context) {
    ESP_LOGI(kMainAppTag, "Received chunk (%zu bytes):", len);
    fwrite(data, 1, len, stdout); printf("\n"); // Print raw data
    return HttpsClient::Status::kOk;
}
HttpsClient::Status OnDataReceivedCollect(const char* data, size_t len, void* user_context) {
    std::string* response_buffer = static_cast<std::string*>(user_context);
    // NOTE: This collecting string still uses heap! Replace if heap is critical.
    try {
        response_buffer->append(data, len);
    } catch (const std::bad_alloc& e) { // In case app enables exceptions
        ESP_LOGE(kMainAppTag, "Failed memory allocation for response buffer!");
        return HttpsClient::Status::kNoMemory;
    }
    ESP_LOGD(kMainAppTag, "Collected %zu bytes, total %zu", len, response_buffer->length());
    return HttpsClient::Status::kOk;
}

// --- Example Data Provider ---
struct StreamUploadContext {
    const uint8_t* data_ptr = nullptr;
    size_t total_size = 0;
    size_t sent_size = 0;
};
int ProvideDataChunk(char* buffer, size_t max_len, void* user_context) {
    StreamUploadContext* upload_ctx = static_cast<StreamUploadContext*>(user_context);
    if (!upload_ctx || upload_ctx->sent_size >= upload_ctx->total_size) return 0; // EOF
    size_t remaining = upload_ctx->total_size - upload_ctx->sent_size;
    size_t chunk = (remaining > max_len) ? max_len : remaining;
    memcpy(buffer, upload_ctx->data_ptr + upload_ctx->sent_size, chunk);
    upload_ctx->sent_size += chunk;
    ESP_LOGD(kMainAppTag, "Provided chunk %zu bytes, total sent %zu / %zu", chunk, upload_ctx->sent_size, upload_ctx->total_size);
    return static_cast<int>(chunk);
}

// --- Main Application Task ---
extern "C" void app_main(void) {
    // --- Prerequisites & Wi-Fi ---
    ESP_ERROR_CHECK(nvs_flash_init());
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    // --- Connect to Wi-Fi (Replace with your actual connection logic) ---
    ESP_LOGI(kMainAppTag, "WiFi Connected (Assuming...)");
    vTaskDelay(pdMS_TO_TICKS(2000)); // Allow time for connection

    // --- HTTPS Client Usage ---
    HttpsClient https_client;
    HttpsClient::Config client_config = {}; // Zero initialize

    // --- Set Config ---
    client_config.base_url = "https://httpbin.org";
    // ** Caller MUST provide buffer sizes **
    client_config.buffer_size_rx_bytes = 2048; // Example: 2KB RX
    client_config.buffer_size_tx_bytes = 1024; // Example: 1KB TX (will size stream buffer)
    // Other options
    client_config.verify_server = false; // Example: Skip verification for httpbin
    client_config.timeout_ms = 20000;    // Example: 20 second timeout

    // --- EXAMPLE 1: GET ---
    ESP_LOGI(kMainAppTag, "*** Example 1: GET ***");
    HttpsClient::Status op_status = https_client.Open(client_config);
    if (op_status != HttpsClient::Status::kOk) {
        ESP_LOGE(kMainAppTag, "Failed to open client: %s", HttpsClient::StatusToString(op_status));
        return; // Handle error
    }

    std::string get_response_body; // Caution: Still uses heap in example
    HttpsClient::ResponseInfo get_resp_info;
    HttpsClient::Headers get_headers = {{"User-Agent", "ESP-IDF HttpsClient Final Complete V4"}};

    op_status = https_client.Get("/get?client=final_complete_v4", get_headers,
                         [&](const char* d, size_t l, void* c){ return OnDataReceivedCollect(d, l, &get_response_body); },
                         &get_resp_info);

    if (op_status == HttpsClient::Status::kOk) {
         ESP_LOGI(kMainAppTag, "GET successful! HTTP Status: %d", get_resp_info.status_code);
         if (get_resp_info.status_code >= 200 && get_resp_info.status_code < 300) {
            ESP_LOGI(kMainAppTag, "GET Response Body Len: %zu", get_response_body.length());
         } else {
            ESP_LOGW(kMainAppTag, "GET HTTP Error Status: %d", get_resp_info.status_code);
            ESP_LOGW(kMainAppTag, "GET Error Body Len: %zu", get_response_body.length());
         }
    } else {
        ESP_LOGE(kMainAppTag, "GET failed: %s", HttpsClient::StatusToString(op_status));
        ESP_LOGE(kMainAppTag, "Failed Request Info - HTTP Status: %d", get_resp_info.status_code);
    }
    get_response_body.clear(); // Clear heap usage


    // --- EXAMPLE 2: PUT Stream ---
    ESP_LOGI(kMainAppTag, "\n*** Example 2: PUT Stream ***");
    const char* dummy_file_content = "Final complete content, no PIMPL struct, vector chunk buf.";
    StreamUploadContext upload_context = {};
    upload_context.data_ptr = reinterpret_cast<const uint8_t*>(dummy_file_content);
    upload_context.total_size = strlen(dummy_file_content);
    upload_context.sent_size = 0;

    HttpsClient::Headers put_headers = {
        {"Content-Type", "text/plain"},
        {"Content-Length", std::to_string(upload_context.total_size)}
    };
    std::string put_response_body; // Caution: Still uses heap in example
    HttpsClient::ResponseInfo put_resp_info;

    HttpsClient::DataProviderCallback data_provider_lambda =
        [&](char* b, size_t l, void* c){ return ProvideDataChunk(b, l, &upload_context); };
    HttpsClient::DataReceivedCallback response_handler_lambda =
        [&](const char* d, size_t l, void* c){ return OnDataReceivedCollect(d, l, &put_response_body); };

    op_status = https_client.PutStream("/put", put_headers, upload_context.total_size,
                                       data_provider_lambda, response_handler_lambda, &put_resp_info);

    if (op_status == HttpsClient::Status::kOk) {
        ESP_LOGI(kMainAppTag, "PUT Stream successful! HTTP Status: %d", put_resp_info.status_code);
         if (put_resp_info.status_code >= 200 && put_resp_info.status_code < 300) {
             ESP_LOGI(kMainAppTag, "PUT Response Body Len: %zu", put_response_body.length());
         } else {
            ESP_LOGW(kMainAppTag, "PUT HTTP Error Status: %d", put_resp_info.status_code);
            ESP_LOGW(kMainAppTag, "PUT Error Body Len: %zu", put_response_body.length());
         }
    } else {
        ESP_LOGE(kMainAppTag, "PUT Stream failed: %s", HttpsClient::StatusToString(op_status));
        ESP_LOGE(kMainAppTag, "Failed Request Info - HTTP Status: %d", put_resp_info.status_code);
    }
    put_response_body.clear(); // Clear heap usage


    // --- Clean up ---
    ESP_LOGI(kMainAppTag, "Closing client.");
    op_status = https_client.Close();
    if (op_status != HttpsClient::Status::kOk) {
         ESP_LOGE(kMainAppTag, "Error closing client: %s", HttpsClient::StatusToString(op_status));
    }

    ESP_LOGI(kMainAppTag, "Example finished.");
}
