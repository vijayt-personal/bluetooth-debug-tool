/**
 * @file json_wrapper.hpp
 * @brief Defines C++ classes JsonDocument and JsonVariant for intuitive,
 * platform-agnostic JSON manipulation using the cJSON library backend.
 *
 * Provides a DOM-style interface inspired by ArduinoJson/RapidJSON,
 * featuring RAII memory management, fluent navigation, type checking,
 * value access, parsing, serialization, and simplified object/array creation.
 * Adheres to Google C++ Style guidelines.
 */
#ifndef JSON_WRAPPER_HPP
#define JSON_WRAPPER_HPP

#include <cmath>    // For std::llround, std::lround
#include <cstddef>  // For size_t
#include <cstdint>  // For int64_t
#include <limits>   // For std::numeric_limits
#include <string>
#include <utility>  // For std::move
#include <vector>
// Include cJSON header - ensure this path is correct for your build setup
#include "cJSON.h"

// Forward declarations
class JsonDocument;
class JsonVariant;

// --- JsonVariant Class ---

/**
 * @brief A non-owning view/proxy into a specific node within a JsonDocument.
 *
 * Offers methods for type checking, value retrieval, and navigation (objects/arrays).
 * Also provides methods for modifying the underlying JSON structure.
 *
 * @warning Lifespan Dependency: A JsonVariant is only valid as long as the
 * JsonDocument it originates from exists and the relevant node hasn't been
 * structurally altered or deleted. Does not own the cJSON node.
 */
class JsonVariant {
  friend class JsonDocument;  // Allows JsonDocument to create root variants

 public:
  /**
   * @brief Default constructor creating an invalid variant (points to nullptr).
   */
  JsonVariant() = default;

  /**
   * @brief Constructs a JsonVariant view from a raw cJSON node pointer.
   * @param node Pointer to the cJSON node (can be null).
   * @warning Public for flexibility, but use with caution. Ensure the node's
   * lifetime is managed correctly (usually by a JsonDocument). Misuse can lead
   * to dangling pointers or memory issues. Prefer obtaining variants via
   * JsonDocument::GetRoot() or navigation operators/methods.
   */
  explicit JsonVariant(cJSON* node) : node_(node) {}

  // --- State & Type Checking ---

  /** @brief Checks if the variant points to a valid (non-null) cJSON node. */
  bool IsValid() const { return node_ != nullptr; }

  /** @brief Checks validity, allowing `if (variant)` style checks. */
  explicit operator bool() const { return IsValid(); }

  /** @brief Checks if the underlying node is JSON null. */
  bool IsNull() const { return IsValid() && cJSON_IsNull(node_); }
  /** @brief Checks if the underlying node is JSON boolean (true or false). */
  bool IsBool() const { return IsValid() && cJSON_IsBool(node_); }
  /** @brief Checks if the underlying node is JSON number. */
  bool IsNumber() const { return IsValid() && cJSON_IsNumber(node_); }
  /** @brief Checks if the underlying node is JSON string. */
  bool IsString() const { return IsValid() && cJSON_IsString(node_); }
  /** @brief Checks if the underlying node is JSON array. */
  bool IsArray() const { return IsValid() && cJSON_IsArray(node_); }
  /** @brief Checks if the underlying node is JSON object. */
  bool IsObject() const { return IsValid() && cJSON_IsObject(node_); }

  // --- Value Retrieval (Read-Only) ---

  /**
   * @brief Gets value as boolean. Converts numbers (0=false, else=true).
   * @param default_val Value returned if invalid or type incompatible.
   * @return Boolean value or default.
   */
  bool AsBool(bool default_val = false) const;

  /**
   * @brief Gets value as double. Converts booleans (true=1.0, false=0.0).
   * @param default_val Value returned if invalid or type incompatible.
   * @return Double value or default.
   */
  double AsDouble(double default_val = 0.0) const;

  /**
   * @brief Gets value as int (rounds double). Check range if needed.
   * @param default_val Value returned if invalid or type incompatible.
   * @return Integer value or default.
   */
  int AsInt(int default_val = 0) const;

  /**
   * @brief Gets value as int64_t (rounds double). Check range if needed.
   * @param default_val Value returned if invalid or type incompatible.
   * @return 64-bit integer value or default.
   */
  int64_t AsInt64(int64_t default_val = 0LL) const;

  /**
   * @brief Gets value as std::string (creates a copy).
   * @param default_val Value returned if invalid or not a string.
   * @return String value or default.
   */
  std::string AsString(const std::string& default_val = "") const;

  // --- Navigation ---

  /**
   * @brief Checks if this object variant contains a specific member key.
   * @param key Member key (case-sensitive).
   * @return True if valid object and contains key.
   */
  bool HasMember(const char* key) const;

  /**
   * @brief Accesses an object member by key (read-only access).
   * @param key Member key (case-sensitive).
   * @return JsonVariant view. Invalid if not object or key doesn't exist.
   */
  JsonVariant operator[](const char* key) const;

  /**
   * @brief Accesses an object member by key (read-only access).
   * @param key Member key (case-sensitive).
   * @return JsonVariant view. Invalid if not object or key doesn't exist.
   */
  JsonVariant operator[](const std::string& key) const {
    return (*this)[key.c_str()];
  }

  /**
   * @brief Gets the number of elements if this variant is an array.
   * @return Array size, or 0 if not a valid array.
   */
  int GetSize() const;

  /**
   * @brief Accesses an array element by index (read-only access).
   * @param index Zero-based index.
   * @return JsonVariant view. Invalid if not array or index out of bounds.
   */
  JsonVariant operator[](int index) const;

  // --- Modification (Values) ---

  /**
   * @brief Sets value if node is already boolean.
   * @param value New value.
   * @return True on success.
   */
  bool SetBool(bool value);

  /**
   * @brief Sets value if node is already number.
   * @param value New value.
   * @return True on success.
   */
  bool SetDouble(double value);

  /**
   * @brief Sets value if node is already string (allocates copy).
   * @param value New C-string value (copied). Nullptr clears the string.
   * @return True on success (incl. allocation).
   */
  bool SetString(const char* value);

  /**
   * @brief Sets value if node is already string (allocates copy).
   * @param value New string value (copied).
   * @return True on success (incl. allocation).
   */
  bool SetString(const std::string& value) { return SetString(value.c_str()); }

  /** @brief Convenience: Sets value if node is number. */
  bool SetInt(int value) { return SetDouble(static_cast<double>(value)); }
  /** @brief Convenience: Sets value if node is number. */
  bool SetInt64(int64_t value) { return SetDouble(static_cast<double>(value)); }

  // --- Modification (Structure - Adding Primitives) ---

  /**
   * @brief Adds item to this array variant. Returns variant to added item.
   * @param item Valid variant to add (content duplicated).
   * @return Variant to added item, or invalid variant on failure.
   */
  JsonVariant AddItem(const JsonVariant& item);
  /** @brief Adds boolean item to this array. Returns variant to added item. */
  JsonVariant AddItem(bool value);
  /** @brief Adds double item to this array. Returns variant to added item. */
  JsonVariant AddItem(double value);
  /** @brief Adds C-string item (copied) to this array. Returns variant to item. */
  JsonVariant AddItem(const char* value);
  /** @brief Adds string item (copied) to this array. Returns variant to item. */
  JsonVariant AddItem(const std::string& value) { return AddItem(value.c_str()); }
  /** @brief Adds integer item to this array. Returns variant to added item. */
  JsonVariant AddItem(int value) { return AddItem(static_cast<double>(value)); }
  /** @brief Adds 64-bit int item to this array. Returns variant to added item. */
  JsonVariant AddItem(int64_t value) {
    return AddItem(static_cast<double>(value));
  }

  /**
   * @brief Adds/replaces member in this object variant with copy of another.
   * @param key Member key.
   * @param item Valid variant value (content duplicated).
   * @return Variant to added/set member, or invalid variant on failure.
   */
  JsonVariant AddMember(const char* key, const JsonVariant& item);
  /** @brief Adds/sets boolean member. Returns variant to member. */
  JsonVariant AddMember(const char* key, bool value);
  /** @brief Adds/sets double member. Returns variant to member. */
  JsonVariant AddMember(const char* key, double value);
  /** @brief Adds/sets C-string member (copied). Returns variant to member. */
  JsonVariant AddMember(const char* key, const char* value);
  /** @brief Adds/sets variant member (copied). Returns variant to member. */
  JsonVariant AddMember(const std::string& key, const JsonVariant& item) {
    return AddMember(key.c_str(), item);
  }
  /** @brief Adds/sets boolean member. Returns variant to member. */
  JsonVariant AddMember(const std::string& key, bool value) {
    return AddMember(key.c_str(), value);
  }
  /** @brief Adds/sets double member. Returns variant to member. */
  JsonVariant AddMember(const std::string& key, double value) {
    return AddMember(key.c_str(), value);
  }
  /** @brief Adds/sets C-string member (copied). Returns variant to member. */
  JsonVariant AddMember(const std::string& key, const char* value) {
    return AddMember(key.c_str(), value);
  }
  /** @brief Adds/sets string member (copied). Returns variant to member. */
  JsonVariant AddMember(const std::string& key, const std::string& value) {
    return AddMember(key.c_str(), value.c_str());
  }
  /** @brief Adds/sets integer member. Returns variant to member. */
  JsonVariant AddMember(const char* key, int value) {
    return AddMember(key, static_cast<double>(value));
  }
  /** @brief Adds/sets 64-bit int member. Returns variant to member. */
  JsonVariant AddMember(const char* key, int64_t value) {
    return AddMember(key, static_cast<double>(value));
  }
  /** @brief Adds/sets integer member. Returns variant to member. */
  JsonVariant AddMember(const std::string& key, int value) {
    return AddMember(key.c_str(), static_cast<double>(value));
  }
  /** @brief Adds/sets 64-bit int member. Returns variant to member. */
  JsonVariant AddMember(const std::string& key, int64_t value) {
    return AddMember(key.c_str(), static_cast<double>(value));
  }

  // --- Modification (Structure - Adding Objects/Arrays) ---

  /**
   * @brief Adds/replaces member in object with a new empty object.
   * @param key Member key.
   * @return Variant to the new empty object, or invalid variant on failure.
   */
  JsonVariant AddObjectMember(const char* key);

  /** @brief Adds/replaces member in object with a new empty object. */
  JsonVariant AddObjectMember(const std::string& key) {
    return AddObjectMember(key.c_str());
  }

  /**
   * @brief Adds/replaces member in object with a new empty array.
   * @param key Member key.
   * @return Variant to the new empty array, or invalid variant on failure.
   */
  JsonVariant AddArrayMember(const char* key);

  /** @brief Adds/replaces member in object with a new empty array. */
  JsonVariant AddArrayMember(const std::string& key) {
    return AddArrayMember(key.c_str());
  }

  /**
   * @brief Adds a new empty object item to this array variant.
   * @return Variant to the new empty object, or invalid variant on failure.
   */
  JsonVariant AddObjectItem();

  /**
   * @brief Adds a new empty array item to this array variant.
   * @return Variant to the new empty array, or invalid variant on failure.
   */
  JsonVariant AddArrayItem();

  // --- Internal Access ---

  /**
   * @brief Gets the internal non-owning cJSON node pointer.
   * @return Raw cJSON pointer, or nullptr if invalid.
   * @warning Use with caution. Direct manipulation bypasses wrapper logic.
   */
  cJSON* GetInternalPtr() const { return node_; }

 private:
  cJSON* node_ = nullptr;  // Pointer to the cJSON node (non-owning).
};

// --- JsonDocument Class ---

/**
 * @brief Represents an owning JSON document structure using cJSON.
 *
 * Manages root cJSON object lifetime via RAII. Provides methods for parsing
 * (deserializing), serializing, and creating JSON documents.
 * Adheres to Google C++ Style guidelines.
 */
class JsonDocument {
 public:
  /** @brief Default constructor. Creates an empty/invalid document. */
  JsonDocument() = default;

  /**
   * @brief Parses (deserializes) JSON string. Check IsValid() after.
   * @param json_string JSON string to parse.
   */
  explicit JsonDocument(const std::string& json_string);

  /**
   * @brief Parses (deserializes) JSON C-string. Check IsValid() after.
   * @param json_string Null-terminated JSON C-string to parse.
   */
  explicit JsonDocument(const char* json_string);

  /** @brief Move constructor. Transfers ownership of the cJSON root. */
  JsonDocument(JsonDocument&& other) noexcept;

  /** @brief Move assignment operator. Transfers ownership. */
  JsonDocument& operator=(JsonDocument&& other) noexcept;

  // Deleted copy semantics (prevents accidental expensive deep copies).
  // Implement explicitly using cJSON_Duplicate if needed.
  JsonDocument(const JsonDocument&) = delete;
  JsonDocument& operator=(const JsonDocument&) = delete;

  /** @brief Destructor. Frees the cJSON tree via cJSON_Delete (RAII). */
  ~JsonDocument();

  // --- Parsing & Serialization ---

  /**
   * @brief Parses (deserializes) JSON string, replacing current content.
   * @param json_string JSON string to parse.
   * @return True on success, false otherwise (check IsValid()).
   */
  bool Parse(const std::string& json_string);

  /**
   * @brief Parses (deserializes) JSON C-string, replacing current content.
   * @param json_string Null-terminated JSON C-string to parse.
   * @return True on success, false otherwise (check IsValid()).
   */
  bool Parse(const char* json_string);

  /**
   * @brief Serializes the JSON document to a string.
   * @param pretty True for formatted output, false for compact.
   * @return JSON string. Empty string or "null" on failure/if empty doc.
   */
  std::string Serialize(bool pretty = false) const;

  // --- State & Root Access ---

  /** @brief Checks if the document holds a valid (non-null) root node. */
  bool IsValid() const { return root_ != nullptr; }

  /** @brief Checks validity, allowing `if (doc)` style checks. */
  explicit operator bool() const { return IsValid(); }

  /** @brief Gets a non-owning view of the document's root element. */
  JsonVariant GetRoot() const;

  // --- Document Creation ---

  /** @brief Clears content and creates a new empty JSON object root. */
  bool CreateObject();

  /** @brief Clears content and creates a new empty JSON array root. */
  bool CreateArray();

  // --- Internal Access ---

  /**
   * @brief Gets internal owning cJSON root pointer.
   * @return Raw owning cJSON pointer, or nullptr if empty/invalid.
   * @warning Use with extreme caution. Bypasses RAII if misused.
   */
  cJSON* GetInternalPtr() const { return root_; }

 private:
  /** @brief Helper to safely delete the current root node. */
  void Clear();

  cJSON* root_ = nullptr;  // Owning pointer to the root cJSON object.
};

#endif  // JSON_WRAPPER_HPP
