/**
 * @file https_client.h
 * @brief Defines the HttpsClient class for HTTPS communication using the PIMPL idiom.
 * The public interface is platform-agnostic; implementation details are hidden.
 * @author Gemini
 * @date 2025-05-27 Current time is Tuesday, May 27, 2025 at 2:33:12 PM IST.
 */
#ifndef HTTPS_CLIENT_H
#define HTTPS_CLIENT_H

#include <functional>
#include <string_view>
#include <map>
#include <memory>  // For std::unique_ptr
#include <cstddef> // For size_t
#include <cstdint> // For uint8_t etc.

/**
 * @class HttpsClient
 * @brief Provides a C++ PIMPL-based wrapper for HTTPS communication.
 *
 * This class offers a simplified interface for performing common HTTPS requests
 * like GET, POST, HEAD, etc. It uses the PIMPL (Pointer to Implementation)
 * idiom to hide platform-specific details (e.g., ESP-IDF's esp_http_client)
 * from the user, ensuring a clean header and reduced compilation dependencies.
 *
 * All network operations are blocking. For non-blocking behavior, instantiate
 * and use this client from a dedicated thread or task.
 */
class HttpsClient {
public:
    // --- Public Nested Types and Constants ---

    /** @brief Maximum supported length for a full URL passed to request methods. */
    static constexpr size_t kMaxUrlLength = 2048;
    /** @brief Maximum supported length for an HTTP header key name. */
    static constexpr size_t kMaxHeaderKeyLen = 64;
    /** @brief Maximum supported length for an HTTP header value. */
    static constexpr size_t kMaxHeaderValueLen = 512;

    /**
     * @brief Status codes returned by HttpsClient methods and callbacks.
     */
    enum class Status {
        kOk = 0,             ///< Operation successful.
        kFail,               ///< Generic failure.
        kInvalidArgument,    ///< Invalid argument provided to an HttpsClient method.
        kNotInitialized,     ///< Client is not initialized (Open not called or failed/closed).
        kAlreadyInitialized, ///< Open() called when client is already open.
        kNoMemory,           ///< Memory allocation failed internally or in underlying libraries.
        kTimeout,            ///< Operation timed out.
        kNetworkError,       ///< Lower-level network error (DNS, TCP, socket, etc.).
        kConnectionError,    ///< Failed to establish connection or connection was lost.
        kTlsError,           ///< TLS handshake or encryption/decryption error.
        kHttpError,          ///< HTTP protocol error (e.g., parsing, malformed response).
        kResponseError,      ///< Error indicated by HTTP status code (e.g., 4xx, 5xx). Note: method might still return kOk if transport succeeded.
        kStreamError,        ///< Error during request or response streaming (e.g., callback error, unexpected EOF).
        kBufferTooSmall,     ///< A provided buffer or an internal limit (like kMaxUrlLength) was too small.
        kUnsupported         ///< The requested feature or operation is not supported by the implementation.
    };

    /**
     * @brief Standard HTTP methods supported by the client.
     */
    enum class HttpMethod {
        kGet,   ///< HTTP GET method.
        kPost,  ///< HTTP POST method.
        kPut,   ///< HTTP PUT method.
        kPatch, ///< HTTP PATCH method.
        kHead   ///< HTTP HEAD method.
    };

    /**
     * @brief Converts an HttpsClient::Status enum value to a descriptive string literal.
     * @param status The status code to convert.
     * @return A null-terminated string describing the status. Never returns null.
     */
    static const char* StatusToString(Status status);

    /** @brief Callback for receiving response body data. */
    using DataReceivedCallback =
        std::function<Status(const char* data, size_t len, void* user_context)>;
    /** @brief Callback for providing request body data for streaming. */
    using DataProviderCallback =
        std::function<int(char* buffer, size_t max_len, void* user_context)>;

    /** @brief Configuration for the HttpsClient. */
    struct Config {
        size_t buffer_size_rx_bytes = 4096; ///< RX buffer size for underlying implementation.
        size_t buffer_size_tx_bytes = 4096; ///< TX buffer size for underlying implementation.
        bool verify_server = true;          ///< Enable server certificate verification.
        const char* server_cert_pem = nullptr; ///< Server's root CA certificate in PEM format.
        int timeout_ms = 10000;             ///< Connection and request timeout in milliseconds.
        int keep_alive_idle_sec = 5;        ///< TCP Keep-Alive idle time in seconds.
        int keep_alive_interval_sec = 5;    ///< TCP Keep-Alive interval in seconds.
        int keep_alive_count = 3;           ///< TCP Keep-Alive number of probes.
        /** @brief User context pointer for callbacks, set during Open(). */
        void* user_context = nullptr;
    };

    /** @brief Holds response information. */
    struct ResponseInfo {
        int status_code = 0;                ///< HTTP status code from server.
        long long content_length = -1;      ///< Content-Length from response headers.
        bool connection_close = false;      ///< True if 'Connection: close' was received.
    };

    /** @brief Type for HTTP request headers. */
    using Headers = std::map<std::string_view, std::string_view>;

    // --- Constructor and Destructor ---
    /**
     * @brief Constructs an HttpsClient instance.
     * The client is not ready for requests until Open() is successfully called.
     */
    HttpsClient();
    /**
     * @brief Destroys the HttpsClient instance and cleans up resources.
     * Automatically calls Close() if the client was open.
     * @note The definition is in the .cpp file to allow `std::unique_ptr<PlatformHttpClientImpl>`
     * to correctly delete the `PlatformHttpClientImpl` object (which requires `PlatformHttpClientImpl` to be a complete type).
     */
    ~HttpsClient();

    // --- Rule of Five/Six: Non-Copyable and Non-Movable ---
    HttpsClient(const HttpsClient&) = delete;
    HttpsClient& operator=(const HttpsClient&) = delete;
    HttpsClient(HttpsClient&&) = delete;
    HttpsClient& operator=(HttpsClient&&) = delete;

    // --- Public API Methods ---

    /**
     * @brief Initializes the client and underlying resources. BLOCKING.
     * @param config Configuration settings for this client instance.
     * @return Status::kOk on success, or an error status otherwise.
     */
    Status Open(const Config& config);

    /**
     * @brief Closes any open connection and releases resources. BLOCKING (potentially).
     * Safe to call even if already closed or never opened.
     * @return Status::kOk on success, or an error status on cleanup failure.
     */
    Status Close();

    /**
     * @brief Performs an HTTP HEAD request to retrieve headers. BLOCKING.
     * @param url The full URL. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers Additional request headers.
     * @param response_info Pointer to store response details. Cannot be nullptr for HEAD.
     * @return Status::kOk on transport/protocol success. Check response_info->status_code for HTTP success.
     */
    Status Head(std::string_view url, const Headers& headers, ResponseInfo* response_info);

    /**
     * @brief Performs an HTTP GET request. BLOCKING.
     * @param url The full URL. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers Additional request headers.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to store response details.
     * @return Status::kOk on transport/protocol success. Check response_info->status_code.
     */
    Status Get(std::string_view url, const Headers& headers,
               DataReceivedCallback on_data_received,
               ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP POST request. BLOCKING.
     * @param url The full URL. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers Additional request headers (e.g., "Content-Type").
     * @param post_data The entire request body.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to store response details.
     * @return Status::kOk on transport/protocol success. Check response_info->status_code.
     */
    Status Post(std::string_view url, const Headers& headers,
                std::string_view post_data,
                DataReceivedCallback on_data_received,
                ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP POST request with a streaming request body. BLOCKING.
     * @param url The full URL. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers Additional request headers (MUST include "Content-Length").
     * @param total_body_length Total size in bytes of the request body.
     * @param data_provider Callback to provide request body chunks. Must not be nullptr.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to store response details.
     * @return Status::kOk on transport/protocol success. Check response_info->status_code.
     */
    Status PostStream(std::string_view url, const Headers& headers,
                      size_t total_body_length,
                      DataProviderCallback data_provider,
                      DataReceivedCallback on_data_received,
                      ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP PUT request. BLOCKING.
     * @param url The full URL. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers Additional request headers.
     * @param put_data The entire request body.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to store response details.
     * @return Status::kOk on transport/protocol success. Check response_info->status_code.
     */
    Status Put(std::string_view url, const Headers& headers,
               std::string_view put_data,
               DataReceivedCallback on_data_received,
               ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP PUT request with a streaming request body. BLOCKING.
     * @param url The full URL. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers Additional request headers (MUST include "Content-Length").
     * @param total_body_length The total size in bytes of the request body.
     * @param data_provider Callback to provide request body chunks. Must not be nullptr.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to store response details.
     * @return Status::kOk on transport/protocol success. Check response_info->status_code.
     */
    Status PutStream(std::string_view url, const Headers& headers,
                     size_t total_body_length,
                     DataProviderCallback data_provider,
                     DataReceivedCallback on_data_received,
                     ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP PATCH request. BLOCKING.
     * @param url The full URL. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers Additional request headers.
     * @param patch_data The entire request body data.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to store response details.
     * @return Status::kOk on transport/protocol success. Check response_info->status_code.
     */
    Status Patch(std::string_view url, const Headers& headers,
                 std::string_view patch_data,
                 DataReceivedCallback on_data_received,
                 ResponseInfo* response_info = nullptr);

private:
    /**
     * @class PlatformHttpClientImpl
     * @brief Forward declaration for the PIMPL pattern.
     * The actual definition of this class is hidden in the .cpp file
     * and contains platform-specific implementation details (e.g., for ESP32).
     */
    class PlatformHttpClientImpl;
    /**
     * @brief Unique pointer to the opaque implementation object.
     */
    std::unique_ptr<PlatformHttpClientImpl> impl_;
};

#endif // HTTPS_CLIENT_H

------------------------------------------------------------------------------------------------------

/**
 * @file https_client.cpp
 * @brief Implements the HttpsClient class using the PIMPL idiom.
 * The HttpsClient::PlatformHttpClientImpl class encapsulates ESP-IDF specific details.
 * @author Gemini
 * @date 2025-05-27 Current time is Tuesday, May 27, 2025 at 2:51:00 PM IST.
 */
#include "https_client.h" // Public interface

#include <cstring> // For memcpy, strlen, strcasecmp
#include <cstdio>  // For snprintf
#include <array>   // For stack arrays for headers/URL
#include <vector>  // For temporary chunk buffer (heap allocated)

// --- ESP-IDF Specific Includes (Hidden from header) ---
#include "esp_http_client.h"
#include "esp_log.h"
#include "esp_err.h"

#ifndef ESP32_PLATFORM // Guard for local builds/IDE
#define ESP32_PLATFORM
#endif

#ifdef ESP32_PLATFORM
#include "esp_crt_bundle.h"
#endif
#include "errno.h" 

// Logging Tag for the implementation details
static const char* TAG_IMPL = "HttpsClientImpl";

// --- HttpsClient::PlatformHttpClientImpl Definition ---
class HttpsClient::PlatformHttpClientImpl {
public:
    using Status = HttpsClient::Status;
    using HttpMethod = HttpsClient::HttpMethod;
    using Config = HttpsClient::Config;
    using ResponseInfo = HttpsClient::ResponseInfo;
    using Headers = HttpsClient::Headers;
    using DataReceivedCallback = HttpsClient::DataReceivedCallback;
    using DataProviderCallback = HttpsClient::DataProviderCallback;

    struct ImplRequestContext {
        DataReceivedCallback on_data_received_cb = nullptr;   
        void* user_context_from_config = nullptr;           
        ResponseInfo* response_info_ptr_user = nullptr;     
    };

    esp_http_client_handle_t esp_client_handle_ = nullptr;
    ImplRequestContext current_request_ctx_; 
    size_t tx_buffer_size_ = 0;         

    PlatformHttpClientImpl() = default;

    ~PlatformHttpClientImpl() {
        if (esp_client_handle_) {
            Close(); 
        }
    }

    Status Open(const Config& config) {
        if (esp_client_handle_) {
            ESP_LOGW(TAG_IMPL, "Open: Client already initialized.");
            return Status::kAlreadyInitialized;
        }
        if (config.buffer_size_rx_bytes == 0 || config.buffer_size_tx_bytes == 0) {
            ESP_LOGE(TAG_IMPL, "Open: Buffer sizes must be non-zero.");
            return Status::kInvalidArgument;
        }

        tx_buffer_size_ = config.buffer_size_tx_bytes;

        esp_http_client_config_t esp_config = {};
        esp_config.url = "http://dummy.invalid"; 
        esp_config.buffer_size = config.buffer_size_rx_bytes;
        esp_config.buffer_size_tx = config.buffer_size_tx_bytes;
        esp_config.timeout_ms = config.timeout_ms;
        esp_config.keep_alive_enable = true;
        esp_config.keep_alive_idle = config.keep_alive_idle_sec;
        esp_config.keep_alive_interval = config.keep_alive_interval_sec;
        esp_config.keep_alive_count = config.keep_alive_count;
        
        current_request_ctx_ = {}; 
        current_request_ctx_.user_context_from_config = config.user_context;
        esp_config.user_data = &current_request_ctx_; 
        esp_config.event_handler = PlatformHttpClientImpl::PlatformEventHandler; 

        if (config.verify_server) {
            esp_config.cert_pem = config.server_cert_pem;
            esp_config.skip_cert_common_name_check = false;
            #if defined(ESP32_PLATFORM) && defined(CONFIG_ESP_TLS_CRT_BUNDLE_ATTACH)
                esp_config.crt_bundle_attach = esp_crt_bundle_attach;
                ESP_LOGI(TAG_IMPL, "Open: ESP-TLS CRT Bundle Attach enabled via Kconfig.");
            #else
                if (!config.server_cert_pem) {
                    ESP_LOGW(TAG_IMPL, "Open: Server verification ON, but no server_cert_pem provided and CRT bundle not used/available.");
                }
            #endif
        } else {
            ESP_LOGW(TAG_IMPL, "Open: Server certificate verification is DISABLED.");
            esp_config.cert_pem = nullptr;
            esp_config.skip_cert_common_name_check = true;
        }

        esp_client_handle_ = esp_http_client_init(&esp_config);
        if (!esp_client_handle_) {
            ESP_LOGE(TAG_IMPL, "Open: esp_http_client_init failed.");
            tx_buffer_size_ = 0; 
            return Status::kFail;
        }
        ESP_LOGI(TAG_IMPL, "PlatformHttpClientImpl opened successfully (ESP32).");
        return Status::kOk;
    }

    Status Close() {
        esp_err_t err = ESP_OK;
        if (esp_client_handle_) {
            esp_http_client_set_user_data(esp_client_handle_, nullptr);
            err = esp_http_client_cleanup(esp_client_handle_);
            esp_client_handle_ = nullptr;
            tx_buffer_size_ = 0;
            if (err != ESP_OK) {
                ESP_LOGE(TAG_IMPL, "Close: esp_http_client_cleanup failed: %s", esp_err_to_name(err));
            }
        } else {
            ESP_LOGD(TAG_IMPL, "Close: Client was already closed or never opened.");
        }
        current_request_ctx_ = {}; 
        if (err == ESP_OK) { ESP_LOGI(TAG_IMPL, "PlatformHttpClientImpl closed."); }
        return MapEspErrorToStatus(err);
    }

    Status PerformRequestInternal(std::string_view url, HttpMethod method_enum,
                                  const Headers& headers, std::string_view request_body,
                                  ResponseInfo* response_info_user) {
        if (!esp_client_handle_) {
            ESP_LOGE(TAG_IMPL, "PerformRequestInternal: Client not initialized.");
            return Status::kNotInitialized;
        }

        current_request_ctx_.response_info_ptr_user = response_info_user;
        
        if (response_info_user) { 
            *response_info_user = {}; 
        }

        esp_err_t err_esp;
        std::array<char, HttpsClient::kMaxUrlLength> url_buffer;
        int len = snprintf(url_buffer.data(), url_buffer.size(), "%.*s", (int)url.length(), url.data());
        if (len < 0 || static_cast<size_t>(len) >= url_buffer.size()) {
            ESP_LOGE(TAG_IMPL, "PerformRequestInternal: URL '%.*s' (len %zu) exceeds max length %zu.",
                     (int)url.length(), url.data(), url.length(), HttpsClient::kMaxUrlLength - 1);
            return Status::kBufferTooSmall;
        }

        err_esp = esp_http_client_set_url(esp_client_handle_, url_buffer.data());
        if (err_esp != ESP_OK) { ESP_LOGE(TAG_IMPL, "PerformRequestInternal: set_url failed: %s", esp_err_to_name(err_esp)); return MapEspErrorToStatus(err_esp); }

        err_esp = esp_http_client_set_method(esp_client_handle_, MapHttpMethodToEsp(method_enum));
        if (err_esp != ESP_OK) { ESP_LOGE(TAG_IMPL, "PerformRequestInternal: set_method failed: %s", esp_err_to_name(err_esp)); return MapEspErrorToStatus(err_esp); }

        std::array<char, HttpsClient::kMaxHeaderKeyLen> header_key_buffer; // Renamed
        std::array<char, HttpsClient::kMaxHeaderValueLen> header_value_buffer; // Renamed
        for (const auto& h : headers) {
            snprintf(header_key_buffer.data(), header_key_buffer.size(), "%.*s", (int)h.first.length(), h.first.data());
            snprintf(header_value_buffer.data(), header_value_buffer.size(), "%.*s", (int)h.second.length(), h.second.data());
            if (strnlen(header_key_buffer.data(), header_key_buffer.size()) >= header_key_buffer.size() - 1) { ESP_LOGW(TAG_IMPL, "Header key truncated: %.*s", (int)h.first.length(), h.first.data()); }
            if (strnlen(header_value_buffer.data(), header_value_buffer.size()) >= header_value_buffer.size() - 1) { ESP_LOGW(TAG_IMPL, "Header value for '%.*s' truncated.", (int)h.first.length(), h.first.data()); }
            err_esp = esp_http_client_set_header(esp_client_handle_, header_key_buffer.data(), header_value_buffer.data());
            if (err_esp != ESP_OK) { ESP_LOGE(TAG_IMPL, "PerformRequestInternal: set_header '%s' failed: %s", header_key_buffer.data(), esp_err_to_name(err_esp)); return MapEspErrorToStatus(err_esp); }
        }

        if (!request_body.empty()) {
            err_esp = esp_http_client_set_post_field(esp_client_handle_, request_body.data(), request_body.length());
            if (err_esp != ESP_OK) { ESP_LOGE(TAG_IMPL, "PerformRequestInternal: set_post_field failed: %s", esp_err_to_name(err_esp)); return MapEspErrorToStatus(err_esp); }
            char* ct_val = nullptr;
            if (esp_http_client_get_header(esp_client_handle_, "Content-Type", &ct_val) != ESP_OK || ct_val == nullptr) {
                ESP_LOGD(TAG_IMPL, "PerformRequestInternal: Auto-setting Content-Type to application/octet-stream.");
                esp_http_client_set_header(esp_client_handle_, "Content-Type", "application/octet-stream");
            }
            if (ct_val) free(ct_val);
        } else if (method_enum == HttpMethod::kPost || method_enum == HttpMethod::kPut || method_enum == HttpMethod::kPatch) {
            char* cl_val = nullptr; char* te_val = nullptr;
            bool cl_present = (esp_http_client_get_header(esp_client_handle_, "Content-Length", &cl_val) == ESP_OK && cl_val != nullptr);
            bool te_present = (esp_http_client_get_header(esp_client_handle_, "Transfer-Encoding", &te_val) == ESP_OK && te_val != nullptr);
            if (cl_val) free(cl_val); if (te_val) free(te_val);
            if (!cl_present && !te_present) {
                ESP_LOGD(TAG_IMPL, "PerformRequestInternal: Auto-setting Content-Length: 0 for empty body on method %d.", static_cast<int>(method_enum));
                esp_http_client_set_header(esp_client_handle_, "Content-Length", "0");
            }
        }
        
        err_esp = esp_http_client_perform(esp_client_handle_);
        Status status = MapEspErrorToStatus(err_esp);

        if (response_info_user) {
            response_info_user->status_code = esp_http_client_get_status_code(esp_client_handle_);
            response_info_user->content_length = esp_http_client_get_content_length(esp_client_handle_);
            // response_info_user->connection_close is set by PlatformEventHandler
        }

        if (status == Status::kOk && response_info_user) {
            ESP_LOGI(TAG_IMPL, "PerformRequestInternal OK - HTTP Status: %d, Content-Length: %lld", response_info_user->status_code, response_info_user->content_length);
        } else if (status != Status::kOk) {
            int http_code = response_info_user ? response_info_user->status_code : esp_http_client_get_status_code(esp_client_handle_);
            ESP_LOGE(TAG_IMPL, "PerformRequestInternal failed: %s. HTTP Status (if available): %d", HttpsClient::StatusToString(status), http_code);
        }
        
        current_request_ctx_.response_info_ptr_user = nullptr; 
        current_request_ctx_.on_data_received_cb = nullptr;
        return status;
    }

    Status PerformStreamUploadInternal(std::string_view url, HttpMethod method_enum,
                                       const Headers& headers, size_t total_body_length,
                                       DataProviderCallback data_provider, ResponseInfo* response_info_user) {
        if (!esp_client_handle_) { ESP_LOGE(TAG_IMPL, "StreamUpload: Client not initialized."); return Status::kNotInitialized; }
        if (!data_provider) { ESP_LOGE(TAG_IMPL, "StreamUpload: Data provider is null."); return Status::kInvalidArgument; }
        if (tx_buffer_size_ == 0) { ESP_LOGE(TAG_IMPL, "StreamUpload: TX buffer size is 0."); return Status::kNotInitialized; }

        current_request_ctx_.response_info_ptr_user = response_info_user;
        // current_request_ctx_.on_data_received_cb is set by public PostStream/PutStream

        if (response_info_user) { *response_info_user = {}; }

        esp_err_t err_esp;
        std::array<char, HttpsClient::kMaxUrlLength> url_buffer;
        int len = snprintf(url_buffer.data(), url_buffer.size(), "%.*s", (int)url.length(), url.data());
        if (len < 0 || (size_t)len >= url_buffer.size()) { ESP_LOGE(TAG_IMPL, "StreamUpload: URL too long."); return Status::kBufferTooSmall; }

        esp_http_client_set_url(esp_client_handle_, url_buffer.data());
        esp_http_client_set_method(esp_client_handle_, MapHttpMethodToEsp(method_enum));

        bool cl_found = false;
        std::array<char, HttpsClient::kMaxHeaderKeyLen> header_key_buffer; // Renamed
        std::array<char, HttpsClient::kMaxHeaderValueLen> header_value_buffer; // Renamed
        for(const auto& h : headers){
            snprintf(header_key_buffer.data(),header_key_buffer.size(),"%.*s",(int)h.first.length(),h.first.data());
            snprintf(header_value_buffer.data(),header_value_buffer.size(),"%.*s",(int)h.second.length(),h.second.data());
            if (strnlen(header_key_buffer.data(), header_key_buffer.size()) >= header_key_buffer.size() - 1) { ESP_LOGW(TAG_IMPL, "StreamUpload: Header key truncated."); }
            if (strnlen(header_value_buffer.data(), header_value_buffer.size()) >= header_value_buffer.size() - 1) { ESP_LOGW(TAG_IMPL, "StreamUpload: Header value truncated."); }
            if(strcasecmp(header_key_buffer.data(),"Content-Length")==0) cl_found=true;
            esp_http_client_set_header(esp_client_handle_,header_key_buffer.data(),header_value_buffer.data());
        }
        if(!cl_found) { ESP_LOGE(TAG_IMPL, "StreamUpload: Content-Length header missing."); return Status::kInvalidArgument; }
        char* ct_val=nullptr; if(esp_http_client_get_header(esp_client_handle_,"Content-Type",&ct_val)!=ESP_OK||ct_val==nullptr){ ESP_LOGD(TAG_IMPL, "StreamUpload: Auto-setting Content-Type to application/octet-stream."); esp_http_client_set_header(esp_client_handle_,"Content-Type","application/octet-stream");} if(ct_val) free(ct_val);

        err_esp = esp_http_client_open(esp_client_handle_, total_body_length);
        if (err_esp != ESP_OK) {
            if(response_info_user) response_info_user->status_code = esp_http_client_get_status_code(esp_client_handle_);
            ESP_LOGE(TAG_IMPL, "StreamUpload: esp_http_client_open failed: %s", esp_err_to_name(err_esp));
            return MapEspErrorToStatus(err_esp);
        }
        
        std::vector<char> chunk_buffer;
        chunk_buffer.resize(tx_buffer_size_);
        if (chunk_buffer.capacity() < tx_buffer_size_ && tx_buffer_size_ > 0) {
            ESP_LOGE(TAG_IMPL, "StreamUpload: Chunk buffer vector allocation/resize failed (capacity %zu < requested %zu).", chunk_buffer.capacity(), tx_buffer_size_);
            esp_http_client_close(esp_client_handle_); 
            return Status::kNoMemory;
        }

        Status op_status = Status::kOk;
        size_t bytes_sent_total = 0;
        while (bytes_sent_total < total_body_length) {
            int bytes_in_chunk = data_provider(chunk_buffer.data(), chunk_buffer.size(), current_request_ctx_.user_context_from_config);
            if (bytes_in_chunk < 0) { ESP_LOGE(TAG_IMPL, "StreamUpload: data_provider error %d.", bytes_in_chunk); op_status = Status::kStreamError; break; }
            if (bytes_in_chunk == 0) { 
                if (bytes_sent_total < total_body_length) { ESP_LOGE(TAG_IMPL, "StreamUpload: data_provider EOF before all data sent (%zu/%zu).", bytes_sent_total, total_body_length); op_status = Status::kStreamError; }
                break; 
            }
            size_t current_chunk_size = static_cast<size_t>(bytes_in_chunk);
            if (current_chunk_size > chunk_buffer.size()) { ESP_LOGW(TAG_IMPL, "StreamUpload: Provider chunk %zu > buffer %zu, using buffer capacity.", current_chunk_size, chunk_buffer.size()); current_chunk_size = chunk_buffer.size(); }
            if (bytes_sent_total + current_chunk_size > total_body_length) { ESP_LOGW(TAG_IMPL, "StreamUpload: Provider chunk %zu + sent %zu > total %zu, clamping.", current_chunk_size, bytes_sent_total, total_body_length); current_chunk_size = total_body_length - bytes_sent_total; }
            if (current_chunk_size == 0) { if (bytes_sent_total < total_body_length) { ESP_LOGE(TAG_IMPL, "StreamUpload: Zero chunk write planned before completion."); op_status=Status::kStreamError;} break; }

            int written_bytes = esp_http_client_write(esp_client_handle_, chunk_buffer.data(), current_chunk_size);
            if (written_bytes < 0) { ESP_LOGE(TAG_IMPL, "StreamUpload: esp_http_client_write error %d (%s)", written_bytes, esp_err_to_name(static_cast<esp_err_t>(written_bytes))); op_status = MapEspErrorToStatus(static_cast<esp_err_t>(written_bytes)); break; }
            if (static_cast<size_t>(written_bytes) != current_chunk_size) { ESP_LOGW(TAG_IMPL, "StreamUpload: Partial write %d of %zu. Connection issue?", written_bytes, current_chunk_size); op_status = Status::kConnectionError; break; }
            bytes_sent_total += written_bytes;
            ESP_LOGD(TAG_IMPL, "StreamUpload: Sent chunk %d bytes, total %zu/%zu", written_bytes, bytes_sent_total, total_body_length);
        }

        if (op_status == Status::kOk && bytes_sent_total != total_body_length) {
            ESP_LOGE(TAG_IMPL, "StreamUpload: Data sent %zu bytes does not match Content-Length %zu.", bytes_sent_total, total_body_length);
            op_status = Status::kStreamError;
        }

        if (op_status == Status::kOk) { 
            long long response_len = esp_http_client_fetch_headers(esp_client_handle_);
            if (response_len < 0) { 
                op_status = MapEspErrorToStatus(static_cast<esp_err_t>(response_len));
                if(response_info_user) response_info_user->status_code = esp_http_client_get_status_code(esp_client_handle_); 
                ESP_LOGE(TAG_IMPL, "StreamUpload: fetch_headers failed: %s", HttpsClient::StatusToString(op_status));
            } else {
                if (response_info_user) {
                    response_info_user->status_code = esp_http_client_get_status_code(esp_client_handle_);
                    response_info_user->content_length = response_len;
                }
                ESP_LOGI(TAG_IMPL, "StreamUpload: Headers fetched. HTTP Status: %d, Response Content-Length: %lld",
                         response_info_user ? response_info_user->status_code : esp_http_client_get_status_code(esp_client_handle_), response_len);
            }
        }
        
        esp_http_client_close(esp_client_handle_); 
        current_request_ctx_.response_info_ptr_user = nullptr;
        current_request_ctx_.on_data_received_cb = nullptr;
        return op_status;
    }

    static esp_http_client_method_t MapHttpMethodToEsp(HttpMethod method) {
        switch (method) {
            case HttpMethod::kGet:   return HTTP_METHOD_GET;
            case HttpMethod::kPost:  return HTTP_METHOD_POST;
            case HttpMethod::kPut:   return HTTP_METHOD_PUT;
            case HttpMethod::kPatch: return HTTP_METHOD_PATCH;
            case HttpMethod::kHead:  return HTTP_METHOD_HEAD;
            default: 
                ESP_LOGW(TAG_IMPL, "MapHttpMethodToEsp: Unsupported HttpMethod: %d, defaulting to GET.", static_cast<int>(method));
                return HTTP_METHOD_GET;
        }
    }

    static Status MapEspErrorToStatus(esp_err_t err) {
        switch (err) {
            case ESP_OK: return Status::kOk;
            case ESP_ERR_INVALID_ARG: return Status::kInvalidArgument;
            case ESP_ERR_HTTP_INVALID_METHOD: return Status::kInvalidArgument;
            case ESP_ERR_HTTP_INVALID_HEADER: return Status::kInvalidArgument;
            case ESP_ERR_NO_MEM: return Status::kNoMemory;
            case ESP_ERR_TIMEOUT: return Status::kTimeout;
            case ESP_ERR_HTTP_CONNECT: return Status::kConnectionError;
            case ESP_ERR_HTTP_CONNECTING: return Status::kConnectionError;
            case ESP_ERR_ESP_TLS_FAILED_CONNECT: return Status::kConnectionError;
            case ESP_ERR_HTTP_SOCKET_ERR: return Status::kNetworkError;
            case ESP_FAIL: return Status::kFail;
            case ESP_ERR_ESP_TLS_HANDSHAKE: return Status::kTlsError;
            case ESP_ERR_ESP_TLS_PK_PARSE: return Status::kTlsError;
            case ESP_ERR_ESP_TLS_CA_CERT: return Status::kTlsError;
            case ESP_ERR_HTTP_PARSE: return Status::kHttpError;
            case ESP_ERR_HTTP_HEADERS: return Status::kHttpError;
            case ESP_ERR_HTTP_REDIRECT: return Status::kHttpError;
            default:
                ESP_LOGW(TAG_IMPL, "MapEspErrorToStatus: Unmapped esp_err_t: %d (%s)", err, esp_err_to_name(err));
                if (err > ESP_ERR_HTTP_BASE && err <= ESP_ERR_HTTP_MAX) return Status::kHttpError;
                if (err > ESP_ERR_ESP_TLS_BASE && err <= ESP_ERR_ESP_TLS_MAX) return Status::kTlsError;
                return Status::kFail;
        }
    }

    static esp_err_t PlatformEventHandler(esp_http_client_event_t *evt) {
        ImplRequestContext* req_ctx = static_cast<ImplRequestContext*>(evt->user_data);
        if (!req_ctx) { 
            ESP_LOGE(TAG_IMPL, "PlatformEventHandler: RequestContext (user_data) is null!");
            return ESP_FAIL;
        }

        // Note: Accessing evt->client internal struct fields directly (like client->response.status_code)
        // is done here for early update of ResponseInfo. This relies on ESP-IDF internal struct layout.
        // Official esp_http_client_get_status_code() / get_content_length() are for use after perform().
        esp_http_client_t* client_struct = static_cast<esp_http_client_t*>(evt->client);

        switch (evt->event_id) {
            case HTTP_EVENT_ERROR:
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_ERROR");
                if (req_ctx->response_info_ptr_user && client_struct) {
                     req_ctx->response_info_ptr_user->status_code = client_struct->response.status_code;
                }
                break;
            case HTTP_EVENT_ON_CONNECTED: // Occurs after connection, headers are being/have been processed
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_ON_CONNECTED");
                if (req_ctx->response_info_ptr_user && client_struct) {
                    req_ctx->response_info_ptr_user->status_code = client_struct->response.status_code;
                    req_ctx->response_info_ptr_user->content_length = client_struct->response.content_length;
                }
                break;
            case HTTP_EVENT_ON_HEADER:
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: ON_HEADER: %s: %s", evt->header_key, evt->header_value);
                if (req_ctx->response_info_ptr_user) {
                    if (client_struct) { 
                         req_ctx->response_info_ptr_user->status_code = client_struct->response.status_code;
                         req_ctx->response_info_ptr_user->content_length = client_struct->response.content_length;
                    }
                    if (strcasecmp(evt->header_key, "Connection") == 0 && strcasecmp(evt->header_value, "close") == 0) {
                        req_ctx->response_info_ptr_user->connection_close = true;
                    }
                }
                break;
            case HTTP_EVENT_ON_DATA:
                 ESP_LOGD(TAG_IMPL, "PlatformEventHandler: ON_DATA len=%d", evt->data_len);
                if (req_ctx->response_info_ptr_user && client_struct) { 
                    if (req_ctx->response_info_ptr_user->status_code == 0) req_ctx->response_info_ptr_user->status_code = client_struct->response.status_code;
                    if (req_ctx->response_info_ptr_user->content_length == -1) req_ctx->response_info_ptr_user->content_length = client_struct->response.content_length;
                }
                if (req_ctx->on_data_received_cb && evt->data_len > 0 && evt->data) {
                    Status cb_stat = req_ctx->on_data_received_cb( (const char*)evt->data, static_cast<size_t>(evt->data_len), req_ctx->user_context_from_config);
                    if (cb_stat != Status::kOk) { 
                        ESP_LOGE(TAG_IMPL, "PlatformEventHandler: Data callback error: %s", HttpsClient::StatusToString(cb_stat)); 
                        return ESP_FAIL; 
                    }
                } else if (evt->data_len > 0 && !req_ctx->on_data_received_cb) {
                     ESP_LOGD(TAG_IMPL, "PlatformEventHandler: Data (%d bytes) received but no on_data_received_cb set (e.g. for HEAD).", evt->data_len);
                }
                break;
            case HTTP_EVENT_ON_FINISH:
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_ON_FINISH");
                 if (req_ctx->response_info_ptr_user && client_struct) { 
                    req_ctx->response_info_ptr_user->status_code = client_struct->response.status_code;
                    req_ctx->response_info_ptr_user->content_length = client_struct->response.content_length;
                }
                break;
            case HTTP_EVENT_DISCONNECTED: 
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_DISCONNECTED"); 
                break;
            case HTTP_EVENT_REDIRECT: 
                ESP_LOGI(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_REDIRECT to %s. Auto-following by default.", esp_http_client_get_url(static_cast<esp_http_client_handle_t>(evt->client)));
                // esp_http_client will automatically follow redirects if not disabled in its configuration.
                // No need to call esp_http_client_set_redirection() here unless you want to alter default behavior.
                break;
            default: 
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: Unhandled Event ID: %d", evt->event_id); 
                break;
        }
        return ESP_OK;
    }
};

// --- HttpsClient Method Definitions (forwarding to PIMPL) ---
HttpsClient::HttpsClient() : impl_(std::make_unique<PlatformHttpClientImpl>()) {}

HttpsClient::~HttpsClient() = default; 

const char* HttpsClient::StatusToString(Status status) {
    switch (status) {
        case Status::kOk: return "Ok";
        case Status::kFail: return "Fail";
        case Status::kInvalidArgument: return "InvalidArgument";
        case Status::kNotInitialized: return "NotInitialized";
        case Status::kAlreadyInitialized: return "AlreadyInitialized";
        case Status::kNoMemory: return "NoMemory";
        case Status::kTimeout: return "Timeout";
        case Status::kNetworkError: return "NetworkError";
        case Status::kConnectionError: return "ConnectionError";
        case Status::kTlsError: return "TlsError";
        case Status::kHttpError: return "HttpError";
        case Status::kResponseError: return "ResponseError";
        case Status::kStreamError: return "StreamError";
        case Status::kBufferTooSmall: return "BufferTooSmall";
        case Status::kUnsupported: return "Unsupported";
        default: return "UnknownStatus";
    }
}

HttpsClient::Status HttpsClient::Open(const Config& config) {
    return impl_->Open(config);
}
HttpsClient::Status HttpsClient::Close() {
    return impl_->Close();
}
HttpsClient::Status HttpsClient::Head(std::string_view url, const Headers& headers, ResponseInfo* response_info) {
    if (!response_info) {
        // Logging at the public API level could be done here if a global/static logger was available
        // For now, just return the error status.
        return Status::kInvalidArgument;
    }
    impl_->current_request_ctx_.on_data_received_cb = nullptr; 
    return impl_->PerformRequestInternal(url, HttpMethod::kHead, headers, "", response_info);
}
HttpsClient::Status HttpsClient::Get(std::string_view url, const Headers& headers,
                                     DataReceivedCallback on_data_received, ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformRequestInternal(url, HttpMethod::kGet, headers, "", response_info);
}
HttpsClient::Status HttpsClient::Post(std::string_view url, const Headers& headers, std::string_view post_data,
                                      DataReceivedCallback on_data_received, ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformRequestInternal(url, HttpMethod::kPost, headers, post_data, response_info);
}
HttpsClient::Status HttpsClient::PostStream(std::string_view url, const Headers& headers, size_t total_body_length,
                                            DataProviderCallback data_provider, DataReceivedCallback on_data_received,
                                            ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformStreamUploadInternal(url, HttpMethod::kPost, headers, total_body_length, data_provider, response_info);
}
HttpsClient::Status HttpsClient::Put(std::string_view url, const Headers& headers, std::string_view put_data,
                                     DataReceivedCallback on_data_received, ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformRequestInternal(url, HttpMethod::kPut, headers, put_data, response_info);
}
HttpsClient::Status HttpsClient::PutStream(std::string_view url, const Headers& headers, size_t total_body_length,
                                           DataProviderCallback data_provider, DataReceivedCallback on_data_received,
                                           ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformStreamUploadInternal(url, HttpMethod::kPut, headers, total_body_length, data_provider, response_info);
}
HttpsClient::Status HttpsClient::Patch(std::string_view url, const Headers& headers, std::string_view patch_data,
                                       DataReceivedCallback on_data_received, ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformRequestInternal(url, HttpMethod::kPatch, headers, patch_data, response_info);
}
-----------------------------------------------------------------------------------------------------------

/**
 * @file app_main_pimpl_example.cpp
 * @brief Example usage of HttpsClient (PIMPL version) as a member of another class.
 * @author Gemini
 * @date 2025-05-27 Current time is Tuesday, May 27, 2025 at 2:33:12 PM IST.
 */
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"

#include "https_client.h" // Public HttpsClient interface (PIMPL version)

#include <string>
#include <vector>
#include <memory> // For std::make_unique if creating HttpsClient on heap

static const char* kMainAppTag = "HTTP_PIMPL_EXAMPLE";

// Example Root CA certificate for httpbin.org (DigiCert Global Root CA)
const char* HTTPBIN_ORG_ROOT_CA_PEM_PIMPL = \
"-----BEGIN CERTIFICATE-----\n" \
"MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh\n" \
"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" \
"d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\n" \
"QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT\n" \
"MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\n" \
"b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG\n" \
"9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhQbg0ef3p4HjF59iARFtLSr5oX2uaRpHm\n" \
"sHlwxLk/瘢truncated_for_brevity陟/LoUWOEFFnoBazbfKijwNRL34j0VEWWPId2\n" \
"ZAD95Yc//CN4zrf0M7PTDEu05KQS5bE2VzGc5r0uHgsJ9RUW02N1EutF81My1G8G\n" \
"0h0jLs7N50Py1G/hV18orjS57AmDk2N4AfsS7NRkQ6GKUnLNQLV47F6S9IFIPM/S\n" \
"2FpLuAXrRAhRkBzQE3KOzv/3u2/FP0SA0mmlhBgCV7SM2adWFLw23EY/CUDp2nRN\n" \
"k3sBDYWA8l5P7L9hSPSfl574p2sHZ7lI2zC2gV846e5EZ6FQxwIDAQABo2MwYTAO\n" \
"BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR\n" \
"TLtm8KPiGxv2c7hCs+gwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxv2c7hCs+gw\n" \
"DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr\n" \
"hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg\n" \
"06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF\n" \
"PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\n" \
"YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk\n" \
"CAUw7C29C79Fv1C5qfPrmAESrciAqZynZeUS7_HBIYB7ELI=\n" \
"-----END CERTIFICATE-----\n";

// Callback for collecting response body data into a std::string
HttpsClient::Status OnDataReceivedCollectPimpl(const char* data, size_t len, void* user_context) {
    std::string* response_buffer = static_cast<std::string*>(user_context);
    if (!response_buffer) {
        ESP_LOGE(kMainAppTag, "OnDataReceivedCollectPimpl: user_context (string buffer) is null!");
        return HttpsClient::Status::kFail;
    }
    try {
        response_buffer->append(data, len);
    } catch (const std::bad_alloc&) {
        ESP_LOGE(kMainAppTag, "OnDataReceivedCollectPimpl: std::bad_alloc appending data");
        return HttpsClient::Status::kNoMemory;
    }
    ESP_LOGD(kMainAppTag, "Collected %zu bytes, total response body size now %zu", len, response_buffer->length());
    return HttpsClient::Status::kOk;
}


class MyWebServiceManager {
public:
    MyWebServiceManager() {
        client_config_.buffer_size_rx_bytes = 4096;
        client_config_.buffer_size_tx_bytes = 2048;
        client_config_.verify_server = true; 
        client_config_.server_cert_pem = HTTPBIN_ORG_ROOT_CA_PEM_PIMPL; 
        client_config_.timeout_ms = 15000; 
        ESP_LOGI(kMainAppTag, "MyWebServiceManager initialized.");

        // Open the client during manager construction
        HttpsClient::Status open_status = http_client_instance_.Open(client_config_);
        if (open_status != HttpsClient::Status::kOk) {
            ESP_LOGE(kMainAppTag, "MyWebServiceManager: Failed to open HttpsClient: %s",
                     HttpsClient::StatusToString(open_status));
            // Set a flag or handle the error appropriately for the manager's state
            is_client_open_ = false;
        } else {
            is_client_open_ = true;
        }
    }

    ~MyWebServiceManager() {
        if (is_client_open_) {
            http_client_instance_.Close();
        }
        ESP_LOGI(kMainAppTag, "MyWebServiceManager destroyed.");
    }

    bool GetResourceSize(std::string_view resource_url, long long& out_resource_size) {
        if (!is_client_open_) {
            ESP_LOGE(kMainAppTag, "GetResourceSize: Client not open. Attempting to re-open.");
            // Optionally, try to Open it here if it makes sense for your application
            if (http_client_instance_.Open(client_config_) != HttpsClient::Status::kOk) {
                 ESP_LOGE(kMainAppTag, "GetResourceSize: Failed to re-open client.");
                 return false;
            }
            is_client_open_ = true; // Update state
        }

        ESP_LOGI(kMainAppTag, "MyWebServiceManager: Getting size for URL: %.*s", (int)resource_url.length(), resource_url.data());

        HttpsClient::ResponseInfo response_details = {}; // Use HttpsClient::ResponseInfo
        HttpsClient::Headers headers = { {"User-Agent", "MyWebServiceManagerApp/1.0-PIMPL"} };

        HttpsClient::Status status = http_client_instance_.Head(resource_url, headers, &response_details);

        if (status == HttpsClient::Status::kOk) {
            ESP_LOGI(kMainAppTag, "MyWebServiceManager: HEAD request HTTP Status: %d", response_details.status_code);
            if (response_details.status_code == 200) {
                if (response_details.content_length >= 0) {
                    out_resource_size = response_details.content_length;
                    ESP_LOGI(kMainAppTag, "MyWebServiceManager: Resource size: %lld bytes.", out_resource_size);
                    return true;
                } else {
                    ESP_LOGW(kMainAppTag, "MyWebServiceManager: HTTP 200, but Content-Length not found/invalid in HEAD response.");
                }
            } else {
                ESP_LOGW(kMainAppTag, "MyWebServiceManager: HEAD request returned non-200 status: %d", response_details.status_code);
            }
        } else {
            ESP_LOGE(kMainAppTag, "MyWebServiceManager: HEAD request failed: %s (HTTP Status from ResponseInfo: %d)",
                     HttpsClient::StatusToString(status), response_details.status_code);
        }
        return false;
    }

    bool GetResourceContent(std::string_view resource_url, std::string& out_body) {
        if (!is_client_open_) {
            ESP_LOGE(kMainAppTag, "GetResourceContent: Client not open. Attempting to re-open.");
             if (http_client_instance_.Open(client_config_) != HttpsClient::Status::kOk) {
                 ESP_LOGE(kMainAppTag, "GetResourceContent: Failed to re-open client.");
                 return false;
            }
            is_client_open_ = true;
        }
        out_body.clear(); 
        ESP_LOGI(kMainAppTag, "MyWebServiceManager: Getting content for URL: %.*s", (int)resource_url.length(), resource_url.data());
        
        HttpsClient::ResponseInfo response_details = {};
        HttpsClient::Headers headers = { {"User-Agent", "MyWebServiceManagerApp/1.0-PIMPL"} };
        
        // The callback needs a way to access 'out_body'. Lambdas are great for this.
        // The 'user_context' parameter in DataReceivedCallback will be what was set
        // in HttpsClient::Config::user_context when Open() was called.
        // Here, we use a lambda to capture 'out_body' by reference.
        client_config_.user_context = &out_body; // Set user context for this specific call if needed by a global callback
                                                 // However, the lambda approach below is cleaner for per-call context.

        HttpsClient::Status status = http_client_instance_.Get(resource_url, headers,
            // Lambda captures 'out_body' by reference.
            // The 'user_ctx_from_config' is what was in config.user_context at Open().
            [&out_body](const char* data, size_t len, void* user_ctx_from_config) {
                return OnDataReceivedCollectPimpl(data, len, &out_body);
            },
            &response_details
        );

        if (status == HttpsClient::Status::kOk && response_details.status_code == 200) {
            ESP_LOGI(kMainAppTag, "MyWebServiceManager: GET successful. Received %lld bytes, collected %zu bytes.", 
                     response_details.content_length, out_body.length());
            return true;
        } else {
            ESP_LOGE(kMainAppTag, "MyWebServiceManager: GET failed. Status: %s, HTTP Code: %d",
                     HttpsClient::StatusToString(status), response_details.status_code);
        }
        return false;
    }

private:
    HttpsClient http_client_instance_; // HttpsClient (PIMPL version) as a direct member
    HttpsClient::Config client_config_;
    bool is_client_open_ = false;
};


extern "C" void app_main(void) {
    ESP_LOGI(kMainAppTag, "Starting PIMPL HTTPS Client Member Example");

    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    ESP_LOGI(kMainAppTag, "Example: Simulating WiFi connected...");
    vTaskDelay(pdMS_TO_TICKS(2000)); // Adjust as needed for your WiFi setup

    MyWebServiceManager web_manager; // Create an instance of our class that owns the HttpsClient

    // Test HEAD request for content length using httpbin.org
    const char* test_url_head = "https://httpbin.org/bytes/512"; // httpbin generates 512 random bytes
    long long object_size = -1;

    if (web_manager.GetResourceSize(test_url_head, object_size)) {
        ESP_LOGI(kMainAppTag, "Main: Successfully obtained object size for %s: %lld bytes", test_url_head, object_size);
        
        // Now try to GET the content if size is known
        if (object_size > 0) { // httpbin.org/bytes/N should have Content-Length N
            std::string content_body;
            ESP_LOGI(kMainAppTag, "Main: Attempting to download content for %s", test_url_head);
            if (web_manager.GetResourceContent(test_url_head, content_body)) {
                ESP_LOGI(kMainAppTag, "Main: Successfully downloaded content. Actual received size: %zu bytes.", content_body.length());
                // ESP_LOGI(kMainAppTag, "Main: Content (first 100 bytes): %.*s", 100, content_body.c_str()); // Be careful printing binary data
            } else {
                ESP_LOGE(kMainAppTag, "Main: Failed to download content for %s", test_url_head);
            }
        }
    } else {
        ESP_LOGE(kMainAppTag, "Main: Failed to obtain object size for %s.", test_url_head);
    }

    ESP_LOGI(kMainAppTag, "PIMPL Example finished.");
}
