/**
 * @file https_client.h
 * @brief Defines the HttpsClient class for HTTPS communication using the PIMPL idiom.
 * The public interface is platform-agnostic; implementation details are hidden.
 * @author Gemini
 * @date 2025-05-27 Current time is Tuesday, May 27, 2025 at 12:43:46 PM IST.
 */
#ifndef HTTPS_CLIENT_H
#define HTTPS_CLIENT_H

#include <functional>
#include <string_view>
#include <map>
#include <memory>  // For std::unique_ptr
#include <cstddef> // For size_t
#include <cstdint> // For uint8_t etc.

/**
 * @class HttpsClient
 * @brief Provides a C++ PIMPL-based wrapper for HTTPS communication.
 *
 * This class offers a simplified interface for performing common HTTPS requests
 * like GET, POST, HEAD, etc. It uses the PIMPL (Pointer to Implementation)
 * idiom to hide platform-specific details (e.g., ESP-IDF's esp_http_client)
 * from the user, ensuring a clean header and reduced compilation dependencies.
 *
 * All network operations are blocking. For non-blocking behavior, instantiate
 * and use this client from a dedicated thread or task.
 */
class HttpsClient {
public:
    // --- Public Nested Types and Constants ---

    /**
     * @brief Maximum supported length for a full URL passed to request methods.
     * Implementations use this to size internal buffers for URLs.
     */
    static constexpr size_t kMaxUrlLength = 2048;

    /**
     * @brief Maximum supported length for an HTTP header key name.
     * Used by implementations for internal buffers when processing header keys.
     */
    static constexpr size_t kMaxHeaderKeyLen = 64;

    /**
     * @brief Maximum supported length for an HTTP header value.
     * Used by implementations for internal buffers when processing header values.
     */
    static constexpr size_t kMaxHeaderValueLen = 512;

    /**
     * @brief Status codes returned by HttpsClient methods and callbacks.
     */
    enum class Status {
        kOk = 0,             ///< Operation successful.
        kFail,               ///< Generic failure.
        kInvalidArgument,    ///< Invalid argument provided to an HttpsClient method.
        kNotInitialized,     ///< Client is not initialized (Open not called or failed/closed).
        kAlreadyInitialized, ///< Open() called when client is already open.
        kNoMemory,           ///< Memory allocation failed internally or in underlying libraries.
        kTimeout,            ///< Operation timed out.
        kNetworkError,       ///< Lower-level network error (DNS, TCP, socket, etc.).
        kConnectionError,    ///< Failed to establish connection or connection was lost.
        kTlsError,           ///< TLS handshake or encryption/decryption error.
        kHttpError,          ///< HTTP protocol error (e.g., parsing, malformed response).
        kResponseError,      ///< Error indicated by HTTP status code (e.g., 4xx, 5xx). Note: method might still return kOk if transport succeeded.
        kStreamError,        ///< Error during request or response streaming (e.g., callback error, unexpected EOF).
        kBufferTooSmall,     ///< A provided buffer or an internal limit (like kMaxUrlLength) was too small.
        kUnsupported         ///< The requested feature or operation is not supported by the implementation.
    };

    /**
     * @brief Standard HTTP methods supported by the client.
     */
    enum class HttpMethod {
        kGet,   ///< HTTP GET method.
        kPost,  ///< HTTP POST method.
        kPut,   ///< HTTP PUT method.
        kPatch, ///< HTTP PATCH method.
        kHead   ///< HTTP HEAD method.
    };

    /**
     * @brief Converts an HttpsClient::Status enum value to a descriptive string literal.
     * Useful for logging and debugging.
     * @param status The status code to convert.
     * @return A null-terminated string describing the status. Never returns null.
     */
    static const char* StatusToString(Status status);

    /**
     * @brief Callback function type for receiving response body data in chunks.
     * @param data Pointer to the data chunk received. This pointer is only valid for the duration of the callback. Not null-terminated.
     * @param len Length of the data chunk in bytes.
     * @param user_context User-provided context pointer (from Config::user_context at the time of Open).
     * @return HttpsClient::Status Should return HttpsClient::Status::kOk on success.
     * Returning any other status will signal an error to the client and attempt to abort the request.
     */
    using DataReceivedCallback =
        std::function<Status(const char* data, size_t len, void* user_context)>;

    /**
     * @brief Callback function type for providing request body data in chunks for streaming uploads.
     * @param buffer Buffer to write the chunk data into.
     * @param max_len Maximum number of bytes that can be written into the buffer (typically equals the configured TX buffer size).
     * @param user_context User-provided context pointer (from Config::user_context at the time of Open).
     * @return int The number of bytes written into the buffer (must be <= max_len).
     * Return 0 to indicate the end of data (EOF). All data specified by Content-Length must have been sent.
     * Return a negative value to indicate an error condition, which will abort the upload.
     */
    using DataProviderCallback =
        std::function<int(char* buffer, size_t max_len, void* user_context)>;

    /**
     * @brief Configuration structure used when calling Open().
     * Contains settings for the HTTPS client instance.
     */
    struct Config {
        /** @brief RX buffer size for the underlying HTTP implementation. Affects max chunk size for received data/headers. Must be > 0. */
        size_t buffer_size_rx_bytes = 4096;
        /** @brief TX buffer size for the underlying HTTP implementation. Affects stream upload chunk buffer size. Must be > 0. */
        size_t buffer_size_tx_bytes = 4096;
        /** @brief Set to true to enable server certificate verification (recommended for production). */
        bool verify_server = true;
        /** @brief Pointer to the server's root CA certificate(s) in PEM format. Required if verify_server is true and not relying on a system trust store/bundle. String must persist for the lifetime of the client or until Close(). */
        const char* server_cert_pem = nullptr;
        /** @brief Overall timeout for connection and request processing, in milliseconds. */
        int timeout_ms = 10000;
        /** @brief TCP Keep-Alive: Idle time in seconds before sending keep-alive probes. */
        int keep_alive_idle_sec = 5;
        /** @brief TCP Keep-Alive: Interval in seconds between keep-alive probes. */
        int keep_alive_interval_sec = 5;
        /** @brief TCP Keep-Alive: Number of probes to send before timing out. */
        int keep_alive_count = 3;
        /** @brief Optional user context pointer passed unmodified to all callbacks (DataReceivedCallback, DataProviderCallback). This context is set during Open(). */
        void* user_context = nullptr;
    };

    /**
     * @brief Structure to hold response information obtained after an HTTP request.
     */
    struct ResponseInfo {
        /** @brief HTTP status code returned by the server (e.g., 200, 404). */
        int status_code = 0;
        /** @brief Content-Length value from the response headers. Is -1 if not present (e.g., chunked encoding or HEAD request with no Content-Length). */
        long long content_length = -1;
        /** @brief Flag indicating if the server sent a 'Connection: close' header. */
        bool connection_close = false;
    };

    /** @brief Type alias for HTTP request headers, represented as a map of string views.
     * The string views must point to valid memory for the duration of the request call.
     */
    using Headers = std::map<std::string_view, std::string_view>;

    // --- Constructor and Destructor ---
    /**
     * @brief Constructs an HttpsClient instance.
     * The client is not yet ready for requests until Open() is called.
     */
    HttpsClient();
    /**
     * @brief Destroys the HttpsClient instance.
     * Automatically calls Close() to release any underlying resources if the client was open.
     * @note The definition is in the .cpp file to allow `std::unique_ptr<PlatformHttpClientImpl>` to see the full definition of `PlatformHttpClientImpl`.
     */
    ~HttpsClient();

    // --- Rule of Five/Six: Non-Copyable and Non-Movable ---
    // PIMPL often makes copying/moving complex if not handled by smart pointers correctly.
    // For this client, let's make it non-copyable and non-movable for simplicity.
    // If move semantics are needed, they would require careful implementation of the PIMPL's ownership.
    HttpsClient(const HttpsClient&) = delete;
    HttpsClient& operator=(const HttpsClient&) = delete;
    HttpsClient(HttpsClient&&) = delete;
    HttpsClient& operator=(HttpsClient&&) = delete;

    // --- Public API Methods ---

    /**
     * @brief Initializes the client and underlying resources based on the provided configuration.
     * This method is BLOCKING.
     * @param config Configuration settings for this client instance.
     * @return Status::kOk on success, or an appropriate error status otherwise.
     */
    Status Open(const Config& config);

    /**
     * @brief Closes any open connection and releases all associated underlying resources.
     * This method can be BLOCKING, depending on the underlying implementation's cleanup process.
     * It is safe to call Close() even if the client is already closed or was never opened.
     * @return Status::kOk on successful closure (or if already closed), or an error status on cleanup failure.
     */
    Status Close();

    /**
     * @brief Performs an HTTP HEAD request to the specified URL.
     * This retrieves only the headers from the server, not the message body.
     * This method is BLOCKING.
     * @param url The full URL for the request (e.g., "https://example.com/resource"). Must be <= HttpsClient::kMaxUrlLength.
     * @param headers A map of additional request headers to send. Keys/values should adhere to kMaxHeaderKeyLen/ValueLen.
     * @param response_info Pointer to a ResponseInfo struct where response details (status code, content length, etc.) will be stored. This argument cannot be nullptr for HEAD.
     * @return Status::kOk if the request cycle completed successfully at the transport/protocol level.
     * Check `response_info->status_code` for the actual HTTP success (e.g., 200).
     * Returns other status codes on failure (e.g., network error, timeout).
     */
    Status Head(std::string_view url, const Headers& headers, ResponseInfo* response_info);

    /**
     * @brief Performs an HTTP GET request to the specified URL.
     * This method is BLOCKING.
     * @param url The full URL for the request. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers A map of additional request headers.
     * @param on_data_received Callback function to handle incoming response body data chunks. Can be nullptr if the body is to be ignored (though some data might still be buffered internally).
     * @param response_info Optional pointer to a ResponseInfo struct to store response details.
     * @return Status::kOk if the request cycle completed successfully at the transport/protocol level.
     * Check `response_info->status_code` (if provided) for HTTP success.
     */
    Status Get(std::string_view url, const Headers& headers,
               DataReceivedCallback on_data_received,
               ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP POST request with a non-streaming (full buffer) body.
     * This method is BLOCKING.
     * @param url The full URL for the request. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers A map of additional request headers (e.g., "Content-Type").
     * @param post_data The entire request body data as a string view.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to a ResponseInfo struct.
     * @return Status::kOk if the request cycle completed successfully. Check `response_info->status_code`.
     */
    Status Post(std::string_view url, const Headers& headers,
                std::string_view post_data,
                DataReceivedCallback on_data_received,
                ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP POST request with a streaming request body.
     * This method is BLOCKING for the duration of the stream.
     * @param url The full URL for the request. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers A map of additional request headers. MUST include "Content-Length" matching `total_body_length`.
     * @param total_body_length The total size in bytes of the request body to be streamed.
     * @param data_provider Callback function to provide request body data in chunks. Must not be nullptr.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to a ResponseInfo struct.
     * @return Status::kOk if the request/response cycle completed successfully. Check `response_info->status_code`.
     */
    Status PostStream(std::string_view url, const Headers& headers,
                      size_t total_body_length,
                      DataProviderCallback data_provider,
                      DataReceivedCallback on_data_received,
                      ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP PUT request with a non-streaming (full buffer) body.
     * This method is BLOCKING.
     * @param url The full URL for the request. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers A map of additional request headers.
     * @param put_data The entire request body data.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to a ResponseInfo struct.
     * @return Status::kOk if the request cycle completed successfully. Check `response_info->status_code`.
     */
    Status Put(std::string_view url, const Headers& headers,
               std::string_view put_data,
               DataReceivedCallback on_data_received,
               ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP PUT request with a streaming request body.
     * This method is BLOCKING for the duration of the stream.
     * @param url The full URL for the request. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers A map of additional request headers. MUST include "Content-Length".
     * @param total_body_length The total size in bytes of the request body.
     * @param data_provider Callback function to provide request body chunks. Must not be nullptr.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to a ResponseInfo struct.
     * @return Status::kOk if the request/response cycle completed successfully. Check `response_info->status_code`.
     */
    Status PutStream(std::string_view url, const Headers& headers,
                     size_t total_body_length,
                     DataProviderCallback data_provider,
                     DataReceivedCallback on_data_received,
                     ResponseInfo* response_info = nullptr);

    /**
     * @brief Performs an HTTP PATCH request with a non-streaming (full buffer) body.
     * This method is BLOCKING.
     * @param url The full URL for the request. Must be <= HttpsClient::kMaxUrlLength.
     * @param headers A map of additional request headers.
     * @param patch_data The entire request body data.
     * @param on_data_received Callback for response body chunks. Can be nullptr.
     * @param response_info Optional pointer to a ResponseInfo struct.
     * @return Status::kOk if the request cycle completed successfully. Check `response_info->status_code`.
     */
    Status Patch(std::string_view url, const Headers& headers,
                 std::string_view patch_data,
                 DataReceivedCallback on_data_received,
                 ResponseInfo* response_info = nullptr);

private:
    /**
     * @class PlatformHttpClientImpl
     * @brief Forward declaration for the PIMPL pattern.
     * The actual definition of this class is hidden in the .cpp file
     * and contains platform-specific implementation details.
     */
    class PlatformHttpClientImpl;
    /**
     * @brief Unique pointer to the opaque implementation object.
     */
    std::unique_ptr<PlatformHttpClientImpl> impl_;
};

#endif // HTTPS_CLIENT_H

------------------------------------------------------------------------------------

  /**
 * @file https_client.cpp
 * @brief Implements the HttpsClient class using the PIMPL idiom.
 * The HttpsClient::PlatformHttpClientImpl class encapsulates ESP-IDF specific details.
 * @author Gemini
 * @date 2025-05-26 Current time is Monday, May 26, 2025 at 6:42:39 AM IST.
 */
#include "https_client.h" // Public interface

#include <cstring> // For memcpy, strlen, strcasecmp
#include <cstdio>  // For snprintf
#include <array>   // For stack arrays for headers/URL
#include <vector>  // For temporary chunk buffer (heap allocated)

// --- ESP-IDF Specific Includes (Hidden from header) ---
#include "esp_http_client.h"
#include "esp_log.h"
#include "esp_err.h"

// Define ESP32_PLATFORM or use CONFIG_ESP_TLS_CRT_BUNDLE_ATTACH from sdkconfig
// For this example, let's assume ESP32 context.
#ifndef ESP32_PLATFORM
#define ESP32_PLATFORM
#endif

#ifdef ESP32_PLATFORM
#include "esp_crt_bundle.h"
#endif
#include "errno.h"

// Logging Tag for the implementation
static const char* TAG_IMPL = "HttpsClientImpl";

// --- HttpsClient::PlatformHttpClientImpl Definition ---
class HttpsClient::PlatformHttpClientImpl {
public:
    // --- Types needed by Impl (can alias from HttpsClient or be direct) ---
    using Status = HttpsClient::Status;
    using HttpMethod = HttpsClient::HttpMethod;
    using Config = HttpsClient::Config;
    using ResponseInfo = HttpsClient::ResponseInfo;
    using Headers = HttpsClient::Headers;
    using DataReceivedCallback = HttpsClient::DataReceivedCallback;
    using DataProviderCallback = HttpsClient::DataProviderCallback;

    // Context for ESP-IDF event handler
    struct RequestContext {
        DataReceivedCallback on_data_received_cb = nullptr;
        void* user_context_from_config = nullptr; // From HttpsClient::Config
        ResponseInfo* response_info_ptr_user = nullptr;   // Points to user's ResponseInfo
    };

    esp_http_client_handle_t esp_client_handle_ = nullptr;
    RequestContext current_request_ctx_;
    size_t tx_buffer_size_ = 0;
    // Config current_config_; // Store a copy of the config used at Open() if needed across calls after Open

    PlatformHttpClientImpl() = default;

    ~PlatformHttpClientImpl() {
        if (esp_client_handle_) {
            Close(); // Ensure cleanup
        }
    }

    Status Open(const Config& config) {
        if (esp_client_handle_) { ESP_LOGW(TAG_IMPL, "PlatformHttpClientImpl::Open: Already open."); return Status::kAlreadyInitialized; }
        if (config.buffer_size_rx_bytes == 0 || config.buffer_size_tx_bytes == 0) {
            ESP_LOGE(TAG_IMPL, "PlatformHttpClientImpl::Open: Buffer sizes must be non-zero.");
            return Status::kInvalidArgument;
        }

        // current_config_ = config; // Store if needed for other methods that don't receive it
        tx_buffer_size_ = config.buffer_size_tx_bytes;

        esp_http_client_config_t esp_config = {};
        esp_config.url = "http://dummy.invalid"; // Placeholder, actual URL set per request
        esp_config.buffer_size = config.buffer_size_rx_bytes;
        esp_config.buffer_size_tx = config.buffer_size_tx_bytes;
        esp_config.timeout_ms = config.timeout_ms;
        esp_config.keep_alive_enable = true;
        esp_config.keep_alive_idle = config.keep_alive_idle_sec;
        esp_config.keep_alive_interval = config.keep_alive_interval_sec;
        esp_config.keep_alive_count = config.keep_alive_count;

        current_request_ctx_ = {}; // Reset context for Open
        current_request_ctx_.user_context_from_config = config.user_context;
        esp_config.user_data = &current_request_ctx_;
        esp_config.event_handler = PlatformHttpClientImpl::PlatformEventHandler; // Static member

        if (config.verify_server) {
            esp_config.cert_pem = config.server_cert_pem;
            esp_config.skip_cert_common_name_check = false;
            #if defined(ESP32_PLATFORM) && ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4,0,0) // Check IDF version for crt_bundle_attach
                #ifdef CONFIG_ESP_TLS_CRT_BUNDLE_ATTACH
                    esp_config.crt_bundle_attach = esp_crt_bundle_attach;
                #else
                    if (!config.server_cert_pem) {
                        ESP_LOGE(TAG_IMPL, "Open: Server verification ON, but no server_cert_pem and CRT bundle N/A.");
                        return Status::kInvalidArgument;
                    }
                #endif
            #else // Older IDF or non-ESP32 where bundle might not be available/used this way
                 if (!config.server_cert_pem) {
                    ESP_LOGE(TAG_IMPL, "Open: Server verification ON, but no server_cert_pem provided.");
                    return Status::kInvalidArgument;
                 }
            #endif
        } else {
            ESP_LOGW(TAG_IMPL, "PlatformHttpClientImpl::Open: Server certificate verification is DISABLED.");
            esp_config.cert_pem = nullptr;
            esp_config.skip_cert_common_name_check = true;
        }

        esp_client_handle_ = esp_http_client_init(&esp_config);
        if (!esp_client_handle_) {
            ESP_LOGE(TAG_IMPL, "PlatformHttpClientImpl::Open: esp_http_client_init failed.");
            tx_buffer_size_ = 0;
            return Status::kFail;
        }
        ESP_LOGI(TAG_IMPL, "PlatformHttpClientImpl opened successfully.");
        return Status::kOk;
    }

    Status Close() {
        esp_err_t err = ESP_OK;
        if (esp_client_handle_) {
            err = esp_http_client_cleanup(esp_client_handle_);
            esp_client_handle_ = nullptr;
            tx_buffer_size_ = 0;
            if (err != ESP_OK) {
                ESP_LOGE(TAG_IMPL, "PlatformHttpClientImpl::Close: esp_http_client_cleanup failed: %s", esp_err_to_name(err));
            }
        } else {
            ESP_LOGD(TAG_IMPL, "PlatformHttpClientImpl::Close: Client already closed or never opened.");
        }
        // Reset context for safety, though it's mostly set per-request
        current_request_ctx_ = {};
        ESP_LOGI(TAG_IMPL, "PlatformHttpClientImpl closed.");
        return MapEspErrorToStatus(err);
    }

    Status PerformRequestInternal(std::string_view url, HttpMethod method_enum,
                                  const Headers& headers, std::string_view request_body,
                                  ResponseInfo* response_info_user) {
        if (!esp_client_handle_) {
            ESP_LOGE(TAG_IMPL, "PerformRequestInternal: Client not initialized.");
            return Status::kNotInitialized;
        }

        // current_request_ctx_.on_data_received_cb is set by the public Get/Post methods
        current_request_ctx_.response_info_ptr_user = response_info_user;

        if (response_info_user) {
            // Reset user's ResponseInfo for this new request
            response_info_user->status_code = 0;
            response_info_user->content_length = -1;
            response_info_user->connection_close = false;
        }

        esp_err_t err;
        std::array<char, HttpsClient::kMaxUrlLength> url_buffer;
        int len = snprintf(url_buffer.data(), url_buffer.size(), "%.*s", (int)url.length(), url.data());
        if (len < 0 || static_cast<size_t>(len) >= url_buffer.size()) {
            ESP_LOGE(TAG_IMPL, "URL '%.*s' (len %zu) exceeds max length %zu.", (int)url.length(), url.data(), url.length(), HttpsClient::kMaxUrlLength - 1);
            return Status::kBufferTooSmall;
        }

        err = esp_http_client_set_url(esp_client_handle_, url_buffer.data());
        if (err != ESP_OK) { ESP_LOGE(TAG_IMPL, "set_url failed: %s", esp_err_to_name(err)); return MapEspErrorToStatus(err); }

        err = esp_http_client_set_method(esp_client_handle_, MapHttpMethodToEsp(method_enum));
        if (err != ESP_OK) { ESP_LOGE(TAG_IMPL, "set_method failed: %s", esp_err_to_name(err)); return MapEspErrorToStatus(err); }

        std::array<char, HttpsClient::kMaxHeaderKeyLen> hk_buf;
        std::array<char, HttpsClient::kMaxHeaderValueLen> hv_buf;
        for (const auto& h : headers) {
            snprintf(hk_buf.data(), hk_buf.size(), "%.*s", (int)h.first.length(), h.first.data());
            snprintf(hv_buf.data(), hv_buf.size(), "%.*s", (int)h.second.length(), h.second.data());
            if (strnlen(hk_buf.data(), hk_buf.size()) >= hk_buf.size() - 1) { ESP_LOGW(TAG_IMPL, "Header key truncated: %.*s", (int)h.first.length(), h.first.data()); }
            if (strnlen(hv_buf.data(), hv_buf.size()) >= hv_buf.size() - 1) { ESP_LOGW(TAG_IMPL, "Header value for '%.*s' truncated.", (int)h.first.length(), h.first.data()); }
            err = esp_http_client_set_header(esp_client_handle_, hk_buf.data(), hv_buf.data());
            if (err != ESP_OK) { ESP_LOGE(TAG_IMPL, "set_header '%s' failed: %s", hk_buf.data(), esp_err_to_name(err)); return MapEspErrorToStatus(err); }
        }

        if (!request_body.empty()) {
            err = esp_http_client_set_post_field(esp_client_handle_, request_body.data(), request_body.length());
            if (err != ESP_OK) { ESP_LOGE(TAG_IMPL, "set_post_field failed: %s", esp_err_to_name(err)); return MapEspErrorToStatus(err); }
            char* ct_val = nullptr;
            if (esp_http_client_get_header(esp_client_handle_, "Content-Type", &ct_val) != ESP_OK || ct_val == nullptr) {
                ESP_LOGD(TAG_IMPL, "Auto-setting Content-Type to application/octet-stream for non-empty body.");
                esp_http_client_set_header(esp_client_handle_, "Content-Type", "application/octet-stream");
            }
            if (ct_val) free(ct_val);
        } else if (method_enum == HttpMethod::kPost || method_enum == HttpMethod::kPut || method_enum == HttpMethod::kPatch) {
            char* cl_val = nullptr; char* te_val = nullptr;
            bool cl_present = (esp_http_client_get_header(esp_client_handle_, "Content-Length", &cl_val) == ESP_OK && cl_val != nullptr);
            bool te_present = (esp_http_client_get_header(esp_client_handle_, "Transfer-Encoding", &te_val) == ESP_OK && te_val != nullptr);
            if (cl_val) free(cl_val); if (te_val) free(te_val);
            if (!cl_present && !te_present) {
                ESP_LOGD(TAG_IMPL, "Auto-setting Content-Length: 0 for empty body on method %d", static_cast<int>(method_enum));
                esp_http_client_set_header(esp_client_handle_, "Content-Length", "0");
            }
        }

        err = esp_http_client_perform(esp_client_handle_);
        Status status = MapEspErrorToStatus(err);

        // Final population of response_info_user, ensures it's set even if events didn't fully capture (e.g. error before events)
        if (response_info_user) {
            response_info_user->status_code = esp_http_client_get_status_code(esp_client_handle_);
            response_info_user->content_length = esp_http_client_get_content_length(esp_client_handle_);
            // response_info_user->connection_close is set by PlatformEventHandler
        }

        if (status == Status::kOk && response_info_user) {
            ESP_LOGI(TAG_IMPL, "PerformRequestInternal OK - HTTP Status: %d, Content-Length: %lld", response_info_user->status_code, response_info_user->content_length);
        } else if (status != Status::kOk) {
            int http_code = response_info_user ? response_info_user->status_code : esp_http_client_get_status_code(esp_client_handle_);
            ESP_LOGE(TAG_IMPL, "PerformRequestInternal failed: %s. HTTP Status (if available): %d", HttpsClient::StatusToString(status), http_code);
        }
        current_request_ctx_.response_info_ptr_user = nullptr; // Clear after this request
        current_request_ctx_.on_data_received_cb = nullptr; // Clear callback after this request
        return status;
    }

    Status PerformStreamUploadInternal(std::string_view url, HttpMethod method_enum,
                                       const Headers& headers, size_t total_body_length,
                                       DataProviderCallback data_provider, ResponseInfo* response_info_user) {
        if (!esp_client_handle_) { ESP_LOGE(TAG_IMPL, "StreamUpload: Client not initialized."); return Status::kNotInitialized; }
        if (!data_provider) { ESP_LOGE(TAG_IMPL, "StreamUpload: Data provider is null."); return Status::kInvalidArgument; }
        if (tx_buffer_size_ == 0) { ESP_LOGE(TAG_IMPL, "StreamUpload: TX buffer size is 0."); return Status::kNotInitialized; }

        current_request_ctx_.response_info_ptr_user = response_info_user;
        // current_request_ctx_.on_data_received_cb is set by the public PostStream/PutStream methods

        if (response_info_user) { *response_info_user = {}; }

        esp_err_t err_esp;
        std::array<char, HttpsClient::kMaxUrlLength> url_buffer;
        int len = snprintf(url_buffer.data(), url_buffer.size(), "%.*s", (int)url.length(), url.data());
        if (len < 0 || (size_t)len >= url_buffer.size()) { ESP_LOGE(TAG_IMPL, "StreamUpload: URL too long."); return Status::kBufferTooSmall; }

        esp_http_client_set_url(esp_client_handle_, url_buffer.data());
        esp_http_client_set_method(esp_client_handle_, MapHttpMethodToEsp(method_enum));

        bool cl_found = false;
        std::array<char, HttpsClient::kMaxHeaderKeyLen> hk_buf;
        std::array<char, HttpsClient::kMaxHeaderValueLen> hv_buf;
        for(const auto& h : headers){
            snprintf(hk_buf.data(),hk_buf.size(),"%.*s",(int)h.first.length(),h.first.data());
            snprintf(hv_buf.data(),hv_buf.size(),"%.*s",(int)h.second.length(),h.second.data());
            if(strcasecmp(hk_buf.data(),"Content-Length")==0) cl_found=true;
            esp_http_client_set_header(esp_client_handle_,hk_buf.data(),hv_buf.data());
        }
        if(!cl_found) { ESP_LOGE(TAG_IMPL, "StreamUpload: Content-Length header missing."); return Status::kInvalidArgument; }
        char* ct_val=nullptr; if(esp_http_client_get_header(esp_client_handle_,"Content-Type",&ct_val)!=ESP_OK||ct_val==nullptr){esp_http_client_set_header(esp_client_handle_,"Content-Type","application/octet-stream");} if(ct_val) free(ct_val);

        err_esp = esp_http_client_open(esp_client_handle_, total_body_length);
        if (err_esp != ESP_OK) {
            if(response_info_user) response_info_user->status_code = esp_http_client_get_status_code(esp_client_handle_);
            ESP_LOGE(TAG_IMPL, "StreamUpload: esp_http_client_open failed: %s", esp_err_to_name(err_esp));
            return MapEspErrorToStatus(err_esp);
        }

        std::vector<char> chunk_buffer;
        try { chunk_buffer.resize(tx_buffer_size_); }
        catch (const std::bad_alloc&) {
            ESP_LOGE(TAG_IMPL, "StreamUpload: Failed to allocate chunk_buffer.");
            esp_http_client_close(esp_client_handle_); // Attempt to close if open failed partially
            return Status::kNoMemory;
        }

        Status op_status = Status::kOk;
        size_t bytes_sent_total = 0;
        while (bytes_sent_total < total_body_length) {
            int bytes_in_chunk = data_provider(chunk_buffer.data(), chunk_buffer.size(), current_request_ctx_.user_context_from_config);
            if (bytes_in_chunk < 0) { ESP_LOGE(TAG_IMPL, "StreamUpload: data_provider error."); op_status = Status::kStreamError; break; }
            if (bytes_in_chunk == 0) { // EOF from provider
                if (bytes_sent_total < total_body_length) { ESP_LOGE(TAG_IMPL, "StreamUpload: data_provider EOF before all data sent."); op_status = Status::kStreamError; }
                break;
            }
            size_t current_chunk_size = static_cast<size_t>(bytes_in_chunk);
            // Optional: clamp current_chunk_size if > chunk_buffer.size() or > remaining total_body_length
            if (current_chunk_size > chunk_buffer.size()) current_chunk_size = chunk_buffer.size();
            if (bytes_sent_total + current_chunk_size > total_body_length) current_chunk_size = total_body_length - bytes_sent_total;
            if (current_chunk_size == 0) break;


            int written_bytes = esp_http_client_write(esp_client_handle_, chunk_buffer.data(), current_chunk_size);
            if (written_bytes < 0) { ESP_LOGE(TAG_IMPL, "StreamUpload: esp_http_client_write error %d", written_bytes); op_status = MapEspErrorToStatus(static_cast<esp_err_t>(written_bytes)); break; }
            if (static_cast<size_t>(written_bytes) != current_chunk_size) { ESP_LOGW(TAG_IMPL, "StreamUpload: Partial write %d of %zu", written_bytes, current_chunk_size); op_status = Status::kConnectionError; break; }
            bytes_sent_total += written_bytes;
        }

        if (op_status == Status::kOk && bytes_sent_total != total_body_length) {
            ESP_LOGE(TAG_IMPL, "StreamUpload: Sent %zu bytes, expected %zu.", bytes_sent_total, total_body_length);
            op_status = Status::kStreamError;
        }

        if (op_status == Status::kOk) {
            long long response_len = esp_http_client_fetch_headers(esp_client_handle_);
            if (response_len < 0) {
                op_status = MapEspErrorToStatus(static_cast<esp_err_t>(response_len));
                if(response_info_user) response_info_user->status_code = esp_http_client_get_status_code(esp_client_handle_);
                ESP_LOGE(TAG_IMPL, "StreamUpload: fetch_headers failed: %s", HttpsClient::StatusToString(op_status));
            } else {
                if (response_info_user) {
                    response_info_user->status_code = esp_http_client_get_status_code(esp_client_handle_);
                    response_info_user->content_length = response_len;
                }
            }
        }

        esp_http_client_close(esp_client_handle_); // Always close after esp_http_client_open sequence
        current_request_ctx_.response_info_ptr_user = nullptr;
        current_request_ctx_.on_data_received_cb = nullptr;
        return op_status;
    }

    // Static helper functions for ESP-IDF specifics
    static esp_err_t PlatformEventHandler(esp_http_client_event_t *evt) {
        RequestContext* req_ctx = static_cast<RequestContext*>(evt->user_data);
        if (!req_ctx) { ESP_LOGE(TAG_IMPL, "PlatformEventHandler: Context is null"); return ESP_FAIL; }

        esp_http_client_t* client = static_cast<esp_http_client_t*>(evt->client);

        switch (evt->event_id) {
            case HTTP_EVENT_ERROR:
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_ERROR");
                if (req_ctx->response_info_ptr_user && client) {
                     req_ctx->response_info_ptr_user->status_code = client->response.status_code;
                }
                break;
            case HTTP_EVENT_ON_CONNECTED:
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_ON_CONNECTED");
                if (req_ctx->response_info_ptr_user && client) {
                    req_ctx->response_info_ptr_user->status_code = client->response.status_code;
                    req_ctx->response_info_ptr_user->content_length = client->response.content_length;
                }
                break;
            case HTTP_EVENT_ON_HEADER:
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: ON_HEADER: %s: %s", evt->header_key, evt->header_value);
                if (req_ctx->response_info_ptr_user) {
                    if (client) { // Update on each header; will stabilize
                         req_ctx->response_info_ptr_user->status_code = client->response.status_code;
                         req_ctx->response_info_ptr_user->content_length = client->response.content_length;
                    }
                    if (strcasecmp(evt->header_key, "Connection") == 0 && strcasecmp(evt->header_value, "close") == 0) {
                        req_ctx->response_info_ptr_user->connection_close = true;
                    }
                }
                break;
            case HTTP_EVENT_ON_DATA:
                 ESP_LOGD(TAG_IMPL, "PlatformEventHandler: ON_DATA len=%d", evt->data_len);
                if (req_ctx->response_info_ptr_user && client) { // Ensure info is up-to-date before user callback
                    if (req_ctx->response_info_ptr_user->status_code == 0) req_ctx->response_info_ptr_user->status_code = client->response.status_code;
                    if (req_ctx->response_info_ptr_user->content_length == -1) req_ctx->response_info_ptr_user->content_length = client->response.content_length;
                }
                if (req_ctx->on_data_received_cb && evt->data_len > 0 && evt->data) {
                    Status cb_stat = req_ctx->on_data_received_cb( (const char*)evt->data, evt->data_len, req_ctx->user_context_from_config);
                    if (cb_stat != Status::kOk) { ESP_LOGE(TAG_IMPL, "Data cb error: %s", HttpsClient::StatusToString(cb_stat)); return ESP_FAIL; }
                } else if (evt->data_len > 0 && !req_ctx->on_data_received_cb) {
                     ESP_LOGW(TAG_IMPL, "PlatformEventHandler: Data (%d bytes) received but no callback set.", evt->data_len);
                }
                break;
            case HTTP_EVENT_ON_FINISH:
                ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_ON_FINISH");
                 if (req_ctx->response_info_ptr_user && client) { // Final update
                    req_ctx->response_info_ptr_user->status_code = client->response.status_code;
                    req_ctx->response_info_ptr_user->content_length = client->response.content_length;
                }
                break;
            case HTTP_EVENT_DISCONNECTED: ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_DISCONNECTED"); break;
            case HTTP_EVENT_REDIRECT: ESP_LOGD(TAG_IMPL, "PlatformEventHandler: HTTP_EVENT_REDIRECT"); esp_http_client_set_redirection(static_cast<esp_http_client_handle_t>(evt->client)); break;
            default: ESP_LOGD(TAG_IMPL, "PlatformEventHandler: Unhandled Event: %d", evt->event_id); break;
        }
        return ESP_OK;
    }
};

// --- HttpsClient Method Definitions (forwarding to PIMPL) ---
HttpsClient::HttpsClient() : impl_(std::make_unique<PlatformHttpClientImpl>()) {}

// Destructor MUST be defined here, after PlatformHttpClientImpl is fully defined.
HttpsClient::~HttpsClient() = default;

const char* HttpsClient::StatusToString(Status status) {
    switch (status) {
        case Status::kOk: return "Ok";
        case Status::kFail: return "Fail";
        case Status::kInvalidArgument: return "InvalidArgument";
        case Status::kNotInitialized: return "NotInitialized";
        case Status::kAlreadyInitialized: return "AlreadyInitialized";
        case Status::kNoMemory: return "NoMemory";
        case Status::kTimeout: return "Timeout";
        case Status::kNetworkError: return "NetworkError";
        case Status::kConnectionError: return "ConnectionError";
        case Status::kTlsError: return "TlsError";
        case Status::kHttpError: return "HttpError";
        case Status::kResponseError: return "ResponseError";
        case Status::kStreamError: return "StreamError";
        case Status::kBufferTooSmall: return "BufferTooSmall";
        case Status::kUnsupported: return "Unsupported";
        default: return "UnknownStatus";
    }
}

HttpsClient::Status HttpsClient::Open(const Config& config) {
    return impl_->Open(config);
}
HttpsClient::Status HttpsClient::Close() {
    return impl_->Close();
}
HttpsClient::Status HttpsClient::Head(std::string_view url, const Headers& headers, ResponseInfo* response_info) {
    if (!response_info) {
        ESP_LOGE(TAG_IMPL, "HttpsClient::Head: response_info cannot be null.");
        return Status::kInvalidArgument;
    }
    impl_->current_request_ctx_.on_data_received_cb = nullptr; // No data callback for HEAD
    return impl_->PerformRequestInternal(url, HttpMethod::kHead, headers, "", response_info);
}
HttpsClient::Status HttpsClient::Get(std::string_view url, const Headers& headers,
                                     DataReceivedCallback on_data_received, ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformRequestInternal(url, HttpMethod::kGet, headers, "", response_info);
}
HttpsClient::Status HttpsClient::Post(std::string_view url, const Headers& headers, std::string_view post_data,
                                      DataReceivedCallback on_data_received, ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformRequestInternal(url, HttpMethod::kPost, headers, post_data, response_info);
}
HttpsClient::Status HttpsClient::PostStream(std::string_view url, const Headers& headers, size_t total_body_length,
                                            DataProviderCallback data_provider, DataReceivedCallback on_data_received,
                                            ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformStreamUploadInternal(url, HttpMethod::kPost, headers, total_body_length, data_provider, response_info);
}
HttpsClient::Status HttpsClient::Put(std::string_view url, const Headers& headers, std::string_view put_data,
                                     DataReceivedCallback on_data_received, ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformRequestInternal(url, HttpMethod::kPut, headers, put_data, response_info);
}
HttpsClient::Status HttpsClient::PutStream(std::string_view url, const Headers& headers, size_t total_body_length,
                                           DataProviderCallback data_provider, DataReceivedCallback on_data_received,
                                           ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformStreamUploadInternal(url, HttpMethod::kPut, headers, total_body_length, data_provider, response_info);
}
HttpsClient::Status HttpsClient::Patch(std::string_view url, const Headers& headers, std::string_view patch_data,
                                       DataReceivedCallback on_data_received, ResponseInfo* response_info) {
    impl_->current_request_ctx_.on_data_received_cb = on_data_received;
    return impl_->PerformRequestInternal(url, HttpMethod::kPatch, headers, patch_data, response_info);
}

----------------------------------------------------------------------------------------------------------------

  /**
 * @file app_main_pimpl_example.cpp
 * @brief Example usage of HttpsClient (PIMPL version) as a member of another class.
 * @author Gemini
 * @date 2025-05-26 Current time is Monday, May 26, 2025 at 6:42:39 AM IST.
 */
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"

#include "https_client.h" // Public HttpsClient interface (PIMPL version)

#include <string>
#include <vector>
#include <memory> // For std::make_unique if creating HttpsClient on heap

static const char* kMainAppTag = "HTTP_PIMPL_EXAMPLE";

// Example Root CA certificate for httpbin.org (DigiCert Global Root CA)
// In a real application, manage certificates securely.
const char* HTTPBIN_ORG_ROOT_CA_PEM_PIMPL = \
"-----BEGIN CERTIFICATE-----\n" \
"MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh\n" \
"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" \
"d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\n" \
"QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT\n" \
"MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\n" \
"b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG\n" \
"9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhQbg0ef3p4HjF59iARFtLSr5oX2uaRpHm\n" \
"sHlwxLk/瘢truncated_for_brevity陟/LoUWOEFFnoBazbfKijwNRL34j0VEWWPId2\n" \
"ZAD95Yc//CN4zrf0M7PTDEu05KQS5bE2VzGc5r0uHgsJ9RUW02N1EutF81My1G8G\n" \
"0h0jLs7N50Py1G/hV18orjS57AmDk2N4AfsS7NRkQ6GKUnLNQLV47F6S9IFIPM/S\n" \
"2FpLuAXrRAhRkBzQE3KOzv/3u2/FP0SA0mmlhBgCV7SM2adWFLw23EY/CUDp2nRN\n" \
"k3sBDYWA8l5P7L9hSPSfl574p2sHZ7lI2zC2gV846e5EZ6FQxwIDAQABo2MwYTAO\n" \
"BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR\n" \
"TLtm8KPiGxv2c7hCs+gwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxv2c7hCs+gw\n" \
"DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr\n" \
"hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg\n" \
"06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF\n" \
"PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\n" \
"YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk\n" \
"CAUw7C29C79Fv1C5qfPrmAESrciAqZynZeUS7_HBIYB7ELI=\n" \
"-----END CERTIFICATE-----\n";

// Callback for collecting response body data into a std::string
HttpsClient::Status OnDataReceivedCollectPimpl(const char* data, size_t len, void* user_context) {
    std::string* response_buffer = static_cast<std::string*>(user_context);
    if (!response_buffer) {
        ESP_LOGE(kMainAppTag, "OnDataReceivedCollectPimpl: user_context (string buffer) is null!");
        return HttpsClient::Status::kFail;
    }
    try {
        response_buffer->append(data, len);
    } catch (const std::bad_alloc&) {
        ESP_LOGE(kMainAppTag, "OnDataReceivedCollectPimpl: std::bad_alloc appending data");
        return HttpsClient::Status::kNoMemory;
    }
    ESP_LOGD(kMainAppTag, "Collected %zu bytes, total response body size now %zu", len, response_buffer->length());
    return HttpsClient::Status::kOk;
}


class MyWebServiceManager {
public:
    MyWebServiceManager() {
        // Initialize client configuration for this manager
        client_config_.buffer_size_rx_bytes = 4096;
        client_config_.buffer_size_tx_bytes = 2048;
        client_config_.verify_server = true; // Should be true for production
        client_config_.server_cert_pem = HTTPBIN_ORG_ROOT_CA_PEM_PIMPL; // Use appropriate CA
        client_config_.timeout_ms = 15000; // 15 seconds
        ESP_LOGI(kMainAppTag, "MyWebServiceManager initialized.");

        // Open the client once, if it's to be reused for multiple calls by this manager
        // Or, Open/Close per operation if that's preferred.
        HttpsClient::Status open_status = http_client_instance_.Open(client_config_);
        if (open_status != HttpsClient::Status::kOk) {
            ESP_LOGE(kMainAppTag, "MyWebServiceManager: Failed to open HttpsClient: %s",
                     HttpsClient::StatusToString(open_status));
            // Handle error: perhaps set a flag indicating client is not ready
        } else {
            is_client_open_ = true;
        }
    }

    ~MyWebServiceManager() {
        if (is_client_open_) {
            http_client_instance_.Close();
        }
        ESP_LOGI(kMainAppTag, "MyWebServiceManager destroyed.");
    }

    /**
     * @brief Gets the size of a resource using a HEAD request.
     * @param resource_url The URL of the resource.
     * @param out_resource_size Reference to store the resource size.
     * @return True if size was successfully retrieved (HTTP 200), false otherwise.
     */
    bool GetResourceSize(std::string_view resource_url, long long& out_resource_size) {
        if (!is_client_open_) {
            ESP_LOGE(kMainAppTag, "GetResourceSize: Client not open.");
            // Optionally try to Open it here:
            // if (http_client_instance_.Open(client_config_) != HttpsClient::Status::kOk) return false;
            // is_client_open_ = true; // Then remember to Close it appropriately.
            return false;
        }

        ESP_LOGI(kMainAppTag, "MyWebServiceManager: Getting size for URL: %.*s", (int)resource_url.length(), resource_url.data());

        HttpsClient::ResponseInfo response_details = {};
        HttpsClient::Headers headers = { {"User-Agent", "MyWebServiceManagerApp/1.0-PIMPL"} };

        HttpsClient::Status status = http_client_instance_.Head(resource_url, headers, &response_details);

        if (status == HttpsClient::Status::kOk) {
            ESP_LOGI(kMainAppTag, "MyWebServiceManager: HEAD request HTTP Status: %d", response_details.status_code);
            if (response_details.status_code == 200) {
                if (response_details.content_length >= 0) {
                    out_resource_size = response_details.content_length;
                    ESP_LOGI(kMainAppTag, "MyWebServiceManager: Resource size: %lld bytes.", out_resource_size);
                    return true;
                } else {
                    ESP_LOGW(kMainAppTag, "MyWebServiceManager: HTTP 200, but Content-Length not found/invalid.");
                }
            } else {
                ESP_LOGW(kMainAppTag, "MyWebServiceManager: HEAD request returned non-200 status: %d", response_details.status_code);
            }
        } else {
            ESP_LOGE(kMainAppTag, "MyWebServiceManager: HEAD request failed: %s (HTTP Status: %d)",
                     HttpsClient::StatusToString(status), response_details.status_code);
        }
        return false;
    }

    /**
     * @brief Performs a GET request and collects the response body.
     * @param resource_url URL to GET.
     * @param out_body String to store the response body.
     * @return True on HTTP 200 and successful retrieval, false otherwise.
     */
    bool GetResourceContent(std::string_view resource_url, std::string& out_body) {
        if (!is_client_open_) {
            ESP_LOGE(kMainAppTag, "GetResourceContent: Client not open.");
            return false;
        }
        out_body.clear(); // Ensure out_body is empty

        ESP_LOGI(kMainAppTag, "MyWebServiceManager: Getting content for URL: %.*s", (int)resource_url.length(), resource_url.data());
        
        HttpsClient::ResponseInfo response_details = {};
        HttpsClient::Headers headers = { {"User-Agent", "MyWebServiceManagerApp/1.0-PIMPL"} };

        // Pass the address of the string as user_context for the OnDataReceivedCollectPimpl callback
        // Note: HttpsClient::Config user_context is used by the Impl's PlatformEventHandler.
        // To pass per-call context to the callback, we either need to modify config before each call (if on_data_received directly uses config.user_context)
        // OR the HttpsClient::Get method needs to accept a user_context for its specific callback.
        // The current HttpsClient::Config has a single user_context.
        // Let's assume client_config_.user_context is set to &out_body for this call.
        // A better way for PIMPL would be for Get/Post etc. to also take a void* user_callback_context.
        // For simplicity now, we'll assume the callback knows where to put data or capture.
        // The Impl's RequestContext does have user_context_from_config, which comes from client_config_.
        
        // To make this work correctly with current design: update config's user_context before this call.
        // This is a bit awkward if the HttpsClient is shared and config is set once.
        // The `PlatformHttpClientImpl::RequestContext` already has `user_context_from_config`
        // which is taken from `HttpsClient::Config::user_context`. So we set it there.
        client_config_.user_context = &out_body; // Temporary set for this call if Open doesn't re-read it.
                                                  // The Impl saves config at Open. This won't update it.
                                                  // The Impl's PerformRequestInternal sets current_request_ctx_.on_data_received_cb.
                                                  // The Impl's PlatformEventHandler uses current_request_ctx_.user_context_from_config for the callback.
                                                  // So, if user_context needs to change per call, the Config used in Open() needs to be updated or
                                                  // HttpsClient methods need their own user_context parameter for the callback.
        
        // Let's assume for this example, the user_context for the callback is simply the one set in config.
        // We'll use a lambda in the Get call to capture `out_body` directly. This avoids relying on config.user_context for this specific data.
        // This means the 'user_context' param in DataReceivedCallback will be whatever was in client_config_.user_context during Open().

        HttpsClient::Status status = http_client_instance_.Get(resource_url, headers,
            [&out_body](const char* data, size_t len, void* user_ctx_from_config_at_open) {
                // user_ctx_from_config_at_open is what was in client_config_.user_context during https_client_instance_.Open()
                // We are capturing 'out_body' by reference here.
                return OnDataReceivedCollectPimpl(data, len, &out_body);
            },
            &response_details
        );

        if (status == HttpsClient::Status::kOk && response_details.status_code == 200) {
            ESP_LOGI(kMainAppTag, "MyWebServiceManager: GET successful. Received %lld bytes.", response_details.content_length);
            return true;
        } else {
            ESP_LOGE(kMainAppTag, "MyWebServiceManager: GET failed. Status: %s, HTTP Code: %d",
                     HttpsClient::StatusToString(status), response_details.status_code);
        }
        return false;
    }


private:
    HttpsClient http_client_instance_; // HttpsClient (PIMPL version) as a direct member
    HttpsClient::Config client_config_;
    bool is_client_open_ = false;
};


extern "C" void app_main(void) {
    ESP_LOGI(kMainAppTag, "Starting PIMPL HTTPS Client Member Example");

    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    ESP_LOGI(kMainAppTag, "Example: Simulating WiFi connected...");
    vTaskDelay(pdMS_TO_TICKS(2000));

    MyWebServiceManager web_manager; // Create an instance of our class

    // Test HEAD request for content length
    const char* test_s3_url = "https://httpbin.org/bytes/1024"; // Get 1KB of random bytes
    long long object_size = -1;

    if (web_manager.GetResourceSize(test_s3_url, object_size)) {
        ESP_LOGI(kMainAppTag, "Main: Successfully obtained object size for %s: %lld bytes", test_s3_url, object_size);
        
        // Now try to GET the content
        if (object_size > 0) {
            std::string content_body;
            ESP_LOGI(kMainAppTag, "Main: Attempting to download content for %s", test_s3_url);
            if (web_manager.GetResourceContent(test_s3_url, content_body)) {
                ESP_LOGI(kMainAppTag, "Main: Successfully downloaded content. Size: %zu bytes.", content_body.length());
                // ESP_LOGI(kMainAppTag, "Main: Content (first 100 bytes): %.*s", 100, content_body.c_str());
            } else {
                ESP_LOGE(kMainAppTag, "Main: Failed to download content for %s", test_s3_url);
            }
        }

    } else {
        ESP_LOGE(kMainAppTag, "Main: Failed to obtain object size for %s.", test_s3_url);
    }

    ESP_LOGI(kMainAppTag, "PIMPL Example finished.");
}
