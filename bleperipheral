/**
 * @file ble_peripheral.cc
 * @brief Implementation of the BLE Peripheral interface using NimBLE.
 */
#include "ble_peripheral.h"
#include "NimBLEDevice.h"
#include "NimBLELog.h" // For logging

#include <map>
#include <string>
#include <vector>

namespace platform {
namespace connectivity {

// --- PIMPL Implementation Class ---
// This class contains all the private members and implementation details.
class BlePeripheral::BlePeripheralImpl {
public:
    // --- Types ---
    struct CharacteristicInfo {
        uint32_t properties;
        CharCallback callback;
        NimBLECharacteristic* pCharHandle{nullptr};
    };

    // --- Nested Callback Handlers ---
    class ServerCallbacks : public NimBLEServerCallbacks {
    public:
        explicit ServerCallbacks(BlePeripheralImpl& parent) : parent_(parent) {}
        void onConnect(NimBLEServer* pServer, NimBLEConnInfo& connInfo) override {
            NIMBLE_LOGI("BLE_PERIPHERAL", "Client connected: %s", connInfo.getAddress().toString().c_str());
            parent_.state_ = BleState::kConnected;
            if (parent_.onConnect_) {
                parent_.onConnect_();
            }
        }
        void onDisconnect(NimBLEServer* pServer, NimBLEConnInfo& connInfo, int reason) override {
            NIMBLE_LOGI("BLE_PERIPHERAL", "Client disconnected, reason: %d", reason);
            parent_.state_ = BleState::kDisconnected;
            if (parent_.onDisconnect_) {
                parent_.onDisconnect_();
            }
        }
    private:
        BlePeripheralImpl& parent_;
    };

    class CharacteristicCallbacks : public NimBLECharacteristicCallbacks {
    public:
        explicit CharacteristicCallbacks(BlePeripheralImpl& parent) : parent_(parent) {}
        void onWrite(NimBLECharacteristic* pCharacteristic, NimBLEConnInfo& connInfo) override {
            const auto& uuid = pCharacteristic->getUUID();
            NIMBLE_LOGD("BLE_PERIPHERAL", "Write to characteristic: %s", uuid.toString().c_str());
            auto* char_info = parent_.FindCharacteristic(uuid.toString());
            if (char_info && char_info->callback) {
                const std::string& value = pCharacteristic->getValue();
                char_info->callback(value.data(), value.size());
            }
        }
    private:
        BlePeripheralImpl& parent_;
    };

    // --- Constructor ---
    BlePeripheralImpl()
        : server_callbacks_(*this),
          char_callbacks_(*this) {}

    // --- Public Interface Implementation ---
    void Init(const std::string& device_name);
    void RegisterService(const std::string& service_uuid,
                         const std::vector<std::tuple<std::string, uint32_t, CharCallback>>& characteristics);
    void SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, bool notify);
    void SetAppearance(uint16_t appearance);
    void AddServiceUuid(const std::string& uuid);
    void SetServiceData(const std::string& service_uuid, const std::string& data);
    void SetManufacturerData(const std::string& data);
    void SetRawAdvertisingData(const std::vector<uint8_t>& data);
    void SetRawScanResponseData(const std::vector<uint8_t>& data);
    void ClearAdvertisingData(bool clear_scan_response);
    void StartLegacyAdvertising(bool connectable, uint16_t interval_ms);
#if ENABLE_BLE5_FEATURES
    void StartExtendedAdvertising(bool connectable, bool scannable, uint16_t interval_ms);
    void SetPreferredPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask);
#endif
    void StopAdvertising();
    void Disconnect();
    void SetConnectionCallback(std::function<void()> callback) { onConnect_ = std::move(callback); }
    void SetDisconnectionCallback(std::function<void()> callback) { onDisconnect_ = std::move(callback); }
    BleState GetState() const { return state_; }

private:
    CharacteristicInfo* FindCharacteristic(const std::string& uuid);

    // --- Member Variables ---
    bool initialized_{false};
    BleState state_{BleState::kIdle};
    NimBLEServer* pServer_{nullptr};
    NimBLEAdvertising* pAdvertising_{nullptr};
    ServerCallbacks server_callbacks_;
    CharacteristicCallbacks char_callbacks_;
    std::map<std::string, std::map<std::string, CharacteristicInfo>> serviceCharTable_;
    std::function<void()> onConnect_{nullptr};
    std::function<void()> onDisconnect_{nullptr};
};

// --- BlePeripheralImpl Method Definitions ---

BlePeripheral::BlePeripheralImpl::CharacteristicInfo* BlePeripheral::BlePeripheralImpl::FindCharacteristic(const std::string& uuid) {
    for (auto& servicePair : serviceCharTable_) {
        auto it = servicePair.second.find(uuid);
        if (it != servicePair.second.end()) {
            return &it->second;
        }
    }
    NIMBLE_LOGW("BLE_PERIPHERAL", "Characteristic %s not found", uuid.c_str());
    return nullptr;
}

void BlePeripheral::BlePeripheralImpl::Init(const std::string& device_name) {
    if (initialized_) {
        NIMBLE_LOGW("BLE_PERIPHERAL", "Already initialized");
        return;
    }
    NIMBLE_LOGI("BLE_PERIPHERAL", "Initializing with device name: %s", device_name.c_str());
    NimBLEDevice::init(device_name);
    NimBLEDevice::setMTU(517); // Max MTU for BLE 5
    NimBLEDevice::setPower(ESP_PWR_LVL_P9);

    pServer_ = NimBLEDevice::createServer();
    pServer_->setCallbacks(&server_callbacks_);

    pAdvertising_ = NimBLEDevice::getAdvertising();
    if (pAdvertising_) {
        pAdvertising_->setName(device_name);
        pAdvertising_->setScanResponse(true);
    }

    initialized_ = true;
    state_ = BleState::kIdle;
}

void BlePeripheral::BlePeripheralImpl::RegisterService(
    const std::string& service_uuid,
    const std::vector<std::tuple<std::string, uint32_t, BlePeripheral::CharCallback>>& characteristics) {
    if (!pServer_) {
        NIMBLE_LOGE("BLE_PERIPHERAL", "Server not initialized. Call Init() first.");
        return;
    }
    NIMBLE_LOGI("BLE_PERIPHERAL", "Registering service: %s", service_uuid.c_str());
    NimBLEService* pService = pServer_->createService(service_uuid);

    for (const auto& [char_uuid, properties, callback] : characteristics) {
        NimBLECharacteristic* pChar = pService->createCharacteristic(char_uuid, properties);
        pChar->setCallbacks(&char_callbacks_);
        serviceCharTable_[service_uuid][char_uuid] = {properties, callback, pChar};
        NIMBLE_LOGD("BLE_PERIPHERAL", "  - Characteristic: %s", char_uuid.c_str());
    }
    pService->start();
}

void BlePeripheral::BlePeripheralImpl::SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, bool notify) {
    auto* char_info = FindCharacteristic(char_uuid);
    if (!char_info || !char_info->pCharHandle) {
        return;
    }
    char_info->pCharHandle->setValue(static_cast<const uint8_t*>(value), size);
    if (notify && (char_info->properties & (CharProperty::kNotify | CharProperty::kIndicate))) {
        if (char_info->properties & CharProperty::kNotify) {
            char_info->pCharHandle->notify();
        }
        if (char_info->properties & CharProperty::kIndicate) {
            char_info->pCharHandle->indicate();
        }
    }
}

void BlePeripheral::BlePeripheralImpl::SetAppearance(uint16_t appearance) {
    if (pAdvertising_) pAdvertising_->setAppearance(appearance);
}

void BlePeripheral::BlePeripheralImpl::AddServiceUuid(const std::string& uuid) {
     if (pAdvertising_) pAdvertising_->addServiceUUID(uuid);
}

void BlePeripheral::BlePeripheralImpl::SetServiceData(const std::string& service_uuid, const std::string& data) {
    if (pAdvertising_) pAdvertising_->setServiceData(service_uuid, data);
}

void BlePeripheral::BlePeripheralImpl::SetManufacturerData(const std::string& data) {
    if (pAdvertising_) pAdvertising_->setManufacturerData(data);
}

void BlePeripheral::BlePeripheralImpl::SetRawAdvertisingData(const std::vector<uint8_t>& data) {
    if (pAdvertising_) pAdvertising_->setAdvertisingData(std::string(data.begin(), data.end()));
}

void BlePeripheral::BlePeripheralImpl::SetRawScanResponseData(const std::vector<uint8_t>& data) {
     if (pAdvertising_) pAdvertising_->setScanResponseData(std::string(data.begin(), data.end()));
}

void BlePeripheral::BlePeripheralImpl::ClearAdvertisingData(bool clear_scan_response) {
    if (!pAdvertising_) return;
    
    // Stop advertising before modifying the object
    if (pAdvertising_->isAdvertising()) {
        pAdvertising_->stop();
    }
    
    // Resetting the advertising object is the cleanest way to clear it.
    pAdvertising_->reset();
    
    // Restore default settings
    pAdvertising_->setName(NimBLEDevice::getDeviceName());
    pAdvertising_->setScanResponse(clear_scan_response);
}

void BlePeripheral::BlePeripheralImpl::StartLegacyAdvertising(bool connectable, uint16_t interval_ms) {
    if (!pAdvertising_) return;
    NIMBLE_LOGI("BLE_PERIPHERAL", "Starting legacy advertising...");
    pAdvertising_->setConnectable(connectable);
    // Convert ms to 0.625ms units for the interval
    uint16_t interval_units = interval_ms / 0.625;
    pAdvertising_->setMinInterval(interval_units);
    pAdvertising_->setMaxInterval(interval_units);
    pAdvertising_->start();
    state_ = BleState::kAdvertising;
}

#if ENABLE_BLE5_FEATURES
void BlePeripheral::BlePeripheralImpl::StartExtendedAdvertising(bool connectable, bool scannable, uint16_t interval_ms) {
    if (!pAdvertising_) return;
    NIMBLE_LOGI("BLE_PERIPHERAL", "Starting extended advertising...");
    pAdvertising_->setConnectable(connectable);
    pAdvertising_->setScannable(scannable);
    // Convert ms to 0.625ms units for the interval
    uint16_t interval_units = interval_ms / 0.625;
    pAdvertising_->setMinInterval(interval_units);
    pAdvertising_->setMaxInterval(interval_units);
    // Use instance 0 for extended advertising. No duration limit (0), no max events (0).
    pAdvertising_->start(0, nullptr, 0);
    state_ = BleState::kAdvertising;
}

void BlePeripheral::BlePeripheralImpl::SetPreferredPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask) {
    NIMBLE_LOGI("BLE_PERIPHERAL", "Setting preferred PHY: TX=%d, RX=%d", tx_phys_mask, rx_phys_mask);
    NimBLEDevice::setPhy(static_cast<esp_ble_phy_t>(tx_phys_mask), static_cast<esp_ble_phy_t>(rx_phys_mask));
}
#endif

void BlePeripheral::BlePeripheralImpl::StopAdvertising() {
    if (pAdvertising_ && pAdvertising_->isAdvertising()) {
        NIMBLE_LOGI("BLE_PERIPHERAL", "Stopping advertising");
        pAdvertising_->stop();
        state_ = BleState::kIdle;
    }
}

void BlePeripheral::BlePeripheralImpl::Disconnect() {
    if (pServer_ && state_ == BleState::kConnected) {
        auto connected_peers = pServer_->getPeerDevices();
        if (!connected_peers.empty()) {
            uint16_t conn_id = connected_peers.begin()->first;
            NIMBLE_LOGI("BLE_PERIPHERAL", "Requesting disconnect from client with ConnID: %d", conn_id);
            pServer_->disconnect(conn_id);
        }
    }
}

// --- BlePeripheral Public Method Forwarding ---
// The public methods just call the implementation methods.

BlePeripheral::BlePeripheral() : impl_(std::make_unique<BlePeripheralImpl>()) {}
BlePeripheral::~BlePeripheral() = default;

void BlePeripheral::Init(const std::string& device_name) { impl_->Init(device_name); }
void BlePeripheral::RegisterService(const std::string& service_uuid, const std::vector<std::tuple<std::string, uint32_t, CharCallback>>& characteristics) {
    impl_->RegisterService(service_uuid, characteristics);
}
void BlePeripheral::SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, bool notify) {
    impl_->SetCharacteristicValue(char_uuid, value, size, notify);
}
void BlePeripheral::SetAppearance(uint16_t appearance) { impl_->SetAppearance(appearance); }
void BlePeripheral::AddServiceUuid(const std::string& uuid) { impl_->AddServiceUuid(uuid); }
void BlePeripheral::SetServiceData(const std::string& service_uuid, const std::string& data) { impl_->SetServiceData(service_uuid, data); }
void BlePeripheral::SetManufacturerData(const std::string& data) { impl_->SetManufacturerData(data); }
void BlePeripheral::SetRawAdvertisingData(const std::vector<uint8_t>& data) { impl_->SetRawAdvertisingData(data); }
void BlePeripheral::SetRawScanResponseData(const std::vector<uint8_t>& data) { impl_->SetRawScanResponseData(data); }
void BlePeripheral::ClearAdvertisingData(bool clear_scan_response) { impl_->ClearAdvertisingData(clear_scan_response); }
void BlePeripheral::StartLegacyAdvertising(bool connectable, uint16_t interval_ms) { impl_->StartLegacyAdvertising(connectable, interval_ms); }
#if ENABLE_BLE5_FEATURES
void BlePeripheral::StartExtendedAdvertising(bool connectable, bool scannable, uint16_t interval_ms) { impl_->StartExtendedAdvertising(connectable, scannable, interval_ms); }
void BlePeripheral::SetPreferredPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask) { impl_->SetPreferredPhy(tx_phys_mask, rx_phys_mask); }
#endif
void BlePeripheral::StopAdvertising() { impl_->StopAdvertising(); }
void BlePeripheral::Disconnect() { impl_->Disconnect(); }
void BlePeripheral::SetConnectionCallback(std::function<void()> callback) { impl_->SetConnectionCallback(std::move(callback)); }
void BlePeripheral::SetDisconnectionCallback(std::function<void()> callback) { impl_->SetDisconnectionCallback(std::move(callback)); }
BlePeripheral::BleState BlePeripheral::GetState() const { return impl_->GetState(); }

} // namespace connectivity
} // namespace platform
----------------

/**
 * @file ble_peripheral.cc
 * @brief Implementation of the BLE Peripheral interface using NimBLE.
 */
#include "ble_peripheral.h"
#include "NimBLEDevice.h"
#include "NimBLELog.h" // For logging

#include <map>
#include <string>
#include <vector>

namespace platform {
namespace connectivity {

// --- PIMPL Implementation Class ---
// This class contains all the private members and implementation details.
class BlePeripheral::BlePeripheralImpl {
public:
    // --- Types ---
    struct CharacteristicInfo {
        uint32_t properties;
        CharCallback callback;
        NimBLECharacteristic* pCharHandle{nullptr};
    };

    // --- Nested Callback Handlers ---
    class ServerCallbacks : public NimBLEServerCallbacks {
    public:
        explicit ServerCallbacks(BlePeripheralImpl& parent) : parent_(parent) {}
        void onConnect(NimBLEServer* pServer, NimBLEConnInfo& connInfo) override {
            NIMBLE_LOGI("BLE_PERIPHERAL", "Client connected: %s", connInfo.getAddress().toString().c_str());
            parent_.state_ = BleState::kConnected;
            if (parent_.onConnect_) {
                parent_.onConnect_();
            }
        }
        void onDisconnect(NimBLEServer* pServer, NimBLEConnInfo& connInfo, int reason) override {
            NIMBLE_LOGI("BLE_PERIPHERAL", "Client disconnected, reason: %d", reason);
            parent_.state_ = BleState::kDisconnected;
            if (parent_.onDisconnect_) {
                parent_.onDisconnect_();
            }
        }
    private:
        BlePeripheralImpl& parent_;
    };

    class CharacteristicCallbacks : public NimBLECharacteristicCallbacks {
    public:
        explicit CharacteristicCallbacks(BlePeripheralImpl& parent) : parent_(parent) {}
        void onWrite(NimBLECharacteristic* pCharacteristic, NimBLEConnInfo& connInfo) override {
            const auto& uuid = pCharacteristic->getUUID();
            NIMBLE_LOGD("BLE_PERIPHERAL", "Write to characteristic: %s", uuid.toString().c_str());
            auto* char_info = parent_.FindCharacteristic(uuid.toString());
            if (char_info && char_info->callback) {
                const std::string& value = pCharacteristic->getValue();
                char_info->callback(value.data(), value.size());
            }
        }
    private:
        BlePeripheralImpl& parent_;
    };

    // --- Constructor ---
    BlePeripheralImpl()
        : server_callbacks_(*this),
          char_callbacks_(*this) {}

    // --- Public Interface Implementation ---
    void Init(const std::string& device_name);
    void RegisterService(const std::string& service_uuid,
                         const std::vector<std::tuple<std::string, uint32_t, CharCallback>>& characteristics);
    void SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, bool notify);
    void SetAppearance(uint16_t appearance);
    void AddServiceUuid(const std::string& uuid);
    void SetServiceData(const std::string& service_uuid, const std::string& data);
    void SetManufacturerData(const std::string& data);
    void SetRawAdvertisingData(const std::vector<uint8_t>& data);
    void SetRawScanResponseData(const std::vector<uint8_t>& data);
    void ClearAdvertisingData(bool clear_scan_response);
    void StartLegacyAdvertising(bool connectable, uint16_t interval_ms);
#if ENABLE_BLE5_FEATURES
    void StartExtendedAdvertising(bool connectable, bool scannable, uint16_t interval_ms);
    void SetPreferredPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask);
#endif
    void StopAdvertising();
    void Disconnect();
    void SetConnectionCallback(std::function<void()> callback) { onConnect_ = std::move(callback); }
    void SetDisconnectionCallback(std::function<void()> callback) { onDisconnect_ = std::move(callback); }
    BleState GetState() const { return state_; }

private:
    CharacteristicInfo* FindCharacteristic(const std::string& uuid);

    // --- Member Variables ---
    bool initialized_{false};
    BleState state_{BleState::kIdle};
    NimBLEServer* pServer_{nullptr};
    NimBLEAdvertising* pAdvertising_{nullptr};
    ServerCallbacks server_callbacks_;
    CharacteristicCallbacks char_callbacks_;
    std::map<std::string, std::map<std::string, CharacteristicInfo>> serviceCharTable_;
    std::function<void()> onConnect_{nullptr};
    std::function<void()> onDisconnect_{nullptr};
};

// --- BlePeripheralImpl Method Definitions ---

BlePeripheral::BlePeripheralImpl::CharacteristicInfo* BlePeripheral::BlePeripheralImpl::FindCharacteristic(const std::string& uuid) {
    for (auto& servicePair : serviceCharTable_) {
        auto it = servicePair.second.find(uuid);
        if (it != servicePair.second.end()) {
            return &it->second;
        }
    }
    NIMBLE_LOGW("BLE_PERIPHERAL", "Characteristic %s not found", uuid.c_str());
    return nullptr;
}

void BlePeripheral::BlePeripheralImpl::Init(const std::string& device_name) {
    if (initialized_) {
        NIMBLE_LOGW("BLE_PERIPHERAL", "Already initialized");
        return;
    }
    NIMBLE_LOGI("BLE_PERIPHERAL", "Initializing with device name: %s", device_name.c_str());
    NimBLEDevice::init(device_name);
    NimBLEDevice::setMTU(517); // Max MTU for BLE 5
    NimBLEDevice::setPower(ESP_PWR_LVL_P9);

    pServer_ = NimBLEDevice::createServer();
    pServer_->setCallbacks(&server_callbacks_);

    pAdvertising_ = NimBLEDevice::getAdvertising();
    if (pAdvertising_) {
        pAdvertising_->setName(device_name);
        pAdvertising_->setScanResponse(true);
    }

    initialized_ = true;
    state_ = BleState::kIdle;
}

void BlePeripheral::BlePeripheralImpl::RegisterService(
    const std::string& service_uuid,
    const std::vector<std::tuple<std::string, uint32_t, BlePeripheral::CharCallback>>& characteristics) {
    if (!pServer_) {
        NIMBLE_LOGE("BLE_PERIPHERAL", "Server not initialized. Call Init() first.");
        return;
    }
    NIMBLE_LOGI("BLE_PERIPHERAL", "Registering service: %s", service_uuid.c_str());
    NimBLEService* pService = pServer_->createService(service_uuid);

    for (const auto& [char_uuid, properties, callback] : characteristics) {
        NimBLECharacteristic* pChar = pService->createCharacteristic(char_uuid, properties);
        pChar->setCallbacks(&char_callbacks_);
        serviceCharTable_[service_uuid][char_uuid] = {properties, callback, pChar};
        NIMBLE_LOGD("BLE_PERIPHERAL", "  - Characteristic: %s", char_uuid.c_str());
    }
    pService->start();
}

void BlePeripheral::BlePeripheralImpl::SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, bool notify) {
    auto* char_info = FindCharacteristic(char_uuid);
    if (!char_info || !char_info->pCharHandle) {
        return;
    }
    char_info->pCharHandle->setValue(static_cast<const uint8_t*>(value), size);
    if (notify && (char_info->properties & (CharProperty::kNotify | CharProperty::kIndicate))) {
        if (char_info->properties & CharProperty::kNotify) {
            char_info->pCharHandle->notify();
        }
        if (char_info->properties & CharProperty::kIndicate) {
            char_info->pCharHandle->indicate();
        }
    }
}

void BlePeripheral::BlePeripheralImpl::SetAppearance(uint16_t appearance) {
    if (pAdvertising_) pAdvertising_->setAppearance(appearance);
}

void BlePeripheral::BlePeripheralImpl::AddServiceUuid(const std::string& uuid) {
     if (pAdvertising_) pAdvertising_->addServiceUUID(uuid);
}

void BlePeripheral::BlePeripheralImpl::SetServiceData(const std::string& service_uuid, const std::string& data) {
    if (pAdvertising_) pAdvertising_->setServiceData(service_uuid, data);
}

void BlePeripheral::BlePeripheralImpl::SetManufacturerData(const std::string& data) {
    if (pAdvertising_) pAdvertising_->setManufacturerData(data);
}

void BlePeripheral::BlePeripheralImpl::SetRawAdvertisingData(const std::vector<uint8_t>& data) {
    if (pAdvertising_) pAdvertising_->setAdvertisingData(std::string(data.begin(), data.end()));
}

void BlePeripheral::BlePeripheralImpl::SetRawScanResponseData(const std::vector<uint8_t>& data) {
     if (pAdvertising_) pAdvertising_->setScanResponseData(std::string(data.begin(), data.end()));
}

void BlePeripheral::BlePeripheralImpl::ClearAdvertisingData(bool clear_scan_response) {
    if (!pAdvertising_) return;
    
    // Stop advertising before modifying the object
    if (pAdvertising_->isAdvertising()) {
        pAdvertising_->stop();
    }
    
    // Resetting the advertising object is the cleanest way to clear it.
    pAdvertising_->reset();
    
    // Restore default settings
    pAdvertising_->setName(NimBLEDevice::getDeviceName());
    pAdvertising_->setScanResponse(clear_scan_response);
}

void BlePeripheral::BlePeripheralImpl::StartLegacyAdvertising(bool connectable, uint16_t interval_ms) {
    if (!pAdvertising_) return;
    NIMBLE_LOGI("BLE_PERIPHERAL", "Starting legacy advertising...");
    pAdvertising_->setConnectable(connectable);
    // Convert ms to 0.625ms units for the interval
    uint16_t interval_units = interval_ms / 0.625;
    pAdvertising_->setMinInterval(interval_units);
    pAdvertising_->setMaxInterval(interval_units);
    pAdvertising_->start();
    state_ = BleState::kAdvertising;
}

#if ENABLE_BLE5_FEATURES
void BlePeripheral::BlePeripheralImpl::StartExtendedAdvertising(bool connectable, bool scannable, uint16_t interval_ms) {
    if (!pAdvertising_) return;
    NIMBLE_LOGI("BLE_PERIPHERAL", "Starting extended advertising...");
    pAdvertising_->setConnectable(connectable);
    pAdvertising_->setScannable(scannable);
    // Convert ms to 0.625ms units for the interval
    uint16_t interval_units = interval_ms / 0.625;
    pAdvertising_->setMinInterval(interval_units);
    pAdvertising_->setMaxInterval(interval_units);
    // Use instance 0 for extended advertising. No duration limit (0), no max events (0).
    pAdvertising_->start(0, nullptr, 0);
    state_ = BleState::kAdvertising;
}

void BlePeripheral::BlePeripheralImpl::SetPreferredPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask) {
    NIMBLE_LOGI("BLE_PERIPHERAL", "Setting preferred PHY: TX=%d, RX=%d", tx_phys_mask, rx_phys_mask);
    NimBLEDevice::setPhy(static_cast<esp_ble_phy_t>(tx_phys_mask), static_cast<esp_ble_phy_t>(rx_phys_mask));
}
#endif

void BlePeripheral::BlePeripheralImpl::StopAdvertising() {
    if (pAdvertising_ && pAdvertising_->isAdvertising()) {
        NIMBLE_LOGI("BLE_PERIPHERAL", "Stopping advertising");
        pAdvertising_->stop();
        state_ = BleState::kIdle;
    }
}

void BlePeripheral::BlePeripheralImpl::Disconnect() {
    if (pServer_ && state_ == BleState::kConnected) {
        auto connected_peers = pServer_->getPeerDevices();
        if (!connected_peers.empty()) {
            uint16_t conn_id = connected_peers.begin()->first;
            NIMBLE_LOGI("BLE_PERIPHERAL", "Requesting disconnect from client with ConnID: %d", conn_id);
            pServer_->disconnect(conn_id);
        }
    }
}

// --- BlePeripheral Public Method Forwarding ---
// The public methods just call the implementation methods.

BlePeripheral::BlePeripheral() : impl_(std::make_unique<BlePeripheralImpl>()) {}
BlePeripheral::~BlePeripheral() = default;

void BlePeripheral::Init(const std::string& device_name) { impl_->Init(device_name); }
void BlePeripheral::RegisterService(const std::string& service_uuid, const std::vector<std::tuple<std::string, uint32_t, CharCallback>>& characteristics) {
    impl_->RegisterService(service_uuid, characteristics);
}
void BlePeripheral::SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, bool notify) {
    impl_->SetCharacteristicValue(char_uuid, value, size, notify);
}
void BlePeripheral::SetAppearance(uint16_t appearance) { impl_->SetAppearance(appearance); }
void BlePeripheral::AddServiceUuid(const std::string& uuid) { impl_->AddServiceUuid(uuid); }
void BlePeripheral::SetServiceData(const std::string& service_uuid, const std::string& data) { impl_->SetServiceData(service_uuid, data); }
void BlePeripheral::SetManufacturerData(const std::string& data) { impl_->SetManufacturerData(data); }
void BlePeripheral::SetRawAdvertisingData(const std::vector<uint8_t>& data) { impl_->SetRawAdvertisingData(data); }
void BlePeripheral::SetRawScanResponseData(const std::vector<uint8_t>& data) { impl_->SetRawScanResponseData(data); }
void BlePeripheral::ClearAdvertisingData(bool clear_scan_response) { impl_->ClearAdvertisingData(clear_scan_response); }
void BlePeripheral::StartLegacyAdvertising(bool connectable, uint16_t interval_ms) { impl_->StartLegacyAdvertising(connectable, interval_ms); }
#if ENABLE_BLE5_FEATURES
void BlePeripheral::StartExtendedAdvertising(bool connectable, bool scannable, uint16_t interval_ms) { impl_->StartExtendedAdvertising(connectable, scannable, interval_ms); }
void BlePeripheral::SetPreferredPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask) { impl_->SetPreferredPhy(tx_phys_mask, rx_phys_mask); }
#endif
void BlePeripheral::StopAdvertising() { impl_->StopAdvertising(); }
void BlePeripheral::Disconnect() { impl_->Disconnect(); }
void BlePeripheral::SetConnectionCallback(std::function<void()> callback) { impl_->SetConnectionCallback(std::move(callback)); }
void BlePeripheral::SetDisconnectionCallback(std::function<void()> callback) { impl_->SetDisconnectionCallback(std::move(callback)); }
BlePeripheral::BleState BlePeripheral::GetState() const { return impl_->GetState(); }

} // namespace connectivity
} // namespace platform
