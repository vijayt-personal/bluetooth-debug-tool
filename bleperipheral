/**
 * @file ble_peripheral.h
 * @brief BLE Peripheral interface for handling BLE server, advertising, and
 * modern BLE 5 features.
 */
#ifndef PLATFORM_BLE_PERIPHERAL_H_
#define PLATFORM_BLE_PERIPHERAL_H_

#include <cstddef>
#include <cstdint>
#include <functional>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

// To enable BLE 5 features, define this as 1 in your project's build flags
// (e.g., CXXFLAGS+="-DENABLE_BLE5_FEATURES=1")
#ifndef ENABLE_BLE5_FEATURES
#define ENABLE_BLE5_FEATURES 0
#endif

namespace platform {
namespace connectivity {

class BlePeripheral {
public:
    /**
     * @brief Represents the current state of the BLE peripheral.
     * kIdle: Not connected and not advertising.
     * kAdvertising: Advertising, but not connected.
     * kConnected: Connected to a peer device.
     */
    enum class BleState { kIdle, kAdvertising, kConnected };

    /** @brief Defines properties for a BLE characteristic. Can be combined using bitwise OR. */
    enum class CharProperty : uint32_t {
        kRead            = 0x02,
        kWriteNoResponse = 0x04,
        kWrite           = 0x08,
        kNotify          = 0x10,
        kIndicate        = 0x20,
    };

    /** @brief Specifies the type of notification to send for a characteristic update. */
    enum class NotificationType { kNone, kNotify, kIndicate };

    /** @brief Bitmask for selecting BLE PHYs. */
    enum PhyMask : uint8_t {
        kPhy1m   = (1 << 0),
        kPhy2m   = (1 << 1),
        kPhyCoded= (1 << 2),
    };

    /** @brief Callback function type for characteristic events (e.g., onWrite). */
    using CharCallback = std::function<void(const void *data, size_t size)>;
    /** @brief Callback function type for MTU change events. */
    using MtuChangedCallback = std::function<void(uint16_t effective_mtu)>;

    BlePeripheral();
    ~BlePeripheral();

    // Disable copy and move semantics to prevent accidental duplication.
    BlePeripheral(const BlePeripheral &) = delete;
    BlePeripheral &operator=(const BlePeripheral &) = delete;
    BlePeripheral(BlePeripheral &&) = delete;
    BlePeripheral &operator=(BlePeripheral &&) = delete;
    
    /**
     * @brief Sets the desired MTU for the device.
     * @note MUST be called before Init().
     * @param mtu The desired MTU size (e.g., 517).
     */
    void SetDesiredMtu(uint16_t mtu);

    /**
     * @brief Initializes the BLE stack and peripheral.
     * @param device_name The name for the device to advertise.
     */
    void Init(const std::string &device_name);

    /**
     * @brief Registers a service with its characteristics.
     * @param service_uuid The UUID of the service.
     * @param characteristics A vector of tuples, each containing a characteristic's
     * UUID, its properties (bitwise OR'd), and an optional callback.
     */
    void RegisterService(const std::string &service_uuid,
                         const std::vector<std::tuple<std::string, uint32_t, CharCallback>> &characteristics);

    /**
     * @brief Sets the value of a characteristic and optionally notifies/indicates the client.
     * @param char_uuid The UUID of the characteristic to update.
     * @param value Pointer to the data to set.
     * @param size The size of the data.
     * @param notification_type The type of notification to send. Checks if the property is supported.
     */
    void SetCharacteristicValue(const std::string &char_uuid, const void *value, size_t size,
                                NotificationType notification_type = NotificationType::kNone);

    // --- Advertising Management ---

    /** @brief Sets the GAP appearance in the advertising packet. */
    void SetAppearance(uint16_t appearance);

    /** @brief Adds a service UUID to the advertising packet. */
    void AddServiceUuid(const std::string& uuid);
    
    /** @brief Sets service-specific data from raw bytes. */
    void SetServiceData(const std::string &service_uuid, const uint8_t* data, size_t size);

    /** @brief Sets service-specific data from a byte vector. */
    void SetServiceData(const std::string &service_uuid, const std::vector<uint8_t>& data);

    /** @brief Sets manufacturer-specific data from raw bytes. */
    void SetManufacturerData(const uint8_t* data, size_t size);

    /** @brief Sets manufacturer-specific data from a byte vector. */
    void SetManufacturerData(const std::vector<uint8_t>& data);

    /** @brief Sets the entire raw advertising payload from a byte vector. */
    void SetRawAdvertisingData(const std::vector<uint8_t>& data);

    /** @brief Sets the entire raw advertising payload from raw bytes. */
    void SetRawAdvertisingData(const uint8_t* data, size_t size);

    /** @brief Sets the entire raw scan response payload from a byte vector. */
    void SetRawScanResponseData(const std::vector<uint8_t>& data);
    
    /** @brief Sets the entire raw scan response payload from raw bytes. */
    void SetRawScanResponseData(const uint8_t* data, size_t size);

    /** @brief Clears advertising data. Resets scan response to include device name by default. */
    void ClearAdvertisingData(bool clear_scan_response = true);

    /**
     * @brief Starts legacy BLE advertising.
     * @param connectable If true, allows clients to connect.
     * @param interval_ms The desired advertising interval in milliseconds.
     */
    void StartLegacyAdvertising(bool connectable = true, uint16_t interval_ms = 100);

#if ENABLE_BLE5_FEATURES
    /**
     * @brief Starts BLE 5 extended advertising. (BLE 5 ONLY)
     * @param connectable If true, allows clients to connect. Connectable advertisements are also scannable.
     * @param interval_ms The desired advertising interval in milliseconds.
     */
    void StartExtendedAdvertising(bool connectable = true, uint16_t interval_ms = 100);

    /**
     * @brief Sets the default PHYs for new connections. (BLE 5 ONLY)
     * @param tx_phys_mask A bitmask of preferred transmit PHYs (e.g., kPhy1m | kPhy2m).
     * @param rx_phys_mask A bitmask of preferred receive PHYs.
     */
    void SetDefaultPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask);
#endif

    /** @brief Stops any active advertising. */
    void StopAdvertising();

    /** @brief Disconnects any currently connected client. */
    void Disconnect();

    /** @brief Registers a callback to be invoked when a client connects. */
    void SetConnectionCallback(std::function<void()> callback);

    /** @brief Registers a callback to be invoked when a client disconnects. */
    void SetDisconnectionCallback(std::function<void()> callback);

    /** @brief Registers a callback to be invoked when the MTU is negotiated. */
    void SetMtuChangedCallback(MtuChangedCallback callback);

    /** @brief Gets the current connection state. */
    BleState GetState() const;

private:
    class BlePeripheralImpl;
    std::unique_ptr<BlePeripheralImpl> impl_;
};

// --- Operator overloads for convenient bitwise operations on enums ---

inline uint32_t operator|(BlePeripheral::CharProperty a, BlePeripheral::CharProperty b) {
    return static_cast<uint32_t>(a) | static_cast<uint32_t>(b);
}

inline uint32_t operator|(uint32_t val, BlePeripheral::CharProperty prop) {
    return val | static_cast<uint32_t>(prop);
}

inline bool operator&(uint32_t val, BlePeripheral::CharProperty prop) {
    return (val & static_cast<uint32_t>(prop)) != 0;
}

} // namespace connectivity
} // namespace platform

#endif // PLATFORM_BLE_PERIPHERAL_H_

/**
 * @file ble_peripheral.cc
 * @brief Implementation of the BLE Peripheral interface using NimBLE.
 */
#include "ble_peripheral.h"
#include "NimBLEDevice.h"
#include "NimBLELog.h" // For logging

#include <map>
#include <string>
#include <vector>
#include <algorithm> // For std::find

namespace platform {
namespace connectivity {

// --- PIMPL Implementation Class ---
// This class contains all the private members and implementation details.
class BlePeripheral::BlePeripheralImpl {
public:
    // --- Types ---
    struct CharacteristicInfo {
        uint32_t properties;
        CharCallback callback;
        NimBLECharacteristic* pCharHandle{nullptr};
    };

    // --- Nested Callback Handlers ---
    class ServerCallbacks : public NimBLEServerCallbacks {
    public:
        explicit ServerCallbacks(BlePeripheralImpl& parent) : parent_(parent) {}
        void onConnect(NimBLEServer* pServer, NimBLEConnInfo& connInfo) override {
            NIMBLE_LOGI("BLE_PERIPHERAL", "Client connected: %s", connInfo.getAddress().toString().c_str());
            parent_.state_ = BleState::kConnected;
            
            uint16_t effective_mtu = connInfo.getMTU();
            NIMBLE_LOGI("BLE_PERIPHERAL", "Negotiated MTU: %d", effective_mtu);
            if (parent_.onMtuChanged_) {
                parent_.onMtuChanged_(effective_mtu);
            }

            if (parent_.onConnect_) {
                parent_.onConnect_();
            }
        }
        void onDisconnect(NimBLEServer* pServer, NimBLEConnInfo& connInfo, int reason) override {
            NIMBLE_LOGI("BLE_PERIPHERAL", "Client disconnected, reason: %d", reason);
            parent_.state_ = BleState::kIdle;
            if (parent_.onDisconnect_) {
                parent_.onDisconnect_();
            }
        }
    private:
        BlePeripheralImpl& parent_;
    };

    class CharacteristicCallbacks : public NimBLECharacteristicCallbacks {
    public:
        explicit CharacteristicCallbacks(BlePeripheralImpl& parent) : parent_(parent) {}
        void onWrite(NimBLECharacteristic* pCharacteristic, NimBLEConnInfo& connInfo) override {
            const auto& uuid = pCharacteristic->getUUID();
            NIMBLE_LOGD("BLE_PERIPHERAL", "Write to characteristic: %s", uuid.toString().c_str());
            auto* char_info = parent_.FindCharacteristic(uuid.toString());
            if (char_info && char_info->callback) {
                const std::string& value = pCharacteristic->getValue();
                char_info->callback(value.data(), value.size());
            }
        }
    private:
        BlePeripheralImpl& parent_;
    };

    // --- Constructor ---
    BlePeripheralImpl()
        : server_callbacks_(*this),
          char_callbacks_(*this) {}

    // --- Public Interface Implementation ---
    void SetDesiredMtu(uint16_t mtu);
    void Init(const std::string& device_name);
    void RegisterService(const std::string& service_uuid,
                         const std::vector<std::tuple<std::string, uint32_t, CharCallback>>& characteristics);
    void SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, NotificationType notification_type);
    void SetAppearance(uint16_t appearance);
    void AddServiceUuid(const std::string& uuid);
    void SetServiceData(const std::string& service_uuid, const uint8_t* data, size_t size);
    void SetManufacturerData(const uint8_t* data, size_t size);
    void SetRawAdvertisingData(const uint8_t* data, size_t size);
    void SetRawScanResponseData(const uint8_t* data, size_t size);
    void ClearAdvertisingData(bool clear_scan_response);
    void StartLegacyAdvertising(bool connectable, uint16_t interval_ms);
#if ENABLE_BLE5_FEATURES
    void StartExtendedAdvertising(bool connectable, uint16_t interval_ms);
    void SetDefaultPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask);
#endif
    void StopAdvertising();
    void Disconnect();
    void SetConnectionCallback(std::function<void()> callback) { onConnect_ = std::move(callback); }
    void SetDisconnectionCallback(std::function<void()> callback) { onDisconnect_ = std::move(callback); }
    void SetMtuChangedCallback(MtuChangedCallback callback) { onMtuChanged_ = std::move(callback); }
    BleState GetState() const { return state_; }

private:
    CharacteristicInfo* FindCharacteristic(const std::string& uuid);
    void RebuildAndApplyAdvertisingData();

    // --- Member Variables ---
    bool initialized_{false};
    std::string device_name_;
    uint16_t desired_mtu_{23};
    BleState state_{BleState::kIdle};
    NimBLEServer* pServer_{nullptr};
    NimBLEAdvertising* pAdvertising_{nullptr};
    ServerCallbacks server_callbacks_;
    CharacteristicCallbacks char_callbacks_;
    std::map<std::string, std::map<std::string, CharacteristicInfo>> serviceCharTable_;
    std::function<void()> onConnect_{nullptr};
    std::function<void()> onDisconnect_{nullptr};
    MtuChangedCallback onMtuChanged_{nullptr};

    // --- Advertising Data Components ---
    uint8_t adv_flags_{BLE_HS_ADV_F_DISC_GEN | BLE_HS_ADV_F_BREDR_UNSUP};
    uint16_t appearance_{0};
    std::string manufacturer_data_;
    std::vector<std::string> service_uuids_;
    std::map<std::string, std::string> service_data_map_;
};

// --- BlePeripheralImpl Method Definitions ---

BlePeripheral::BlePeripheralImpl::CharacteristicInfo* BlePeripheral::BlePeripheralImpl::FindCharacteristic(const std::string& uuid) {
    for (auto& servicePair : serviceCharTable_) {
        auto it = servicePair.second.find(uuid);
        if (it != servicePair.second.end()) {
            return &it->second;
        }
    }
    NIMBLE_LOGW("BLE_PERIPHERAL", "Characteristic %s not found", uuid.c_str());
    return nullptr;
}

void BlePeripheral::BlePeripheralImpl::RebuildAndApplyAdvertisingData() {
    auto adv_data = NimBLEAdvertisementData();
    adv_data.setFlags(adv_flags_);

    if (appearance_ != 0) {
        adv_data.setAppearance(appearance_);
    }
    if (!manufacturer_data_.empty()) {
        adv_data.setManufacturerData(manufacturer_data_);
    }
    for (const auto& uuid : service_uuids_) {
        adv_data.addServiceUUID(uuid);
    }
    for (const auto& pair : service_data_map_) {
        adv_data.setServiceData(pair.first, pair.second);
    }

    auto scan_resp_data = NimBLEAdvertisementData();
    scan_resp_data.setName(device_name_);

    if (!pAdvertising_) {
        return;
    }

    bool is_advertising = pAdvertising_->isAdvertising();
    if (is_advertising) {
        pAdvertising_->stop();
    }

    pAdvertising_->setAdvertisementData(adv_data);
    pAdvertising_->setScanResponseData(scan_resp_data);

    if (is_advertising) {
        pAdvertising_->start();
    }
}

void BlePeripheral::BlePeripheralImpl::SetDesiredMtu(uint16_t mtu) {
    if (initialized_) {
        NIMBLE_LOGW("BLE_PERIPHERAL", "SetDesiredMtu must be called before Init().");
        return;
    }
    desired_mtu_ = mtu;
}

void BlePeripheral::BlePeripheralImpl::Init(const std::string& device_name) {
    if (initialized_) {
        NIMBLE_LOGW("BLE_PERIPHERAL", "Already initialized");
        return;
    }
    NIMBLE_LOGI("BLE_PERIPHERAL", "Initializing with device name: %s", device_name.c_str());
    device_name_ = device_name; 
    NimBLEDevice::init(device_name_);
    NimBLEDevice::setMTU(desired_mtu_);
    NimBLEDevice::setPower(ESP_PWR_LVL_P9);

    pServer_ = NimBLEDevice::createServer();
    pServer_->setCallbacks(&server_callbacks_);

    pAdvertising_ = NimBLEDevice::getAdvertising();
    if (pAdvertising_) {
        pAdvertising_->enableScanResponse(true);
        RebuildAndApplyAdvertisingData(); 
    }

    initialized_ = true;
    state_ = BleState::kIdle;
}

void BlePeripheral::BlePeripheralImpl::RegisterService(
    const std::string& service_uuid,
    const std::vector<std::tuple<std::string, uint32_t, BlePeripheral::CharCallback>>& characteristics) {
    if (!pServer_) {
        NIMBLE_LOGE("BLE_PERIPHERAL", "Server not initialized. Call Init() first.");
        return;
    }
    NIMBLE_LOGI("BLE_PERIPHERAL", "Registering service: %s", service_uuid.c_str());
    NimBLEService* pService = pServer_->createService(service_uuid);

    for (const auto& [char_uuid, properties, callback] : characteristics) {
        NimBLECharacteristic* pChar = pService->createCharacteristic(char_uuid, properties);
        pChar->setCallbacks(&char_callbacks_);
        serviceCharTable_[service_uuid][char_uuid] = {properties, callback, pChar};
        NIMBLE_LOGD("BLE_PERIPHERAL", "  - Characteristic: %s", char_uuid.c_str());
    }
    pService->start();
}

void BlePeripheral::BlePeripheralImpl::SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, NotificationType notification_type) {
    auto* char_info = FindCharacteristic(char_uuid);
    if (!char_info || !char_info->pCharHandle) {
        return;
    }

    char_info->pCharHandle->setValue(static_cast<const uint8_t*>(value), size);

    if (notification_type == NotificationType::kNone || state_ != BleState::kConnected) {
        return;
    }

    if (notification_type == NotificationType::kNotify) {
        if (char_info->properties & CharProperty::kNotify) {
            char_info->pCharHandle->notify();
        } else {
            NIMBLE_LOGW("BLE_PERIPHERAL", "Attempted to notify on characteristic %s which does not support it.", char_uuid.c_str());
        }
    } else if (notification_type == NotificationType::kIndicate) {
        if (char_info->properties & CharProperty::kIndicate) {
            char_info->pCharHandle->indicate();
        } else {
            NIMBLE_LOGW("BLE_PERIPHERAL", "Attempted to indicate on characteristic %s which does not support it.", char_uuid.c_str());
        }
    }
}

void BlePeripheral::BlePeripheralImpl::SetAppearance(uint16_t appearance) {
    appearance_ = appearance;
    RebuildAndApplyAdvertisingData();
}

void BlePeripheral::BlePeripheralImpl::AddServiceUuid(const std::string& uuid) {
    if (std::find(service_uuids_.begin(), service_uuids_.end(), uuid) == service_uuids_.end()) {
        service_uuids_.push_back(uuid);
    }
    RebuildAndApplyAdvertisingData();
}

void BlePeripheral::BlePeripheralImpl::SetServiceData(const std::string& service_uuid, const std::string& data) {
    service_data_map_[service_uuid] = data;
    RebuildAndApplyAdvertisingData();
}

void BlePeripheral::BlePeripheralImpl::SetManufacturerData(const std::string& data) {
    manufacturer_data_ = data;
    RebuildAndApplyAdvertisingData();
}

void BlePeripheral::BlePeripheralImpl::SetRawAdvertisingData(const std::string& data) {
    auto adv_data = NimBLEAdvertisementData();
    adv_data.addData(data);
    pAdvertising_->setAdvertisementData(adv_data);
}

void BlePeripheral::BlePeripheralImpl::SetRawScanResponseData(const std::string& data) {
    auto scan_resp_data = NimBLEAdvertisementData();
    scan_resp_data.addData(data);
    pAdvertising_->setScanResponseData(scan_resp_data);
}

void BlePeripheral::BlePeripheralImpl::ClearAdvertisingData(bool clear_scan_response) {
    appearance_ = 0;
    manufacturer_data_.clear();
    service_uuids_.clear();
    service_data_map_.clear();
    
    RebuildAndApplyAdvertisingData();
}

void BlePeripheral::BlePeripheralImpl::StartLegacyAdvertising(bool connectable, uint16_t interval_ms) {
    if (!pAdvertising_) return;
    NIMBLE_LOGI("BLE_PERIPHERAL", "Starting legacy advertising...");
    pAdvertising_->setConnectableMode(connectable ? BLE_GAP_CONN_MODE_UND : BLE_GAP_CONN_MODE_NON);
    uint16_t interval_units = interval_ms / 0.625;
    pAdvertising_->setMinInterval(interval_units);
    pAdvertising_->setMaxInterval(interval_units);
    
    RebuildAndApplyAdvertisingData();
    
    pAdvertising_->start();
    state_ = BleState::kAdvertising;
}

#if ENABLE_BLE5_FEATURES
void BlePeripheral::BlePeripheralImpl::StartExtendedAdvertising(bool connectable, uint16_t interval_ms) {
    if (!pAdvertising_) return;
    NIMBLE_LOGI("BLE_PERIPHERAL", "Starting extended advertising...");
    pAdvertising_->setConnectableMode(connectable ? BLE_GAP_CONN_MODE_UND : BLE_GAP_CONN_MODE_NON);
    
    uint16_t interval_units = interval_ms / 0.625;
    pAdvertising_->setMinInterval(interval_units);
    pAdvertising_->setMaxInterval(interval_units);

    RebuildAndApplyAdvertisingData();

    pAdvertising_->start(0, 0, 0);
    state_ = BleState::kAdvertising;
}

void BlePeripheral::BlePeripheralImpl::SetDefaultPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask) {
    NIMBLE_LOGI("BLE_PERIPHERAL", "Setting default PHY for new connections: TX=%d, RX=%d", tx_phys_mask, rx_phys_mask);
    NimBLEDevice::setDefaultPhy(static_cast<esp_ble_phy_t>(tx_phys_mask), static_cast<esp_ble_phy_t>(rx_phys_mask));
}
#endif

void BlePeripheral::BlePeripheralImpl::StopAdvertising() {
    if (pAdvertising_ && pAdvertising_->isAdvertising()) {
        NIMBLE_LOGI("BLE_PERIPHERAL", "Stopping advertising");
        pAdvertising_->stop();
        if (state_ == BleState::kAdvertising) {
            state_ = BleState::kIdle;
        }
    }
}

void BlePeripheral::BlePeripheralImpl::Disconnect() {
    if (pServer_ && state_ == BleState::kConnected) {
        auto connected_peers = pServer_->getPeerDevices();
        if (!connected_peers.empty()) {
            uint16_t conn_id = connected_peers.begin()->first;
            NIMBLE_LOGI("BLE_PERIPHERAL", "Requesting disconnect from client with ConnID: %d", conn_id);
            pServer_->disconnect(conn_id);
        }
    }
}

// --- BlePeripheral Public Method Forwarding ---
BlePeripheral::BlePeripheral() : impl_(std::make_unique<BlePeripheralImpl>()) {}
BlePeripheral::~BlePeripheral() = default;

void BlePeripheral::SetDesiredMtu(uint16_t mtu) { impl_->SetDesiredMtu(mtu); }
void BlePeripheral::Init(const std::string& device_name) { impl_->Init(device_name); }
void BlePeripheral::RegisterService(const std::string& service_uuid, const std::vector<std::tuple<std::string, uint32_t, CharCallback>>& characteristics) {
    impl_->RegisterService(service_uuid, characteristics);
}
void BlePeripheral::SetCharacteristicValue(const std::string& char_uuid, const void* value, size_t size, NotificationType notification_type) {
    impl_->SetCharacteristicValue(char_uuid, value, size, notification_type);
}
void BlePeripheral::SetAppearance(uint16_t appearance) { impl_->SetAppearance(appearance); }
void BlePeripheral::AddServiceUuid(const std::string& uuid) { impl_->AddServiceUuid(uuid); }
void BlePeripheral::SetServiceData(const std::string &service_uuid, const uint8_t* data, size_t size) {
    impl_->SetServiceData(service_uuid, std::string(reinterpret_cast<const char*>(data), size));
}
void BlePeripheral::SetServiceData(const std::string &service_uuid, const std::vector<uint8_t>& data) {
    impl_->SetServiceData(service_uuid, std::string(data.begin(), data.end()));
}
void BlePeripheral::SetManufacturerData(const uint8_t* data, size_t size) {
    impl_->SetManufacturerData(std::string(reinterpret_cast<const char*>(data), size));
}
void BlePeripheral::SetManufacturerData(const std::vector<uint8_t>& data) {
    impl_->SetManufacturerData(std::string(data.begin(), data.end()));
}
void BlePeripheral::SetRawAdvertisingData(const uint8_t* data, size_t size) {
    impl_->SetRawAdvertisingData(std::string(reinterpret_cast<const char*>(data), size));
}
void BlePeripheral::SetRawAdvertisingData(const std::vector<uint8_t>& data) {
    impl_->SetRawAdvertisingData(std::string(data.begin(), data.end()));
}
void BlePeripheral::SetRawScanResponseData(const uint8_t* data, size_t size) {
    impl_->SetRawScanResponseData(std::string(reinterpret_cast<const char*>(data), size));
}
void BlePeripheral::SetRawScanResponseData(const std::vector<uint8_t>& data) {
    impl_->SetRawScanResponseData(std::string(data.begin(), data.end()));
}
void BlePeripheral::ClearAdvertisingData(bool clear_scan_response) { impl_->ClearAdvertisingData(clear_scan_response); }
void BlePeripheral::StartLegacyAdvertising(bool connectable, uint16_t interval_ms) { impl_->StartLegacyAdvertising(connectable, interval_ms); }
#if ENABLE_BLE5_FEATURES
void BlePeripheral::StartExtendedAdvertising(bool connectable, uint16_t interval_ms) { impl_->StartExtendedAdvertising(connectable, interval_ms); }
void BlePeripheral::SetDefaultPhy(uint8_t tx_phys_mask, uint8_t rx_phys_mask) { impl_->SetDefaultPhy(tx_phys_mask, rx_phys_mask); }
#endif
void BlePeripheral::StopAdvertising() { impl_->StopAdvertising(); }
void BlePeripheral::Disconnect() { impl_->Disconnect(); }
void BlePeripheral::SetConnectionCallback(std::function<void()> callback) { impl_->SetConnectionCallback(std::move(callback)); }
void BlePeripheral::SetDisconnectionCallback(std::function<void()> callback) { impl_->SetDisconnectionCallback(std::move(callback)); }
void BlePeripheral::SetMtuChangedCallback(MtuChangedCallback callback) { impl_->SetMtuChangedCallback(std::move(callback)); }
BlePeripheral::BleState BlePeripheral::GetState() const { return impl_->GetState(); }

} // namespace connectivity
} // namespace platform
#include <iostream>
#include <string>
#include <vector>
#include <chrono>   // For std::chrono
#include <thread>   // For std::this_thread
#include "ble_peripheral.h" // Include the header for our class

// For a real ESP32 project, you would include these for logging and delays
// #include "esp_log.h"
// #include "freertos/FreeRTOS.h"
// #include "freertos/task.h"

// Use our class from the platform::connectivity namespace
using platform::connectivity::BlePeripheral;

// Create an instance of our peripheral
BlePeripheral ble_peripheral;

// Main application entry point
// In an ESP-IDF project, this would be `extern "C" void app_main(void)`
int main() {
    std::cout << "BLE Peripheral - Dynamic Raw Byte Service Data Example" << std::endl;

    // 1. Initialize the peripheral
    ble_peripheral.Init("Dynamic-Data-Device");

    // 2. Define the UUID for the service data we will update
    const std::string service_data_uuid = "00001234-0000-1000-8000-00805f9b34fb";
    
    // 3. Set some initial service data using a raw byte array
    uint8_t initial_data[] = {0x01, 0x02, 0x03}; // Example initial bytes
    std::cout << "Setting initial service data using raw bytes." << std::endl;
    ble_peripheral.SetServiceData(service_data_uuid, initial_data, sizeof(initial_data));

    // 4. Start advertising
    ble_peripheral.StartLegacyAdvertising();
    std::cout << "Advertising started. Check for 'Dynamic-Data-Device' with a BLE scanner." << std::endl;

    // 5. Main application loop to dynamically update the data
    uint8_t update_counter = 0;
    while (true) {
        // Delay for 5 seconds
        // On ESP32 this would be: vTaskDelay(5000 / portTICK_PERIOD_MS);
        std::this_thread::sleep_for(std::chrono::seconds(5));

        // Prepare the new data as a vector of bytes
        std::vector<uint8_t> new_data_bytes;
        new_data_bytes.push_back(0xDE); // A constant header byte
        new_data_bytes.push_back(0xAD); // Another constant header byte
        new_data_bytes.push_back(update_counter++); // The dynamic counter byte
        
        std::cout << "Updating service data with new byte array. Counter: " << (int)new_data_bytes[2] << std::endl;

        // Use the direct uint8_t* overload.
        ble_peripheral.SetServiceData(service_data_uuid, new_data_bytes.data(), new_data_bytes.size());
    }

    return 0;
}
