// Copyright [2025] [Your Name or Company]
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef APP_UPDATER_H
#define APP_UPDATER_H

#include <cstdint>
#include <functional>
#include <map>
#include <memory>
#include <string>
#include <cstdio> // For snprintf in StatusToString

namespace platform {

/**
 * @class AppUpdater
 * @brief Public interface for a platform-agnostic Application Updater.
 *
 * This class uses the PIMPL idiom to provide a stable, clean interface,
 * completely hiding the underlying platform-specific implementation details.
 * It is designed to be instantiated directly, e.g., `platform::AppUpdater my_updater;`.
 */
class AppUpdater {
public:
  // --- Public Nested Types for a Clean, Scoped API ---

  /** @enum Status
   * @brief Defines the possible status codes for update operations.
   */
  enum class Status {
    kSuccess,                  ///< The operation completed successfully.
    kErrorAlreadyInProgress,   ///< An update is already in progress.
    kErrorNotIdle,             ///< An operation was attempted when the updater was not idle.
    kErrorInvalidState,        ///< An operation was attempted in an invalid state.
    kErrorMetadataInvalid,     ///< The provided firmware metadata is invalid or mismatched (e.g., chip ID).
    kErrorPartitionNotFound,   ///< A suitable OTA partition could not be found.
    kErrorOtaBeginFailed,      ///< The platform's underlying 'begin' operation failed.
    kErrorWriteFailed,         ///< Writing a firmware chunk to flash failed.
    kErrorImageSizeMismatch,   ///< The total bytes written does not match the expected size (if size was known).
    kErrorOtaEndFailed,        ///< The platform's 'end' operation failed (e.g., image validation, chip compatibility).
    kErrorSetBootPartitionFailed, ///< Failed to set the new partition as the next boot target.
    kErrorRebootFailed,        ///< The command to reboot the device failed.
    kErrorInvalidArgument,     ///< An invalid argument was provided to a method.
    kErrorCancelled,           ///< The operation was cancelled by the user or Reset().
    kErrorTimeout,             ///< The session timed out due to inactivity.
    kErrorVersionIdentical,    ///< New version is identical to the current version, and same-version flashing is disallowed.
    kErrorGeneric,             ///< A generic, unspecified error occurred.
  };

  /** @struct Metadata
   * @brief Describes the firmware image being updated.
   * `image_size` can be 0 if the total size is unknown at the start of the update.
   * `target_platform_identifier` is an OPTIONAL hint for an early compatibility check
   * in Begin(). A mandatory, more robust chip check against the image header
   * occurs during the first Write() call, and a final one during End().
   */
  struct Metadata {
    size_t image_size = 0;                        ///< Total size of the firmware image in bytes. 0 for unknown.
    std::string version_string;                   ///< Version of the new firmware (e.g., "1.2.3").
    std::string target_platform_identifier;       ///< Optional: Expected platform (e.g., "ESP32S3") for an early check.
    std::map<std::string, std::string> custom_fields; ///< For application-specific metadata.
  };

  /** @struct BeginConfig
   * @brief Configuration options for beginning an update session.
   */
  struct BeginConfig {
    uint32_t inactivity_timeout_ms = 60000; ///< Timeout in ms. 0 to disable. Default 60 seconds.
    bool allow_same_version = false;       ///< If false, Begin() will fail if new version matches current.
  };

  /** @enum State
   * @brief Represents the internal operational state of the updater.
   */
  enum class State {
    kIdle,          ///< Not performing an update. Ready to begin.
    kPreparing,     ///< Initializing partitions and resources.
    kReceivingData, ///< Actively writing firmware data.
    kFinalizing,    ///< Finalizing the write and validating the image.
    kReadyToApply,  ///< The new firmware is valid and ready to be booted.
    kApplying,      ///< Setting the boot partition and preparing to reboot.
    kError          ///< An error occurred. Call Reset() to return to idle.
  };

  /** @struct PartitionInfo
   * @brief Provides details about a flash memory partition.
   */
  struct PartitionInfo {
    std::string label;        ///< The label or name of the partition.
    uint32_t type_id = 0;     ///< Platform-specific type identifier.
    uint32_t subtype_id = 0;  ///< Platform-specific subtype identifier.
    size_t address = 0;       ///< Starting address of the partition.
    size_t size = 0;          ///< Size of the partition in bytes.
    bool is_encrypted = false;///< True if the partition is encrypted.
    bool is_valid = false;    ///< True if this struct contains valid data.
  };

  /**
   * @brief Converts a Status enum to a human-readable string.
   * @param status The status code to convert.
   * @return A constant string representation of the status.
   */
  static const char* StatusToString(Status status);

  /**
   * @brief Constructs an AppUpdater instance, ready in an idle state.
   */
  AppUpdater();

  /**
   * @brief Destructor. Ensures safe cleanup of the implementation.
   * Its definition is in the .cpp file, which is required for the PIMPL idiom.
   */
  ~AppUpdater();

  // --- Move Semantics (defined in .cpp to support PIMPL) ---
  AppUpdater(AppUpdater&&) noexcept;
  AppUpdater& operator=(AppUpdater&&) noexcept;

  // --- Copying is disabled to prevent slicing and ownership issues ---
  AppUpdater(const AppUpdater&) = delete;
  AppUpdater& operator=(const AppUpdater&) = delete;

  /**
   * @brief Registers a custom callback function to be executed on reset.
   * This is useful for application-level cleanup (e.g., closing sockets,
   * updating UI state) when an update is reset, cancelled, or aborted due to error/timeout.
   * @param hook The function to call. Pass an empty function or `nullptr` to clear the hook.
   */
  void SetResetHook(std::function<void()> hook);

  /**
   * @brief Begins an update session.
   * @param metadata The metadata for the incoming firmware.
   * @param config Configuration options for the update session (timeout, version check).
   * @return Status code indicating success or failure.
   */
  Status Begin(const Metadata& metadata, const BeginConfig& config = {});

  /**
   * @brief Writes a chunk of firmware data.
   * Resets the inactivity timer on each successful call.
   * Performs a chip compatibility check against the image header on the first write.
   * @param data Pointer to the data buffer.
   * @param size The size of the data buffer in bytes.
   * @return Status code indicating success or failure.
   */
  Status Write(const uint8_t* data, size_t size);

  /**
   * @brief Finalizes the update process after all data has been written.
   * This typically involves the platform verifying the image signature and integrity.
   * @return Status code indicating success or failure.
   */
  Status End();

  /**
   * @brief Applies the update by setting the boot partition and rebooting.
   * @param pre_restart_hook An optional function for last-minute cleanup
   * before the device reboots.
   * @return This function should not return on success, as the device will reboot.
   * A returned status indicates a failure to apply the update.
   */
  Status Apply(std::function<void()> pre_restart_hook = nullptr);

  /**
   * @brief Explicitly aborts any ongoing operation and resets the updater to the idle state.
   * Executes the registered reset hook after internal cleanup.
   */
  void Reset();

  /** @return The current operational state of the updater. */
  State GetState() const;

  /** @return A string describing the last error that occurred. */
  std::string GetLastError() const;

  /** @return The total number of bytes successfully written in the current session. */
  size_t GetBytesWritten() const;

  /** @return A structure with details about the currently running partition. */
  PartitionInfo GetRunningPartitionInfo() const;

  /** @return A structure with details about the partition that will boot next. */
  PartitionInfo GetNextBootPartitionInfo() const;

  /**
   * @brief Marks the currently running application as valid, cancelling any pending OTA rollback.
   *
   * This function should be called by the **newly booted application** after it has performed
   * its own health checks and determined it is running correctly.
   *
   * If OTA rollback is not enabled in Kconfig, this function typically has no effect but is safe to call.
   * It checks the current app's OTA state and only proceeds with marking if validation is pending.
   *
   * @return Status::kSuccess if the operation was successful or no action was needed.
   * Returns an error status if a problem occurred while trying to mark the app as valid.
   */
  static Status MarkBootSuccessful();

private:
  // Forward-declare the private implementation class.
  class PlatformUpdater;

  // The pointer to implementation.
  std::unique_ptr<PlatformUpdater> impl_;
};

} // namespace platform

#endif // APP_UPDATER_H
--------------------------------------------------------------------------------------------------------------

// Copyright [2025] [Your Name or Company]
// (Apache License header as before)

#include "app_updater.h"

// --- Platform-Specific Includes (Completely hidden from clients) ---
#include <algorithm> // For std::min if needed
#include <cstring>   // For strncpy, strlen etc.
#include "esp_app_format.h"
#include "esp_chip_info.h"
#include "esp_log.h"
#include "esp_ota_ops.h"
#include "esp_partition.h"
#include "esp_system.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"    // For xTaskGetTickCount

// OTA_SIZE_UNKNOWN is used by esp_ota_begin when image size is not known.
#ifndef OTA_SIZE_UNKNOWN
#define OTA_SIZE_UNKNOWN 0xFFFFFFFF
#endif

namespace platform {

// --- Anonymous namespace for helpers local to this implementation file ---
namespace {

const char* kImplTag = "PlatformUpdater"; // Tag for ESP_LOG in the PIMPL class

// Helper to convert ESP chip model to string
std::string ChipModelToString(esp_chip_model_t model) {
  switch (model) {
    case CHIP_ESP32: return "ESP32";
    case CHIP_ESP32S2: return "ESP32S2";
    case CHIP_ESP32S3: return "ESP32S3";
    case CHIP_ESP32C3: return "ESP32C3";
    case CHIP_ESP32H2: return "ESP32H2";
    case CHIP_ESP32C2: return "ESP32C2";
    case CHIP_ESP32C6: return "ESP32C6";
    // Add other chips as needed
    default:
      char unknown_chip_buf[30];
      snprintf(unknown_chip_buf, sizeof(unknown_chip_buf), "UNKNOWN_CHIP_ID(%d)", static_cast<int>(model));
      return std::string(unknown_chip_buf);
  }
}

// Helper to convert esp_partition_t to the public PartitionInfo struct
AppUpdater::PartitionInfo ToPartitionInfo(const esp_partition_t* esp_part) {
    AppUpdater::PartitionInfo info;
    if (esp_part) {
        if(esp_part->label[0] != '\0') { // Check if label is not empty before using strncpy
            info.label.assign(esp_part->label);
        }
        info.type_id = esp_part->type;
        info.subtype_id = esp_part->subtype;
        info.address = esp_part->address;
        info.size = esp_part->size;
        info.is_encrypted = esp_part->encrypted;
        info.is_valid = true;
    } else {
        info.is_valid = false;
    }
    return info;
}

} // anonymous namespace


/**
 * @class AppUpdater::PlatformUpdater
 * @brief The private implementation class for the AppUpdater.
 * This class contains all state and platform-specific logic for the ESP-IDF platform.
 */
class AppUpdater::PlatformUpdater {
public:
  PlatformUpdater() { ResetInternalState(); }
  ~PlatformUpdater() {
    // Ensure any active OTA operation is aborted if the updater is destroyed.
    if (ota_handle_ != 0) {
      ESP_LOGW(kImplTag, "Destructor: Aborting active OTA handle %p.", (void*)ota_handle_);
      esp_ota_abort(ota_handle_);
      // user_reset_hook_ is not called here as this is object destruction, not a logical Reset().
    }
  }

  void SetResetHook(std::function<void()> hook) { user_reset_hook_ = hook; }
  AppUpdater::Status Begin(const AppUpdater::Metadata& metadata, const AppUpdater::BeginConfig& config);
  AppUpdater::Status Write(const uint8_t* data, size_t size);
  AppUpdater::Status End();
  AppUpdater::Status Apply(std::function<void()> pre_restart_hook);
  void Reset();

  AppUpdater::State GetState() const { return current_state_; }
  std::string GetLastError() const { return last_error_message_; }
  size_t GetBytesWritten() const { return bytes_written_; }
  AppUpdater::PartitionInfo GetRunningPartitionInfo() const;
  AppUpdater::PartitionInfo GetNextBootPartitionInfo() const;

private:
  void SetState(AppUpdater::State new_state);
  void SetErrorAndAbort(const std::string& error_message, AppUpdater::Status status_code, esp_err_t esp_idf_err = ESP_OK);
  void ResetInternalState(); // Resets internal variables, DOES NOT call user hook or abort OTA handle here
  bool CheckInactivityTimeout();

  // Platform-specific state
  esp_ota_handle_t ota_handle_ = 0;
  const esp_partition_t* update_partition_ = nullptr;

  // Generic operational state
  AppUpdater::State current_state_ = AppUpdater::State::kIdle;
  std::string last_error_message_;
  size_t bytes_written_ = 0;
  size_t total_image_size_ = 0; // From metadata; OTA_SIZE_UNKNOWN if not provided

  // Timeout state
  uint32_t inactivity_timeout_ms_ = 0;
  uint64_t last_activity_timestamp_ms_ = 0; // Using FreeRTOS tick count in ms

  // User callback
  std::function<void()> user_reset_hook_;

  // Chip check flag
  bool chip_check_performed_on_write_ = false;
};

// --- Implementation of PlatformUpdater methods ---

void AppUpdater::PlatformUpdater::ResetInternalState() {
    // This function resets the internal state variables of the PlatformUpdater.
    // It does NOT abort an active ota_handle_ here; that should be done by the
    // calling function (like Reset(), SetErrorAndAbort(), or Begin()) before calling this.
    // It also does NOT call the user_reset_hook_.
    update_partition_ = nullptr;
    current_state_ = AppUpdater::State::kIdle;
    last_error_message_.clear();
    bytes_written_ = 0;
    total_image_size_ = 0;
    inactivity_timeout_ms_ = 0;
    last_activity_timestamp_ms_ = 0;
    chip_check_performed_on_write_ = false;
    // ota_handle_ is explicitly managed by functions that start/stop OTA operations.
}

void AppUpdater::PlatformUpdater::SetState(AppUpdater::State new_state) {
    ESP_LOGD(kImplTag, "State transition from %d to %d", static_cast<int>(current_state_), static_cast<int>(new_state));
    current_state_ = new_state;
}

void AppUpdater::PlatformUpdater::SetErrorAndAbort(const std::string& msg, AppUpdater::Status status_code, esp_err_t err) {
    last_error_message_ = msg;
    if (err != ESP_OK) { // ESP_OK might mean the error is purely logical, not from an ESP-IDF call
        last_error_message_ += " (Platform Error: " + std::string(esp_err_to_name(err)) + ")";
    }
    ESP_LOGE(kImplTag, "Error set: %s", last_error_message_.c_str());

    if (ota_handle_ != 0) {
        ESP_LOGW(kImplTag, "Aborting active OTA handle %p due to error.", (void*)ota_handle_);
        esp_ota_abort(ota_handle_);
        ota_handle_ = 0;
    }
    SetState(AppUpdater::State::kError);
    // The user_reset_hook_ is called by the public Reset() method or if timeout triggers it.
    // If an error occurs, the user might call Reset() which then calls the hook.
}

bool AppUpdater::PlatformUpdater::CheckInactivityTimeout() {
    if (inactivity_timeout_ms_ == 0) return true; // Timeout disabled

    // Only check timeout if we are in a state where data is expected
    if (current_state_ != AppUpdater::State::kReceivingData) return true;

    uint64_t now_ms = pdTICKS_TO_MS(xTaskGetTickCount());
    if ((now_ms - last_activity_timestamp_ms_) > inactivity_timeout_ms_) {
        SetErrorAndAbort("OTA session timed out due to inactivity.", AppUpdater::Status::kErrorTimeout);
        if (user_reset_hook_) {
             ESP_LOGI(kImplTag, "Executing user-provided reset hook due to timeout.");
             user_reset_hook_();
        }
        return false; // Timed out
    }
    return true; // OK
}

AppUpdater::Status AppUpdater::PlatformUpdater::Begin(const AppUpdater::Metadata& metadata, const AppUpdater::BeginConfig& config) {
    if (current_state_ != AppUpdater::State::kIdle) {
      SetErrorAndAbort("Begin: Updater is not idle.", AppUpdater::Status::kErrorNotIdle);
      return AppUpdater::Status::kErrorNotIdle;
    }
    // ResetInternalState is called by the public Reset which is called by this public Begin
    // This ResetInternalState is for PlatformUpdater internal state
    ResetInternalState(); // Clears previous state, including chip_check_performed_on_write_

    SetState(AppUpdater::State::kPreparing);
    ESP_LOGI(kImplTag, "Begin OTA. Same version: %s. Timeout: %u ms. Optional target platform: '%s'",
             config.allow_same_version ? "Allowed" : "Disallowed",
             config.inactivity_timeout_ms,
             metadata.target_platform_identifier.c_str());

    inactivity_timeout_ms_ = config.inactivity_timeout_ms;
    if (inactivity_timeout_ms_ > 0) {
        last_activity_timestamp_ms_ = pdTICKS_TO_MS(xTaskGetTickCount());
    }

    // 1. Version Check (Pre-flight based on app-provided metadata)
    if (!config.allow_same_version) {
        const esp_app_desc_t* running_app_info = esp_app_get_description();
        if (running_app_info && !metadata.version_string.empty() &&
            metadata.version_string == running_app_info->version) {
            SetErrorAndAbort("New version is the same as the currently running version.", AppUpdater::Status::kErrorVersionIdentical);
            return AppUpdater::Status::kErrorVersionIdentical;
        }
    }

    // 2. OPTIONAL Target Platform Identifier Check (Very Early Pre-flight from metadata)
    if (!metadata.target_platform_identifier.empty()) {
        esp_chip_info_t current_chip_info;
        esp_chip_info(&current_chip_info);
        std::string current_chip_str = ChipModelToString(current_chip_info.model);
        if (metadata.target_platform_identifier != current_chip_str) {
            char err_msg[200];
            snprintf(err_msg, sizeof(err_msg),
                     "Metadata target platform ('%s') does not match current chip ('%s').",
                     metadata.target_platform_identifier.c_str(), current_chip_str.c_str());
            SetErrorAndAbort(err_msg, AppUpdater::Status::kErrorMetadataInvalid);
            return AppUpdater::Status::kErrorMetadataInvalid;
        }
        ESP_LOGI(kImplTag, "Optional metadata platform check passed for '%s'.", current_chip_str.c_str());
    } else {
        ESP_LOGI(kImplTag, "No target_platform_identifier in metadata; chip compatibility will be checked on first Write().");
    }

    update_partition_ = esp_ota_get_next_update_partition(nullptr);
    if (update_partition_ == nullptr) {
        SetErrorAndAbort("No valid OTA update partition found.", AppUpdater::Status::kErrorPartitionNotFound);
        return AppUpdater::Status::kErrorPartitionNotFound;
    }
    ESP_LOGI(kImplTag, "Using OTA partition: %s", update_partition_->label);

    total_image_size_ = (metadata.image_size == 0 || metadata.image_size == OTA_SIZE_UNKNOWN)
                        ? OTA_SIZE_UNKNOWN
                        : metadata.image_size;
    ESP_LOGI(kImplTag, "Attempting to begin OTA with image size: 0x%zx (OTA_SIZE_UNKNOWN if 0xFFFFFFFF)", total_image_size_);

    esp_err_t err = esp_ota_begin(update_partition_, total_image_size_, &ota_handle_);
    if (err != ESP_OK) {
        SetErrorAndAbort("esp_ota_begin failed.", AppUpdater::Status::kErrorOtaBeginFailed, err);
        ota_handle_ = 0; // Ensure handle is zero on failure
        update_partition_ = nullptr;
        return AppUpdater::Status::kErrorOtaBeginFailed;
    }
    ESP_LOGI(kImplTag, "esp_ota_begin succeeded. OTA Handle: %p", (void*)ota_handle_);
    SetState(AppUpdater::State::kReceivingData);
    return AppUpdater::Status::kSuccess;
}

AppUpdater::Status AppUpdater::PlatformUpdater::Write(const uint8_t* data, size_t size) {
    if (current_state_ != AppUpdater::State::kReceivingData) {
        // This state check is important. Don't set error here, let the caller handle the returned status.
        ESP_LOGE(kImplTag, "Write called in invalid state: %d", static_cast<int>(current_state_));
        return AppUpdater::Status::kErrorInvalidState;
    }
    if (!CheckInactivityTimeout()) { // CheckInactivityTimeout calls SetErrorAndAbort if it fails
        return AppUpdater::Status::kErrorTimeout;
    }
    if (data == nullptr && size > 0) {
        SetErrorAndAbort("Write called with null data pointer but non-zero size.", AppUpdater::Status::kErrorInvalidArgument);
        return AppUpdater::Status::kErrorInvalidArgument;
    }
    if (size == 0) {
        ESP_LOGD(kImplTag, "Write called with zero size. No operation.");
        return AppUpdater::Status::kSuccess; // No data to write, but not an error.
    }
     if (ota_handle_ == 0) {
        SetErrorAndAbort("Write called but OTA handle is invalid.", AppUpdater::Status::kErrorInvalidState);
        return AppUpdater::Status::kErrorInvalidState;
    }


    // --- MANDATORY CHIP COMPATIBILITY CHECK ON FIRST WRITE (if not performed by metadata) ---
    if (!chip_check_performed_on_write_) {
        ESP_LOGI(kImplTag, "Performing internal chip compatibility check on first write chunk (size: %zu).", size);
        
        size_t app_desc_offset = sizeof(esp_image_header_t) + sizeof(esp_image_segment_header_t);
        if (bytes_written_ == 0 && size >= app_desc_offset + sizeof(esp_app_desc_t)) {
            const esp_app_desc_t* image_app_desc = reinterpret_cast<const esp_app_desc_t*>(data + app_desc_offset);

            if (image_app_desc->magic_word != ESP_APP_DESC_MAGIC_WORD) {
                SetErrorAndAbort("New firmware image has invalid app description magic word.", AppUpdater::Status::kErrorMetadataInvalid);
                return AppUpdater::Status::kErrorMetadataInvalid;
            }

            esp_chip_info_t current_chip_info;
            esp_chip_info(&current_chip_info);
            
            ESP_LOGD(kImplTag, "Current chip model ID: %d (%s). Image header chip_id: %d.",
                     current_chip_info.model, ChipModelToString(current_chip_info.model).c_str(), image_app_desc->chip_id);
            
            if (image_app_desc->chip_id != current_chip_info.model) {
                char err_msg[200];
                snprintf(err_msg, sizeof(err_msg),
                         "Chip ID mismatch! Current: %s (ID %d), Image for: Chip ID %d.",
                         ChipModelToString(current_chip_info.model).c_str(), current_chip_info.model, image_app_desc->chip_id);
                SetErrorAndAbort(err_msg, AppUpdater::Status::kErrorMetadataInvalid);
                return AppUpdater::Status::kErrorMetadataInvalid;
            }
            ESP_LOGI(kImplTag, "Internal chip compatibility check passed.");
        } else if (bytes_written_ == 0) { // First write, but chunk is too small
            ESP_LOGW(kImplTag, "First data chunk too small (%zu bytes) for immediate chip check. Relying on esp_ota_end().", size);
        }
        chip_check_performed_on_write_ = true; // Mark as attempted/done for subsequent writes
    }

    esp_err_t err = esp_ota_write(ota_handle_, data, size);
    if (err != ESP_OK) {
        SetErrorAndAbort("esp_ota_write failed.", AppUpdater::Status::kErrorWriteFailed, err);
        return AppUpdater::Status::kErrorWriteFailed;
    }
    bytes_written_ += size;
    if (inactivity_timeout_ms_ > 0) {
        last_activity_timestamp_ms_ = pdTICKS_TO_MS(xTaskGetTickCount());
    }
    return AppUpdater::Status::kSuccess;
}

AppUpdater::Status AppUpdater::PlatformUpdater::End() {
    if (current_state_ != AppUpdater::State::kReceivingData) {
        ESP_LOGE(kImplTag, "End called in invalid state: %d", static_cast<int>(current_state_));
        return AppUpdater::Status::kErrorInvalidState;
    }
    if (!CheckInactivityTimeout()) {
        return AppUpdater::Status::kErrorTimeout;
    }
    
    SetState(AppUpdater::State::kFinalizing);
    ESP_LOGI(kImplTag, "Finalizing update. Bytes written: %zu. Expected size: 0x%zx", bytes_written_, total_image_size_);

    if (total_image_size_ != OTA_SIZE_UNKNOWN && bytes_written_ != total_image_size_) {
        char err_msg[150];
        snprintf(err_msg, sizeof(err_msg), "Image size mismatch. Expected 0x%zx, got %zu.", total_image_size_, bytes_written_);
        SetErrorAndAbort(err_msg, AppUpdater::Status::kErrorImageSizeMismatch);
        return AppUpdater::Status::kErrorImageSizeMismatch;
    }
    if (ota_handle_ == 0) { // Should not happen if Begin was successful and not a tiny image handled by Begin already
        SetErrorAndAbort("End called but OTA handle is invalid.", AppUpdater::Status::kErrorInvalidState);
        return AppUpdater::Status::kErrorInvalidState;
    }

    esp_err_t err = esp_ota_end(ota_handle_);
    esp_ota_handle_t temp_handle = ota_handle_; // For logging, as ota_handle_ will be zeroed
    ota_handle_ = 0; // Handle is consumed by esp_ota_end, regardless of success

    if (err != ESP_OK) {
        SetErrorAndAbort("esp_ota_end failed. Image may be invalid or for a different chip.", AppUpdater::Status::kErrorOtaEndFailed, err);
        return AppUpdater::Status::kErrorOtaEndFailed;
    }
    ESP_LOGI(kImplTag, "esp_ota_end succeeded for handle %p. Platform-level validation passed.", (void*)temp_handle);
    SetState(AppUpdater::State::kReadyToApply);
    return AppUpdater::Status::kSuccess;
}

AppUpdater::Status AppUpdater::PlatformUpdater::Apply(std::function<void()> pre_restart_hook) {
    if (current_state_ != AppUpdater::State::kReadyToApply) {
        ESP_LOGE(kImplTag, "Apply called in invalid state: %d", static_cast<int>(current_state_));
        return AppUpdater::Status::kErrorInvalidState;
    }
    if (update_partition_ == nullptr) { // Should have been set by a successful Begin
        SetErrorAndAbort("Apply called but no valid update partition is set.", AppUpdater::Status::kErrorInvalidState);
        return AppUpdater::Status::kErrorInvalidState;
    }

    SetState(AppUpdater::State::kApplying);
    ESP_LOGI(kImplTag, "Applying update to partition: %s", update_partition_->label);

    esp_err_t err = esp_ota_set_boot_partition(update_partition_);
    if (err != ESP_OK) {
        SetErrorAndAbort("esp_ota_set_boot_partition failed.", AppUpdater::Status::kErrorSetBootPartitionFailed, err);
        return AppUpdater::Status::kErrorSetBootPartitionFailed;
    }
    ESP_LOGI(kImplTag, "Boot partition set successfully.");

    if (pre_restart_hook) {
        ESP_LOGI(kImplTag, "Executing pre-restart hook...");
        pre_restart_hook();
        ESP_LOGI(kImplTag, "Pre-restart hook finished.");
    }

    ESP_LOGI(kImplTag, "Rebooting device now...");
    esp_restart();
    // Should not be reached
    SetErrorAndAbort("esp_restart was called but device did not reboot.", AppUpdater::Status::kErrorRebootFailed);
    return AppUpdater::Status::kErrorRebootFailed;
}

void AppUpdater::PlatformUpdater::Reset() {
    ESP_LOGW(kImplTag, "PlatformUpdater::Reset called. Current state: %d", static_cast<int>(current_state_));
    if (ota_handle_ != 0) {
        ESP_LOGI(kImplTag, "Aborting active OTA handle %p during reset.", (void*)ota_handle_);
        esp_ota_abort(ota_handle_);
        ota_handle_ = 0;
    }
    ResetInternalState(); // Resets all other internal state variables

    if (user_reset_hook_) {
        ESP_LOGI(kImplTag, "Executing user-provided reset hook.");
        user_reset_hook_();
    }
}

AppUpdater::PartitionInfo AppUpdater::PlatformUpdater::GetRunningPartitionInfo() const {
    return ToPartitionInfo(esp_ota_get_running_partition());
}

AppUpdater::PartitionInfo AppUpdater::PlatformUpdater::GetNextBootPartitionInfo() const {
    return ToPartitionInfo(esp_ota_get_boot_partition());
}

// --- Public AppUpdater methods forwarding to the implementation ---

AppUpdater::AppUpdater() : impl_(std::make_unique<PlatformUpdater>()) {}
AppUpdater::~AppUpdater() = default; // Definition in .cpp is key for PIMPL with unique_ptr
AppUpdater::AppUpdater(AppUpdater&&) noexcept = default; // Definition in .cpp
AppUpdater& AppUpdater::operator=(AppUpdater&&) noexcept = default; // Definition in .cpp

// --- Static Method Definition ---
const char* AppUpdater::StatusToString(AppUpdater::Status status) {
  static char unknown_buf[40]; // Increased buffer size slightly
  switch (status) {
    case AppUpdater::Status::kSuccess: return "SUCCESS";
    case AppUpdater::Status::kErrorAlreadyInProgress: return "ERROR_ALREADY_IN_PROGRESS";
    case AppUpdater::Status::kErrorNotIdle: return "ERROR_NOT_IDLE";
    case AppUpdater::Status::kErrorInvalidState: return "ERROR_INVALID_STATE";
    case AppUpdater::Status::kErrorMetadataInvalid: return "ERROR_METADATA_INVALID";
    case AppUpdater::Status::kErrorPartitionNotFound: return "ERROR_PARTITION_NOT_FOUND";
    case AppUpdater::Status::kErrorOtaBeginFailed: return "ERROR_OTA_BEGIN_FAILED";
    case AppUpdater::Status::kErrorWriteFailed: return "ERROR_WRITE_FAILED";
    case AppUpdater::Status::kErrorImageSizeMismatch: return "ERROR_IMAGE_SIZE_MISMATCH";
    case AppUpdater::Status::kErrorOtaEndFailed: return "ERROR_OTA_END_FAILED";
    case AppUpdater::Status::kErrorSetBootPartitionFailed: return "ERROR_SET_BOOT_PARTITION_FAILED";
    case AppUpdater::Status::kErrorRebootFailed: return "ERROR_REBOOT_FAILED";
    case AppUpdater::Status::kErrorInvalidArgument: return "ERROR_INVALID_ARGUMENT";
    case AppUpdater::Status::kErrorCancelled: return "ERROR_CANCELLED";
    case AppUpdater::Status::kErrorTimeout: return "ERROR_TIMEOUT";
    case AppUpdater::Status::kErrorVersionIdentical: return "ERROR_VERSION_IDENTICAL";
    case AppUpdater::Status::kErrorGeneric: return "ERROR_GENERIC";
    default:
      snprintf(unknown_buf, sizeof(unknown_buf), "UNKNOWN_STATUS_CODE(%d)", static_cast<int>(status));
      return unknown_buf;
  }
}

AppUpdater::Status AppUpdater::MarkBootSuccessful() {
    ESP_LOGI("AppUpdater", "Static MarkBootSuccessful: Attempting to mark current boot as successful.");
    const esp_partition_t *running_partition = esp_ota_get_running_partition();
    if (!running_partition) {
        ESP_LOGE("AppUpdater", "Static MarkBootSuccessful: Could not get running partition.");
        return AppUpdater::Status::kErrorGeneric;
    }
    esp_ota_img_states_t ota_state;
    esp_err_t err = esp_ota_get_state_partition(running_partition, &ota_state);
    if (err != ESP_OK) {
        ESP_LOGE("AppUpdater", "Static MarkBootSuccessful: Failed to get OTA state (err=0x%x).", err);
        return AppUpdater::Status::kErrorGeneric;
    }
    ESP_LOGI("AppUpdater", "Static MarkBootSuccessful: Current OTA state: %d", ota_state);
    if (ota_state == ESP_OTA_IMG_PENDING_VERIFY) {
        ESP_LOGI("AppUpdater", "Static MarkBootSuccessful: App is PENDING_VERIFY. Marking valid.");
        err = esp_ota_mark_app_valid_cancel_rollback();
        if (err != ESP_OK) {
            ESP_LOGE("AppUpdater", "Static MarkBootSuccessful: esp_ota_mark_app_valid_cancel_rollback failed (err=0x%x).", err);
            return AppUpdater::Status::kErrorGeneric;
        }
        ESP_LOGI("AppUpdater", "Static MarkBootSuccessful: Successfully marked app as valid.");
    } else {
        ESP_LOGI("AppUpdater", "Static MarkBootSuccessful: App not PENDING_VERIFY (state: %d). No explicit mark action needed for rollback cancellation.", ota_state);
    }
    return AppUpdater::Status::kSuccess;
}


// --- Forwarding Method Implementations ---
void AppUpdater::SetResetHook(std::function<void()> hook) { impl_->SetResetHook(hook); }
AppUpdater::Status AppUpdater::Begin(const Metadata& metadata, const BeginConfig& config) { return impl_->Begin(metadata, config); }
AppUpdater::Status AppUpdater::Write(const uint8_t* data, size_t size) { return impl_->Write(data, size); }
AppUpdater::Status AppUpdater::End() { return impl_->End(); }
AppUpdater::Status AppUpdater::Apply(std::function<void()> pre_restart_hook) { return impl_->Apply(pre_restart_hook); }
void AppUpdater::Reset() { impl_->Reset(); }
AppUpdater::State AppUpdater::GetState() const { return impl_->GetState(); }
std::string AppUpdater::GetLastError() const { return impl_->GetLastError(); }
size_t AppUpdater::GetBytesWritten() const { return impl_->GetBytesWritten(); }
AppUpdater::PartitionInfo AppUpdater::GetRunningPartitionInfo() const { return impl_->GetRunningPartitionInfo(); }
AppUpdater::PartitionInfo AppUpdater::GetNextBootPartitionInfo() const { return impl_->GetNextBootPartitionInfo(); }

} // namespace platform

------------------------------------------------------------------------------------------------------------------------
// Copyright [2025] [Your Name or Company]
// (Apache License header as before)

#include "app_updater.h" // Your AppUpdater header

#include "esp_log.h"
#include "esp_chip_info.h"   // For esp_chip_info() to get current chip
#include "esp_app_format.h"  // For esp_app_desc_t and related constants
#include "esp_ota_ops.h"     // For esp_app_get_description
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"       // For NVS init
#include <vector>
#include <string>
#include <cstdio>
#include <algorithm> // For std::transform

// --- Constants for Dummy Firmware and Testing ---
const char* kMainTag = "AppMainExample";

// IMPORTANT: THIS MUST BE SET TO THE STRING REPRESENTATION OF THE CHIP YOU ARE RUNNING ON!
// e.g., "ESP32", "ESP32S3", "ESP32C3"
// This is used for testing the metadata.target_platform_identifier logic.
std::string kActualCurrentChipString = "ESP32"; // Will be updated by GetCurrentChipModelStr()

const char* kTestFirmwareVersion = "7.0.0-boot-test";
const size_t kTestFirmwareTotalSize = 1024 * 30; // 30KB

// Helper to get current chip model as string (matches ChipModelToString in app_updater.cpp)
std::string GetCurrentChipModelStr() {
    esp_chip_info_t chip_info;
    esp_chip_info(&chip_info);
    switch (chip_info.model) {
        case CHIP_ESP32: return "ESP32";
        case CHIP_ESP32S2: return "ESP32S2";
        case CHIP_ESP32S3: return "ESP32S3";
        case CHIP_ESP32C3: return "ESP32C3";
        case CHIP_ESP32H2: return "ESP32H2";
        case CHIP_ESP32C2: return "ESP32C2";
        case CHIP_ESP32C6: return "ESP32C6";
        default: return "UNKNOWN_CHIP";
    }
}

// --- Helper: Creates a dummy firmware chunk with a specific chip_id in its header ---
static bool GetDummyFirmwareChunkWithChipId(size_t offset, uint8_t* buffer, size_t buffer_size, size_t* bytes_read, esp_chip_model_t image_target_chip_id) {
    // ... (Implementation from the previous detailed example) ...
    // (Ensure this function correctly crafts the esp_app_desc_t at offset 0x20)
    if (kTestFirmwareTotalSize == 0 && offset > 0) { *bytes_read = 0; return true; }
    if (offset >= kTestFirmwareTotalSize && kTestFirmwareTotalSize > 0) { *bytes_read = 0; return true; }
    size_t effective_total_size = (kTestFirmwareTotalSize == 0) ? buffer_size : kTestFirmwareTotalSize;
    size_t remaining = effective_total_size - offset;
    *bytes_read = (buffer_size < remaining) ? buffer_size : remaining;
    if (*bytes_read == 0 && effective_total_size > 0 && offset < effective_total_size ) return false;
    for (size_t i = 0; i < *bytes_read; ++i) buffer[i] = static_cast<uint8_t>((offset + i) % 128 + 30);
    size_t app_desc_full_offset = 0x20; // Standard offset for esp_app_desc_t
    if (offset == 0 && *bytes_read >= (app_desc_full_offset + sizeof(esp_app_desc_t))) {
        memset(buffer, 0, app_desc_full_offset + sizeof(esp_app_desc_t)); // Clear header area
        esp_image_header_t* hdr = reinterpret_cast<esp_image_header_t*>(buffer);
        hdr->magic = ESP_IMAGE_HEADER_MAGIC; hdr->segment_count = 1;
        esp_image_segment_header_t* seg_hdr = reinterpret_cast<esp_image_segment_header_t*>(buffer + sizeof(esp_image_header_t));
        seg_hdr->load_addr = 0x40080000; // Dummy
        seg_hdr->data_len = effective_total_size > (app_desc_full_offset + sizeof(esp_app_desc_t)) ? effective_total_size - (app_desc_full_offset + sizeof(esp_app_desc_t)) : 0;
        esp_app_desc_t* app_desc = reinterpret_cast<esp_app_desc_t*>(buffer + app_desc_full_offset);
        app_desc->magic_word = ESP_APP_DESC_MAGIC_WORD;
        app_desc->chip_id = image_target_chip_id;
        strncpy(app_desc->version, kTestFirmwareVersion, sizeof(app_desc->version) -1);
        strncpy(app_desc->project_name, "dummy_ota", sizeof(app_desc->project_name) -1);
        // app_desc->app_elf_sha256 is important for esp_ota_end validation if present
    }
    return true;
}

void LogPartitionInfoMain(const char* title, const platform::AppUpdater::PartitionInfo& info) {
    if (info.is_valid) {
        ESP_LOGI(kMainTag, "%s: Label: '%s', Type: %lu, Subtype: %lu, Addr: 0x%08zX, Size: %zu, Encrypted: %s",
                 title, info.label.c_str(), info.type_id, info.subtype_id,
                 info.address, info.size, info.is_encrypted ? "Yes" : "No");
    } else {
        ESP_LOGI(kMainTag, "%s: Invalid partition data.", title);
    }
}

bool perform_ota_write_loop(platform::AppUpdater& updater, const platform::AppUpdater::Metadata& metadata, esp_chip_model_t image_chip_id) {
    // ... (Implementation from the previous detailed example) ...
    std::vector<uint8_t> chunk_buffer(4096);
    size_t total_to_write = (metadata.image_size == 0 || metadata.image_size == OTA_SIZE_UNKNOWN) ? kTestFirmwareTotalSize : metadata.image_size;
    if (total_to_write == 0 && metadata.image_size == 0) return true;
    while (updater.GetBytesWritten() < total_to_write) {
        size_t bytes_read_from_dummy_source;
        GetDummyFirmwareChunkWithChipId(updater.GetBytesWritten(), chunk_buffer.data(), chunk_buffer.size(), &bytes_read_from_dummy_source, image_chip_id);
        if (bytes_read_from_dummy_source == 0) {
            if (updater.GetBytesWritten() < total_to_write && total_to_write != OTA_SIZE_UNKNOWN) return false;
            break;
        }
        platform::AppUpdater::Status write_status = updater.Write(chunk_buffer.data(), bytes_read_from_dummy_source);
        if (write_status != platform::AppUpdater::Status::kSuccess) return false;
        printf("Progress: %zu / %zu bytes\r", updater.GetBytesWritten(), total_to_write);
        vTaskDelay(pdMS_TO_TICKS(1));
    }
    printf("\n");
    if (total_to_write == OTA_SIZE_UNKNOWN) return true;
    return updater.GetBytesWritten() == total_to_write;
}

// --- Application Task that PERFORMS an OTA Update ---
void ApplicationUpdateTask(void* pvParameters) {
    platform::AppUpdater updater;
    platform::AppUpdater::Status status;
    platform::AppUpdater::Metadata metadata;
    platform::AppUpdater::BeginConfig begin_config;

    bool reset_hook_called_flag = false;
    updater.SetResetHook([&reset_hook_called_flag](){
        ESP_LOGW(kMainTag, "UPDATE TASK: Custom reset hook was called!");
        reset_hook_called_flag = true;
    });

    esp_chip_info_t current_hw_info;
    esp_chip_info(&current_hw_info);
    const esp_chip_model_t actual_current_chip_id = current_hw_info.model;

    ESP_LOGI(kMainTag, "==================================================================");
    ESP_LOGI(kMainTag, "--- UPDATE TASK: Simulating a successful update download       ---");
    ESP_LOGI(kMainTag, "--- (will not call Apply() to allow main_app to continue)      ---");
    ESP_LOGI(kMainTag, "==================================================================");
    updater.Reset(); // Ensure clean state
    reset_hook_called_flag = false; // Reset flag for this scenario

    metadata.image_size = kTestFirmwareTotalSize;
    metadata.version_string = "8.0.0-new-ota"; // Different from current running version
    metadata.target_platform_identifier = kActualCurrentChipString; // Optional: provide correct hint

    begin_config.allow_same_version = false;
    begin_config.inactivity_timeout_ms = 15000; // 15 second timeout

    status = updater.Begin(metadata, begin_config);
    if (status == platform::AppUpdater::Status::kSuccess) {
        ESP_LOGI(kMainTag, "UPDATE TASK: Begin() successful.");
        if (perform_ota_write_loop(updater, metadata, actual_current_chip_id)) { // Image for CORRECT chip
            status = updater.End();
            if (status == platform::AppUpdater::Status::kSuccess) {
                ESP_LOGI(kMainTag, "UPDATE TASK: SUCCESS - Firmware downloaded and verified (End() succeeded).");
                ESP_LOGI(kMainTag, "UPDATE TASK: Current state is kReadyToApply. Bytes written: %zu.", updater.GetBytesWritten());
                LogPartitionInfoMain("UPDATE TASK: Next Boot Partition Info", updater.GetNextBootPartitionInfo());
                ESP_LOGI(kMainTag, "UPDATE TASK: In a real scenario, you might call Apply() now or based on user input.");
                ESP_LOGI(kMainTag, "UPDATE TASK: For this demo, we will NOT call Apply() to let app_main continue.");
            } else {
                 ESP_LOGE(kMainTag, "UPDATE TASK: FAILURE - End() failed: %s (%s)", platform::AppUpdater::StatusToString(status), updater.GetLastError().c_str());
            }
        } else {
             ESP_LOGE(kMainTag, "UPDATE TASK: FAILURE - Write loop failed.");
        }
    } else {
        ESP_LOGE(kMainTag, "UPDATE TASK: Begin() failed: %s (%s)", platform::AppUpdater::StatusToString(status), updater.GetLastError().c_str());
    }

    if (status != platform::AppUpdater::Status::kSuccess && status != platform::AppUpdater::Status::kErrorCancelled && !reset_hook_called_flag && updater.GetState() == platform::AppUpdater::State::kError) {
        ESP_LOGW(kMainTag, "UPDATE TASK: An error occurred, calling Reset() to ensure hook is tested if applicable.");
        updater.Reset(); // This will trigger the hook if an error state leads to reset.
    }


    ESP_LOGI(kMainTag, "UPDATE TASK: Update task finished its scenario. It will now delete itself.");
    vTaskDelete(nullptr);
}


// --- Application Self-Test and Boot Validation (in app_main) ---
bool perform_critical_self_tests() {
    ESP_LOGI(kMainTag, "APP_MAIN: Performing critical application self-tests...");
    // Replace with actual checks for your application:
    // - Initialize essential peripherals
    // - Check critical configurations
    // - Attempt a basic network connection if required for core functionality
    vTaskDelay(pdMS_TO_TICKS(500)); // Simulate some work
    bool tests_passed = true; // Assume true for this example
    if(tests_passed) {
        ESP_LOGI(kMainTag, "APP_MAIN: Self-tests passed.");
    } else {
        ESP_LOGE(kMainTag, "APP_MAIN: Self-tests FAILED!");
    }
    return tests_passed;
}

// --- Main Entry Point ---
extern "C" void app_main(void) {
    // --- NVS Initialization ---
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Update kActualCurrentChipString at runtime for accurate testing messages
    kActualCurrentChipString = GetCurrentChipModelStr();
    ESP_LOGI(kMainTag, "APP_MAIN: Current runtime chip: %s", kActualCurrentChipString.c_str());

    // --- Log current application info ---
    const esp_app_desc_t* app_desc = esp_app_get_description();
    ESP_LOGI(kMainTag, "APP_MAIN: Current App Version: %s", app_desc->version);
    ESP_LOGI(kMainTag, "APP_MAIN: Project Name: %s", app_desc->project_name);
    ESP_LOGI(kMainTag, "APP_MAIN: Compile Time: %s %s", app_desc->date, app_desc->time);
    ESP_LOGI(kMainTag, "APP_MAIN: IDF Version: %s", app_desc->idf_ver);


    // --- OTA Boot Validation Step (This code runs on *every* boot) ---
    ESP_LOGI(kMainTag, "APP_MAIN: Checking if this boot requires OTA validation...");
    if (perform_critical_self_tests()) {
        // If all essential self-tests pass, mark this boot as successful.
        // This is crucial if OTA rollback is enabled.
        // If rollback is disabled, this call is benign.
        platform::AppUpdater::Status mark_status = platform::AppUpdater::MarkBootSuccessful();
        if (mark_status == platform::AppUpdater::Status::kSuccess) {
            ESP_LOGI(kMainTag, "APP_MAIN: Successfully marked boot as successful (or no action was needed by system).");
        } else {
            ESP_LOGE(kMainTag, "APP_MAIN: Failed to mark boot as successful: %s", platform::AppUpdater::StatusToString(mark_status));
            // Depending on the application, this might be a critical failure.
        }
    } else {
        ESP_LOGE(kMainTag, "APP_MAIN: Critical application self-tests FAILED! Not marking boot as successful.");
        // If rollback is enabled, the system might automatically roll back after a few failed boots.
        // Consider if a manual esp_restart() is appropriate here to expedite rollback.
    }

    // --- Start the OTA Update Task (for demonstration) ---
    // In a real application, this might be triggered by a command, a timer, or a cloud message.
    ESP_LOGI(kMainTag, "APP_MAIN: Starting the ApplicationUpdateTask (for demo purposes)...");
    xTaskCreate(&ApplicationUpdateTask, "ota_update_task", 8192 * 2, nullptr, 5, nullptr);


    ESP_LOGI(kMainTag, "APP_MAIN: Main application setup complete. Entering main loop (simulated).");
    // --- Placeholder for your application's main loop or other tasks ---
    for (int i = 0; ; ++i) {
        ESP_LOGD(kMainTag, "APP_MAIN: Main loop iteration %d...", i);
        vTaskDelay(pdMS_TO_TICKS(10000));
    }
}
