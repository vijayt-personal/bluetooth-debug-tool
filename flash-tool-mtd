meta-custom/
├── conf/
│   └── layer.conf
└── recipes-flash-tool/
    └── flash-tool/
        ├── files/
        │   ├── flash_tool.c
        │   ├── Makefile
        │   ├── README.txt
        │   └── SAMPLE_OUTPUT.txt
        └── flash-tool_0.1.bb

// meta-custom/conf/layer.conf
# We have a conf and classes directory, add to BBPATH
BBPATH .= ":${LAYERDIR}"

# We have recipes-* directories, add to BBFILES
BBFILES += "${LAYERDIR}/recipes-*/*/*.bb \
            ${LAYERDIR}/recipes-*/*/*.bbappend"

BBFILE_COLLECTIONS += "meta-custom"
BBFILE_PATTERN_meta-custom = "^${LAYERDIR}/"
BBFILE_PRIORITY_meta-custom = "6"

LAYERDEPENDS_meta-custom = "core"
# Added "zeus" for compatibility with older Yocto versions.
LAYERSERIES_COMPAT_meta-custom = "zeus kirkstone nanbield"


//meta-custom/recipes-flash-tool/flash-tool/flash-tool_0.1.bbSUMMARY = "An advanced CLI tool for safe flash operations via the MTD subsystem"
DESCRIPTION = "A non-interactive command-line utility that uses the native MTD subsystem to read, write, erase, and stress-test flash memory safely."
LICENSE = "CLOSED"

DEPENDS = "mtd-utils-native"

SRC_URI = "file://flash_tool.c \
           file://Makefile \
           file://README.txt \
           file://SAMPLE_OUTPUT.txt \
          "

S = "${WORKDIR}"

do_compile() {
	oe_runmake
}

do_install() {
	install -d ${D}${bindir}
	install -m 0755 ${S}/flash_tool ${D}${bindir}/flash_tool

    install -d ${D}${docdir}/${PN}
    install -m 0644 ${S}/README.txt ${D}${docdir}/${PN}/
    install -m 0644 ${S}/SAMPLE_OUTPUT.txt ${D}${docdir}/${PN}/
}

//meta-custom/recipes-flash-tool/flash-tool/files/Makefile
# Makefile for flash_tool
TARGET=flash_tool
SRCS=flash_tool.c

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(SRCS)
	$(CC) $(CFLAGS) -o $(TARGET) $(SRCS)

clean:
	rm -f $(TARGET)

 // meta-custom/recipes-flash-tool/flash-tool/files/README.txt
NXP i.MX8 Flash Tool (Advanced MTD Version)
============================================
Version: 9.0 (August 22, 2025)

This document provides instructions for the flash_tool CLI. This version uses the standard
Linux MTD subsystem for all flash operations, ensuring safety and compatibility.

1. GLOBAL OPTIONS
-------------------
These options must come BEFORE the main command (e.g., flash).

  --mtd-dev <path>
    Specifies the target MTD device. (Default: /dev/mtd0)

  --warn-addr <hex>
    Sets a custom safety warning address. (Default: 0x200000)

  --use-logical-sectors
    Switches the tool's indexing from physical erase blocks to logical 128KB
    sectors. By default, the tool operates on erase blocks.

2. COMMAND REFERENCE & USAGE EXAMPLES
-------------------------------------
NOTE: The term 'block' below refers to the physical erase block of the device.
If --use-logical-sectors is active, 'block' should be interpreted as a 128KB sector.

  **info**
    - Displays information about the selected MTD partition.

  ---
  **flash write [--no-erase] <type> <pattern> <block> <size>**
    - Writes data to a specific block/sector.

  ---
  **flash read <type> <block> <size>**
    - Reads data from a specific block/sector.

  ---
  **flash erase <type> [<start_block> <end_block>]**
    - Erases a region of flash.

  ---
  **flash write-verify <type> <block> <iter> <fail> <log> <full> [file_path]**
    - Performs a continuous write-read-verify stress test.

// meta-custom/recipes-flash-tool/flash-tool/files/SAMPLE_OUTPUT.txt
This file shows sample output for various flash-tool commands.

----------------------------------------------------------------------
1. Info Command
   # flash-tool --mtd-dev /dev/mtd4 info
----------------------------------------------------------------------
>> Using MTD device: /dev/mtd4
--- MTD Partition Information ---
Partition Name:      user-data
Total Size:          33554432 bytes (32.0 MiB)
Erase Block Size:    131072 bytes (128.0 KiB)
Total Erase Blocks:  256
Min. IO Size:        1 bytes

----------------------------------------------------------------------
2. Multi-Block Erase Command
   # flash-tool --mtd-dev /dev/mtd4 flash erase O 200 201
----------------------------------------------------------------------
>> Using MTD device: /dev/mtd4
Requested erase size 131072 bytes (Type O) is supported by device.
Erasing from block 200 to 201...
Erasing block 1/2 (device block 200) at offset 0x1900000...
Issuing MEMERASE: start=0x1900000, length=0x20000
Erasing block 2/2 (device block 201) at offset 0x1920000...
Issuing MEMERASE: start=0x1920000, length=0x20000
Erase successful.

----------------------------------------------------------------------
3. Write-Verify Command Reaching Max Failures
   # flash-tool --mtd-dev /dev/mtd4 flash write-verify P 250 0 1 1 0
----------------------------------------------------------------------
>> Using MTD device: /dev/mtd4
Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.
--- Starting MTD Write-Verify Stress Test ---
Start Block: 250 | Iterations: Infinite | Stop on Fails: 1
Test Progress: Iter 1 | Block 250 | Erasing... Writing... Verifying... PASS
Test Progress: Iter 2 | Block 250 | Erasing... Writing... Verifying... PASS

[LOG 1/64] VERIFY FAILED!
----------------------------------------
  - Failure Count: 1
  - Block:         250
  - Byte Offset:   0x0000001A (26)
  - Expected Data: 0x1A
  - Actual Data:   0xBA
----------------------------------------
Test Progress: Iter 3 | Block 250 | Erasing... Writing... Verifying... FAIL
Stopping test: Maximum fail count reached.
--- Test Complete ---

//meta-custom/recipes-flash-tool/flash-tool/files/flash_tool.c
/*
 * flash_tool.c
 *
 * An advanced, non-interactive command-line utility for an NXP i.MX8 board.
 * This version uses the native MTD subsystem for safe flash interaction.
 *
 * This version incorporates expert feedback:
 * - Operates on physical erase blocks by default, with an option for logical sectors.
 * - Uses portable types (uint64_t, off_t) for sizes and offsets.
 * - Issues erase commands one block at a time.
 * - Uses fsync() to ensure data integrity during write-verify.
 * - Includes all necessary headers like <stdint.h> and <inttypes.h>.
 *
 * Author: Gemini
 * Date: August 22, 2025
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <ctype.h>
#include <mtd/mtd-user.h>
#include <signal.h>
#include <stdint.h>     // For uint64_t and other fixed-width types
#include <inttypes.h>   // For PRIu64 and other format macros

#define LOGICAL_SECTOR_SIZE (128 * 1024)
#define BOOTLOADER_WARN_ADDR_DEFAULT 0x200000
#define WRITE_SIZE_MAX 256
#define MAX_FAILURE_LOGS 64

// Global variables for configuration
uint64_t g_warn_addr = BOOTLOADER_WARN_ADDR_DEFAULT;
const char *g_mtd_device = "/dev/mtd0";
int g_use_logical_sectors = 0;
volatile sig_atomic_t g_signal_received = 0;

// Prototypes
void signal_handler(int signum);
void hexdump(uint64_t base_offset, const unsigned char *data, size_t size);
void print_help(const char *app_name);
int generate_pattern_data(const char* pattern, unsigned char* buffer, size_t size);
int mtd_erase_block(int fd, uint64_t offset, const mtd_info_t *mtd_info);
int get_mtd_info(mtd_info_t *mtd_info);
int validate_block(uint64_t block, const mtd_info_t *mtd_info);
void handle_flash_info(int argc, char *argv[]);
void handle_flash_write(int argc, char *argv[]);
void handle_flash_read(int argc, char *argv[]);
void handle_flash_erase(int argc, char *argv[]);
void handle_flash_write_verify(int argc, char *argv[]);

void signal_handler(int signum) {
    g_signal_received = 1;
    fprintf(stderr, "\nSignal %d received. Finishing current operation and shutting down gracefully...\n", signum);
}

int main(int argc, char *argv[]) {
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    char *exec_name = argv[0];
    int arg_offset = 1;
    while (arg_offset < argc) {
        if (strcmp(argv[arg_offset], "--warn-addr") == 0) {
            if (arg_offset + 1 >= argc) { fprintf(stderr, "Error: --warn-addr requires a value.\n"); return 1; }
            g_warn_addr = strtoull(argv[arg_offset + 1], NULL, 16);
            printf(">> Custom Warning Address set to 0x%" PRIX64 "\n", g_warn_addr);
            arg_offset += 2;
        } else if (strcmp(argv[arg_offset], "--mtd-dev") == 0) {
            if (arg_offset + 1 >= argc) { fprintf(stderr, "Error: --mtd-dev requires a path.\n"); return 1; }
            g_mtd_device = argv[arg_offset + 1];
            printf(">> Using MTD device: %s\n", g_mtd_device);
            arg_offset += 2;
        } else if (strcmp(argv[arg_offset], "--use-logical-sectors") == 0) {
            g_use_logical_sectors = 1;
            printf(">> Operating in LOGICAL 128KiB SECTOR mode.\n");
            arg_offset += 1;
        } else { break; }
    }
    
    argc -= arg_offset;
    argv += arg_offset;

    if (argc < 1) { print_help(exec_name); return 1; }
    
    if (strcmp(argv[0], "flash") == 0) {
        if (argc < 2) { fprintf(stderr, "Error: Missing flash subcommand.\n"); print_help(exec_name); return 1; }
        char *sub_cmd = argv[1];
        if (strcmp(sub_cmd, "write") == 0) handle_flash_write(argc-2, argv+2);
        else if (strcmp(sub_cmd, "read") == 0) handle_flash_read(argc-2, argv+2);
        else if (strcmp(sub_cmd, "erase") == 0) handle_flash_erase(argc-2, argv+2);
        else if (strcmp(sub_cmd, "write-verify") == 0) handle_flash_write_verify(argc-2, argv+2);
        else { fprintf(stderr, "Error: Unknown flash command '%s'.\n", sub_cmd); print_help(exec_name); return 1; }
    } else if (strcmp(argv[0], "info") == 0) { handle_flash_info(argc-1, argv+1);
    } else if (strcmp(argv[0], "clr") == 0) { printf("\033[H\033[J");
    } else if (strcmp(argv[0], "help") == 0) { print_help(exec_name);
    } else { fprintf(stderr, "Error: Unknown command '%s'.\n", argv[0]); print_help(exec_name); return 1; }
    
    return 0;
}

void print_help(const char *app_name) {
    printf("NXP i.MX8 Flash Tool (Advanced MTD Version)\n\n");
    printf("Usage: %s [--mtd-dev <path>] [--warn-addr <hex>] [--use-logical-sectors] <command> [options]\n\n", app_name);
    printf("Commands:\n");
    printf("  info                                                - Display info about the MTD partition.\n");
    printf("  flash write [--no-erase] <type> <pattern> <block|sector> <size> - Write pattern.\n");
    printf("  flash read <type> <block|sector> <size>             - Read data from flash.\n");
    printf("  flash erase <type> [<start_block|sector> <end_block|sector>] - Erase flash region.\n");
    printf("  flash write-verify <t> <block|sector> <iter> <fail> <log> <full> [file] - Stress test.\n");
    printf("  clr                                                 - Clear terminal screen.\n");
    printf("  help                                                - Show this help message.\n\n");
}

void hexdump(uint64_t base_offset, const unsigned char *data, size_t size) {
    for (size_t i = 0; i < size; i++) {
        if (i % 8 == 0) {
            if (i > 0) printf("\n");
            printf("0x%08" PRIX64 " : ", base_offset + i);
        }
        printf("%02X ", data[i]);
    }
    printf("\n");
}

int mtd_erase_block(int fd, uint64_t offset, const mtd_info_t *mtd_info) {
    struct erase_info_user lock_info = { .start = (uint32_t)offset, .length = mtd_info->erasesize };
    if (ioctl(fd, MEMUNLOCK, &lock_info) != 0) {
        perror("ioctl(MEMUNLOCK)");
        fprintf(stderr, "Warning: Could not unlock region. Continuing erase anyway.\n");
    }

    struct erase_info_user erase_info = { .start = (uint32_t)offset, .length = mtd_info->erasesize };
    printf("Issuing MEMERASE: start=0x%x, length=0x%x\n", erase_info.start, erase_info.length);
    if (ioctl(fd, MEMERASE, &erase_info) != 0) {
        perror("ioctl(MEMERASE)");
        ioctl(fd, MEMLOCK, &lock_info);
        return -1;
    }

    if (ioctl(fd, MEMLOCK, &lock_info) != 0) {
        perror("ioctl(MEMLOCK)");
        fprintf(stderr, "Warning: Could not re-lock region after erase.\n");
    }
    return 0;
}

int get_mtd_info(mtd_info_t *mtd_info) {
    int fd = open(g_mtd_device, O_RDONLY);
    if (fd < 0) { perror("open(MEMGETINFO)"); return -1; }
    if (ioctl(fd, MEMGETINFO, mtd_info) != 0) { perror("ioctl(MEMGETINFO)"); close(fd); return -1; }
    close(fd);
    return 0;
}

int validate_block(uint64_t block, const mtd_info_t *mtd_info) {
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info->erasesize;
    if (block_size == 0) {
        fprintf(stderr, "Error: Invalid block/sector size 0.\n");
        return -1;
    }
    uint64_t max_block = mtd_info->size / block_size - 1;
    if (block > max_block) {
        fprintf(stderr, "Error: Block/sector %" PRIu64 " is out of range. Valid range is 0-%" PRIu64 ".\n", block, max_block);
        return -1;
    }
    return 0;
}

int generate_pattern_data(const char* pattern, unsigned char* buffer, size_t size) {
    if (strcmp(pattern, "+") == 0) { for (size_t i = 0; i < size; i++) buffer[i] = (unsigned char)(i & 0xFF);
    } else if (strcmp(pattern, "-") == 0) { for (size_t i = 0; i < size; i++) buffer[i] = (unsigned char)((0xFF - i) & 0xFF);
    } else {
        long val = strtol(pattern, NULL, 16);
        if (val < 0 || val > 255) { fprintf(stderr, "Error: Invalid hex pattern.\n"); return -1; }
        memset(buffer, (unsigned char)val, size);
    }
    return 0;
}

void handle_flash_info(int argc, char *argv[]) {
    if (argc != 0) { fprintf(stderr, "Usage: info\n"); exit(1); }
    
    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);

    printf("--- MTD Partition Information ---\n");
    printf("Partition Name:      %s\n", mtd_info.name);
    printf("Total Size:          %u bytes (%.1f MiB)\n", mtd_info.size, (float)mtd_info.size / (1024*1024));
    printf("Erase Block Size:    %u bytes (%.1f KiB)\n", mtd_info.erasesize, (float)mtd_info.erasesize / 1024);
    if (mtd_info.erasesize > 0) {
        printf("Total Erase Blocks:  %llu\n", (unsigned long long)mtd_info.size / mtd_info.erasesize);
    }
    printf("Min. IO Size:        %u bytes\n", mtd_info.writesize);
}

void handle_flash_write(int argc, char *argv[]) {
    int perform_erase = 1;
    int arg_offset = 0;
    if (argc > 0 && strcmp(argv[0], "--no-erase") == 0) {
        perform_erase = 0;
        arg_offset = 1;
        printf(">> --no-erase flag set. Skipping pre-erase.\n");
    }

    if (argc - arg_offset != 4) { fprintf(stderr, "Usage: flash write [--no-erase] <type> <pattern> <block|sector> <size>\n"); exit(1); }
    
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    char *pattern = argv[arg_offset + 1];
    uint64_t block = strtoull(argv[arg_offset + 2], NULL, 0);
    size_t size = strtoul(argv[arg_offset + 3], NULL, 0);

    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0 || validate_block(block, &mtd_info) != 0) exit(1);
    
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info.erasesize;
    uint64_t offset = block * block_size;

    if (offset < g_warn_addr) { fprintf(stderr, "!! DANGER: Address 0x%" PRIX64 " is below warning address 0x%" PRIX64 ". Aborting.\n", offset, g_warn_addr); exit(1); }
    if (size == 0 || size > WRITE_SIZE_MAX) { fprintf(stderr, "Error: Size must be between 1 and %d bytes.\n", WRITE_SIZE_MAX); exit(1); }
    if (size > mtd_info.erasesize) { fprintf(stderr, "Error: Write size (%zu) cannot be larger than an erase block (%u).\n", size, mtd_info.erasesize); exit(1); }

    unsigned char *data_buffer = malloc(size);
    if (!data_buffer || generate_pattern_data(pattern, data_buffer, size) != 0) {
        fprintf(stderr, "Error allocating or generating pattern data.\n");
        if(data_buffer) free(data_buffer);
        exit(1);
    }

    int fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); free(data_buffer); exit(1); }

    printf("Writing %zu bytes to block/sector %" PRIu64 " (Offset 0x%" PRIX64 ")...\n", size, block, offset);
    
    if (perform_erase) {
        uint64_t erase_offset = (offset / mtd_info.erasesize) * mtd_info.erasesize;
        printf("Pre-erasing block at offset 0x%" PRIX64 "...\n", erase_offset);
        if (mtd_erase_block(fd, erase_offset, &mtd_info) != 0) {
            free(data_buffer); close(fd); exit(1);
        }
    }

    if (lseek(fd, offset, SEEK_SET) == (off_t)-1) { perror("lseek"); free(data_buffer); close(fd); exit(1); }
    
    ssize_t written = write(fd, data_buffer, size);
    if (written < 0) { perror("write"); free(data_buffer); close(fd); exit(1); }
    
    fsync(fd);
    
    free(data_buffer);
    close(fd);

    if ((size_t)written != size) { fprintf(stderr, "Error: Wrote %zd of %zu bytes.\n", written, size); exit(1); }
    printf("Write successful.\n");
}

void handle_flash_read(int argc, char *argv[]) {
    if (argc != 3) { fprintf(stderr, "Usage: flash read <type> <block|sector> <size>\n"); exit(1); }
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    uint64_t block = strtoull(argv[1], NULL, 0);
    size_t size = strtoul(argv[2], NULL, 0);

    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0 || validate_block(block, &mtd_info) != 0) exit(1);
    
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info.erasesize;
    uint64_t offset = block * block_size;

    if (size == 0 || size > WRITE_SIZE_MAX) { fprintf(stderr, "Error: Size must be between 1 and %d bytes.\n", WRITE_SIZE_MAX); exit(1); }

    unsigned char *data_buffer = malloc(size);
    if (!data_buffer) { fprintf(stderr, "Error: malloc failed.\n"); exit(1); }
    
    int fd = open(g_mtd_device, O_RDONLY);
    if (fd < 0) { perror("open"); free(data_buffer); exit(1); }
    
    if (lseek(fd, offset, SEEK_SET) == (off_t)-1) { perror("lseek"); free(data_buffer); close(fd); exit(1); }
    ssize_t bytes_read = read(fd, data_buffer, size);
    close(fd);

    if (bytes_read < 0) { perror("read"); free(data_buffer); exit(1); }
    
    printf("sector=0x%" PRIX64 " size=%zd\n", offset, bytes_read);
    printf("Data read followed by sector 0x%" PRIX64 "\n", offset);
    hexdump(offset, data_buffer, bytes_read);
    free(data_buffer);
}

void handle_flash_erase(int argc, char *argv[]) {
    if (argc < 1) { fprintf(stderr, "Usage: flash erase <type> [<start_block|sector> <end_block|sector>]\n"); exit(1); }
    char type = argv[0][0];

    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);

    if (type == 'C') {
        if (argc != 1) { fprintf(stderr, "Usage: flash erase C\n"); exit(1); }
        printf("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
        printf("You are about to erase the ENTIRE MTD partition named \"%s\".\n", mtd_info.name);
        printf("This will destroy ALL data on this partition (%u bytes).\n", mtd_info.size);
        printf("This operation is IRREVERSIBLE.\n\n");
        printf("To confirm, type the exact phrase 'ERASE-PARTITION' and press Enter.\n> ");

        char confirmation[32];
        if (fgets(confirmation, sizeof(confirmation), stdin)) {
            confirmation[strcspn(confirmation, "\n")] = 0;
            if (strcmp(confirmation, "ERASE-PARTITION") == 0) {
                printf("\nConfirmation accepted. Proceeding with partition erase.\n");
            } else {
                printf("\nConfirmation failed. Aborting.\n");
                exit(1);
            }
        } else {
            printf("\nCould not read confirmation. Aborting.\n");
            exit(1);
        }

        printf("Erasing entire partition \"%s\" (%u bytes)...\n", mtd_info.name, mtd_info.size);
        int fd = open(g_mtd_device, O_RDWR);
        if (fd < 0) { perror("open"); exit(1); }
        
        uint64_t num_blocks = mtd_info.size / mtd_info.erasesize;
        for (uint64_t i = 0; i < num_blocks; i++) {
            if (g_signal_received) { break; }
            uint64_t current_offset = i * mtd_info.erasesize;
            printf("Erasing block %" PRIu64 "/%" PRIu64 " at offset 0x%" PRIX64 "...\n", i + 1, num_blocks, current_offset);
            if (mtd_erase_block(fd, current_offset, &mtd_info) != 0) {
                close(fd);
                exit(1);
            }
        }
        close(fd);
        if (!g_signal_received) {
            printf("Erase successful.\n");
        }
        return;
    }

    if (argc != 3) { fprintf(stderr, "Usage: flash erase <Z|Y|O> <start_block|sector> <end_block|sector>\n"); exit(1); }
    uint64_t start_block = strtoull(argv[1], NULL, 0);
    uint64_t end_block = strtoull(argv[2], NULL, 0);

    uint32_t requested_erase_size = 0;
    switch(type) {
        case 'Z': requested_erase_size = 4096; break;
        case 'Y': requested_erase_size = 32768; break;
        case 'O': requested_erase_size = 131072; break;
        default: fprintf(stderr, "Error: Invalid erase type '%c'. Use Z, Y, O, or C.\n", type); exit(1);
    }
    
    if (requested_erase_size != mtd_info.erasesize) {
        fprintf(stderr, "Error: Unsupported erase size. Requested %u bytes (Type %c), but device requires %u bytes.\n",
                requested_erase_size, type, mtd_info.erasesize);
        exit(1);
    }
    printf("Requested erase size %u bytes (Type %c) is supported by device.\n", requested_erase_size, type);

    if (validate_block(start_block, &mtd_info) != 0 || validate_block(end_block, &mtd_info) != 0) exit(1);
    if (start_block > end_block) { fprintf(stderr, "Error: Start block cannot be greater than end block.\n"); exit(1); }

    int fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); exit(1); }

    printf("Erasing from block/sector %" PRIu64 " to %" PRIu64 "...\n", start_block, end_block);
    
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info.erasesize;

    for (uint64_t i = start_block; i <= end_block; i++) {
        if (g_signal_received) { break; }
        uint64_t current_offset = i * block_size;
        
        uint64_t num_phys_blocks = (i == end_block) ? ((end_block + 1) * block_size - current_offset) / mtd_info.erasesize : block_size / mtd_info.erasesize;

        for (uint64_t j = 0; j < num_phys_blocks; j++) {
            if (g_signal_received) { goto end_erase_loop; }
            uint64_t physical_offset = current_offset + (j * mtd_info.erasesize);
            if (physical_offset < g_warn_addr) { 
                fprintf(stderr, "!! DANGER: Address 0x%" PRIX64 " is below warning address 0x%" PRIX64 ". Aborting.\n", physical_offset, g_warn_addr);
                goto end_erase_loop;
            }
            printf("Erasing physical block at offset 0x%" PRIX64 "...\n", physical_offset);
            if (mtd_erase_block(fd, physical_offset, &mtd_info) != 0) {
                close(fd);
                exit(1);
            }
        }
    }
end_erase_loop:
    
    close(fd);
    if (!g_signal_received) {
        printf("Erase successful.\n");
    }
}

void handle_flash_write_verify(int argc, char *argv[]) {
    if (argc < 6 || argc > 7) { fprintf(stderr, "Usage: flash write-verify <t> <block> <iter> <fail> <log> <full> [file]\n"); exit(1); }
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    uint64_t start_block = strtoull(argv[1], NULL, 0);
    uint64_t iterations = strtoull(argv[2], NULL, 0);
    uint64_t fail_stop_count = strtoull(argv[3], NULL, 0);
    int log_enable = atoi(argv[4]);
    int full_sector_util = atoi(argv[5]);
    const char* file_path = (argc == 7) ? argv[6] : NULL;

    unsigned long long iter_count = 0, fail_count = 0, logged_fails = 0, total_pass = 0;
    
    printf("--- Starting MTD Write-Verify Stress Test ---\n");
    printf("Start Block: %" PRIu64 " | Iterations: %s | Stop on Fails: %s\n", 
            start_block, (iterations == 0) ? "Infinite" : argv[2], (fail_stop_count == 0) ? "No" : argv[3]);

    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);
    if (validate_block(start_block, &mtd_info) != 0) exit(1);

    int fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); exit(1); }
    
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info.erasesize;
    uint64_t max_blocks = mtd_info.size / block_size;
    unsigned char *write_buf = malloc(block_size);
    unsigned char *read_buf = malloc(block_size);
    if (!write_buf || !read_buf) { fprintf(stderr, "Malloc failed for test buffers\n"); close(fd); exit(1); }

    off_t file_size = 0;
    if (file_path) {
        printf("Using data from file: %s\n", file_path);
        FILE *f = fopen(file_path, "rb");
        if (!f) { perror("fopen"); free(write_buf); free(read_buf); close(fd); exit(1); }
        if (fseeko(f, 0, SEEK_END) != 0) { perror("fseeko"); fclose(f); exit(1); }
        file_size = ftello(f);
        if (fseeko(f, 0, SEEK_SET) != 0) { perror("fseeko"); fclose(f); exit(1); }
        if (file_size > block_size) {
            fprintf(stderr, "Error: File size (%" PRIdMAX ") exceeds block/sector size (%u).\n", (intmax_t)file_size, block_size);
            fclose(f); free(write_buf); free(read_buf); close(fd); exit(1);
        }
        memset(write_buf, 0xFF, block_size);
        if (fread(write_buf, 1, file_size, f) != (size_t)file_size) {
            fprintf(stderr, "Error reading from file.\n");
            fclose(f); free(write_buf); free(read_buf); close(fd); exit(1);
        }
        fclose(f);
    }

    while ((iterations == 0 || iter_count < iterations) && !g_signal_received) {
        iter_count++;
        uint64_t current_block = start_block;
        if (full_sector_util) {
            uint64_t safe_block_start = (g_warn_addr + block_size - 1) / block_size;
            uint64_t num_safe_blocks = max_blocks - safe_block_start;
            if (num_safe_blocks <= 0) { fprintf(stderr, "\nError: No safe blocks available for full utilization test.\n"); break; }
            current_block = safe_block_start + ((iter_count-1) % num_safe_blocks);
        }
        
        if (validate_block(current_block, &mtd_info) != 0) { fprintf(stderr, "\nError: Calculated block %" PRIu64 " is invalid. Stopping.\n", current_block); break; }
        
        uint64_t offset = current_block * block_size;
        if (!file_path) {
            generate_pattern_data("+", write_buf, block_size);
            write_buf[0] = iter_count & 0xFF;
        }

        printf("Test Progress: Iter %llu | Block %" PRIu64 " | Erasing... ", iter_count, current_block);
        fflush(stdout);
        if (mtd_erase_block(fd, offset, &mtd_info) != 0) { fail_count++; if(log_enable) fprintf(stderr, "\nErase fail on block %" PRIu64 "\n", current_block); continue; }
        
        printf("Writing... ");
        fflush(stdout);
        lseek(fd, offset, SEEK_SET);
        if (write(fd, write_buf, block_size) != block_size) { fail_count++; if(log_enable) fprintf(stderr, "\nWrite fail on block %" PRIu64 "\n", current_block); continue; }
        fsync(fd);
        
        printf("Verifying... ");
        fflush(stdout);
        lseek(fd, offset, SEEK_SET);
        if (read(fd, read_buf, block_size) != block_size) { fail_count++; if(log_enable) fprintf(stderr, "\nRead fail on block %" PRIu64 "\n", current_block); continue; }

        if (memcmp(write_buf, read_buf, block_size) == 0) {
            total_pass++;
            printf("PASS\n");
        } else {
            fail_count++;
            printf("FAIL\n");
            if (log_enable && logged_fails < MAX_FAILURE_LOGS) {
                logged_fails++;
                uint64_t mismatch_offset = -1;
                for (uint32_t i = 0; i < block_size; i++) {
                    if (write_buf[i] != read_buf[i]) {
                        mismatch_offset = i;
                        break;
                    }
                }
                printf("[LOG %llu/%d] VERIFY FAILED!\n", logged_fails, MAX_FAILURE_LOGS);
                printf("----------------------------------------\n");
                printf("  - Failure Count: %llu\n", fail_count);
                printf("  - Block:         %" PRIu64 "\n", current_block);
                if (mismatch_offset != (uint64_t)-1) {
                    printf("  - Byte Offset:   0x%08" PRIX64 " (%" PRIu64 ")\n", mismatch_offset, mismatch_offset);
                    printf("  - Expected Data: 0x%02X\n", write_buf[mismatch_offset]);
                    printf("  - Actual Data:   0x%02X\n", read_buf[mismatch_offset]);
                }
                printf("----------------------------------------\n");
            }
            if (fail_stop_count > 0 && fail_count >= fail_stop_count) { fprintf(stderr, "Stopping test: Maximum fail count reached.\n"); break; }
        }
    }
    
    free(write_buf); free(read_buf);
    close(fd);
    printf("--- Test Complete ---\n");
}

/*
 * flash_tool.c
 *
 * An advanced, non-interactive command-line utility for an NXP i.MX8 board.
 * This version uses the native MTD subsystem for safe flash interaction.
 *
 * This version incorporates expert feedback:
 * - Operates on physical erase blocks by default, with an option for logical sectors.
 * - Uses portable types (uint64_t, off_t) for sizes and offsets.
 * - Issues erase commands one block at a time.
 * - Uses fsync() to ensure data integrity during write-verify.
 * - Includes all necessary headers like <stdint.h> and <inttypes.h>.
 * - Contains robust bounds checking and validation.
 * - Handles partial read/write calls and EINTR.
 *
 * Author: Gemini
 * Date: August 22, 2025
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <ctype.h>
#include <mtd/mtd-user.h>
#include <signal.h>
#include <stdint.h>
#include <inttypes.h>
#include <limits.h>

#define LOGICAL_SECTOR_SIZE (128 * 1024)
#define BOOTLOADER_WARN_ADDR_DEFAULT 0x200000
#define WRITE_SIZE_MAX 256
#define MAX_FAILURE_LOGS 64

// Global variables for configuration
uint64_t g_warn_addr = BOOTLOADER_WARN_ADDR_DEFAULT;
const char *g_mtd_device = "/dev/mtd0";
int g_use_logical_sectors = 0;
volatile sig_atomic_t g_signal_received = 0;

// Prototypes
void signal_handler(int signum);
void hexdump(uint64_t base_offset, const unsigned char *data, size_t size);
void print_help(const char *app_name);
int generate_pattern_data(const char* pattern, unsigned char* buffer, size_t size);
int mtd_erase_block(int fd, uint64_t offset, const struct mtd_info_user *mtd_info);
int get_mtd_info(struct mtd_info_user *mtd_info);
int validate_block(uint64_t block, const struct mtd_info_user *mtd_info);
int mtd_write_data(int fd, uint64_t offset, const void *data, size_t size);
int mtd_read_data(int fd, uint64_t offset, void *buffer, size_t size);
void handle_flash_info(int argc, char *argv[]);
void handle_flash_write(int argc, char *argv[]);
void handle_flash_read(int argc, char *argv[]);
void handle_flash_erase(int argc, char *argv[]);
void handle_flash_write_verify(int argc, char *argv[]);

void signal_handler(int signum) {
    g_signal_received = 1;
    fprintf(stderr, "\nSignal %d received. Finishing current operation and shutting down gracefully...\n", signum);
}

int main(int argc, char *argv[]) {
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    char *exec_name = argv[0];
    int arg_offset = 1;
    while (arg_offset < argc) {
        if (strcmp(argv[arg_offset], "--warn-addr") == 0) {
            if (arg_offset + 1 >= argc) { fprintf(stderr, "Error: --warn-addr requires a value.\n"); return 1; }
            g_warn_addr = strtoull(argv[arg_offset + 1], NULL, 16);
            printf(">> Custom Warning Address set to 0x%" PRIX64 "\n", g_warn_addr);
            arg_offset += 2;
        } else if (strcmp(argv[arg_offset], "--mtd-dev") == 0) {
            if (arg_offset + 1 >= argc) { fprintf(stderr, "Error: --mtd-dev requires a path.\n"); return 1; }
            g_mtd_device = argv[arg_offset + 1];
            printf(">> Using MTD device: %s\n", g_mtd_device);
            arg_offset += 2;
        } else if (strcmp(argv[arg_offset], "--use-logical-sectors") == 0) {
            g_use_logical_sectors = 1;
            printf(">> Operating in LOGICAL 128KiB SECTOR mode.\n");
            arg_offset += 1;
        } else { break; }
    }
    
    argc -= arg_offset;
    argv += arg_offset;

    if (argc < 1) { print_help(exec_name); return 1; }
    
    if (strcmp(argv[0], "flash") == 0) {
        if (argc < 2) { fprintf(stderr, "Error: Missing flash subcommand.\n"); print_help(exec_name); return 1; }
        char *sub_cmd = argv[1];
        if (strcmp(sub_cmd, "write") == 0) handle_flash_write(argc-2, argv+2);
        else if (strcmp(sub_cmd, "read") == 0) handle_flash_read(argc-2, argv+2);
        else if (strcmp(sub_cmd, "erase") == 0) handle_flash_erase(argc-2, argv+2);
        else if (strcmp(sub_cmd, "write-verify") == 0) handle_flash_write_verify(argc-2, argv+2);
        else { fprintf(stderr, "Error: Unknown flash command '%s'.\n", sub_cmd); print_help(exec_name); return 1; }
    } else if (strcmp(argv[0], "info") == 0) { handle_flash_info(argc-1, argv+1);
    } else if (strcmp(argv[0], "clr") == 0) { printf("\033[H\033[J");
    } else if (strcmp(argv[0], "help") == 0) { print_help(exec_name);
    } else { fprintf(stderr, "Error: Unknown command '%s'.\n", argv[0]); print_help(exec_name); return 1; }
    
    return 0;
}

void print_help(const char *app_name) {
    printf("NXP i.MX8 Flash Tool (Advanced MTD Version)\n\n");
    printf("Usage: %s [--mtd-dev <path>] [--warn-addr <hex>] [--use-logical-sectors] <command> [options]\n\n", app_name);
    printf("Commands:\n");
    printf("  info                                                - Display info about the MTD partition.\n");
    printf("  flash write [--no-erase] <type> <pattern> <block|sector> <size> - Write pattern.\n");
    printf("  flash read <type> <block|sector> <size>             - Read data from flash.\n");
    printf("  flash erase <type> [<start_block|sector> <end_block|sector>] - Erase flash region.\n");
    printf("  flash write-verify <t> <block|sector> <iter> <fail> <log> <full> [file] - Stress test.\n");
    printf("  clr                                                 - Clear terminal screen.\n");
    printf("  help                                                - Show this help message.\n\n");
}

void hexdump(uint64_t base_offset, const unsigned char *data, size_t size) {
    for (size_t i = 0; i < size; i++) {
        if (i % 8 == 0) {
            if (i > 0) printf("\n");
            printf("0x%08" PRIX64 " : ", base_offset + i);
        }
        printf("%02X ", data[i]);
    }
    printf("\n");
}

int mtd_erase_block(int fd, uint64_t offset, const struct mtd_info_user *mtd_info) {
    if (offset > UINT32_MAX) {
        fprintf(stderr, "Error: erase offset 0x%" PRIX64 " >= 32-bit limit; this kernel may require MEMERASE64 support.\n", offset);
        return -1;
    }

    struct erase_info_user lock_info = { .start = (uint32_t)offset, .length = mtd_info->erasesize };
    if (ioctl(fd, MEMUNLOCK, &lock_info) != 0) {
        perror("ioctl(MEMUNLOCK)");
        fprintf(stderr, "Warning: Could not unlock region. Continuing erase anyway.\n");
    }

    struct erase_info_user erase_info = { .start = (uint32_t)offset, .length = mtd_info->erasesize };
    if (ioctl(fd, MEMERASE, &erase_info) != 0) {
        perror("ioctl(MEMERASE)");
        ioctl(fd, MEMLOCK, &lock_info);
        return -1;
    }

    if (ioctl(fd, MEMLOCK, &lock_info) != 0) {
        perror("ioctl(MEMLOCK)");
        fprintf(stderr, "Warning: Could not re-lock region after erase.\n");
    }
    return 0;
}

int mtd_write_data(int fd, uint64_t offset, const void *data, size_t size) {
    if (lseek(fd, (off_t)offset, SEEK_SET) == (off_t)-1) {
        perror("lseek for write");
        return -1;
    }
    
    size_t total_written = 0;
    while (total_written < size) {
        ssize_t written = write(fd, (const char*)data + total_written, size - total_written);
        if (written < 0) {
            if (errno == EINTR) continue; // Interrupted by signal, just retry
            perror("write");
            return -1;
        }
        total_written += written;
    }
    
    if (fsync(fd) != 0) {
        perror("fsync");
        return -1;
    }
    return 0;
}

int mtd_read_data(int fd, uint64_t offset, void *buffer, size_t size) {
    if (lseek(fd, (off_t)offset, SEEK_SET) == (off_t)-1) {
        perror("lseek for read");
        return -1;
    }
    
    size_t total_read = 0;
    while (total_read < size) {
        ssize_t bytes_read = read(fd, (char*)buffer + total_read, size - total_read);
        if (bytes_read < 0) {
            if (errno == EINTR) continue; // Interrupted by signal, just retry
            perror("read");
            return -1;
        }
        if (bytes_read == 0) { // End of file
            fprintf(stderr, "Error: Reached end of device unexpectedly.\n");
            return -1;
        }
        total_read += bytes_read;
    }
    return 0;
}

int get_mtd_info(struct mtd_info_user *mtd_info) {
    int fd = open(g_mtd_device, O_RDONLY);
    if (fd < 0) { perror("open(MEMGETINFO)"); return -1; }
    if (ioctl(fd, MEMGETINFO, mtd_info) != 0) { perror("ioctl(MEMGETINFO)"); close(fd); return -1; }
    close(fd);
    return 0;
}

int validate_block(uint64_t block, const struct mtd_info_user *mtd_info) {
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info->erasesize;
    if (block_size == 0) {
        fprintf(stderr, "Error: Invalid block/sector size 0.\n");
        return -1;
    }
    uint64_t num_blocks = mtd_info->size / block_size;
    if (num_blocks == 0) {
        fprintf(stderr, "Error: Device size (%u) is smaller than the block/sector size (%u).\n", mtd_info->size, block_size);
        return -1;
    }
    if (block >= num_blocks) {
        fprintf(stderr, "Error: Block/sector %" PRIu64 " is out of range. Valid range is 0-%" PRIu64 ".\n", block, num_blocks - 1);
        return -1;
    }
    return 0;
}

int generate_pattern_data(const char* pattern, unsigned char* buffer, size_t size) {
    if (strcmp(pattern, "+") == 0) { for (size_t i = 0; i < size; i++) buffer[i] = (unsigned char)(i & 0xFF);
    } else if (strcmp(pattern, "-") == 0) { for (size_t i = 0; i < size; i++) buffer[i] = (unsigned char)((0xFF - i) & 0xFF);
    } else {
        long val = strtol(pattern, NULL, 16);
        if (val < 0 || val > 255) { fprintf(stderr, "Error: Invalid hex pattern.\n"); return -1; }
        memset(buffer, (unsigned char)val, size);
    }
    return 0;
}

void handle_flash_info(int argc, char *argv[]) {
    if (argc != 0) { fprintf(stderr, "Usage: info\n"); exit(1); }
    
    struct mtd_info_user mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);

    printf("--- MTD Partition Information ---\n");
    printf("Partition Name:      %s\n", mtd_info.name);
    printf("Total Size:          %u bytes (%.1f MiB)\n", mtd_info.size, (float)mtd_info.size / (1024*1024));
    printf("Erase Block Size:    %u bytes (%.1f KiB)\n", mtd_info.erasesize, (float)mtd_info.erasesize / 1024);
    if (mtd_info.erasesize > 0) {
        printf("Total Erase Blocks:  %llu\n", (unsigned long long)mtd_info.size / mtd_info.erasesize);
    }
}

void handle_flash_write(int argc, char *argv[]) {
    int perform_erase = 1;
    int arg_offset = 0;
    if (argc > 0 && strcmp(argv[0], "--no-erase") == 0) {
        perform_erase = 0;
        arg_offset = 1;
        printf(">> --no-erase flag set. Skipping pre-erase.\n");
    }

    if (argc - arg_offset != 4) { fprintf(stderr, "Usage: flash write [--no-erase] <type> <pattern> <block|sector> <size>\n"); exit(1); }
    
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    char *pattern = argv[arg_offset + 1];
    uint64_t block = strtoull(argv[arg_offset + 2], NULL, 0);
    size_t size = strtoul(argv[arg_offset + 3], NULL, 0);

    struct mtd_info_user mtd_info;
    if (get_mtd_info(&mtd_info) != 0 || validate_block(block, &mtd_info) != 0) exit(1);
    
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info.erasesize;
    uint64_t offset = block * block_size;

    if (offset < g_warn_addr) { fprintf(stderr, "!! DANGER: Address 0x%" PRIX64 " is below warning address 0x%" PRIX64 ". Aborting.\n", offset, g_warn_addr); exit(1); }
    if (size == 0 || size > WRITE_SIZE_MAX) { fprintf(stderr, "Error: Size must be between 1 and %d bytes.\n", WRITE_SIZE_MAX); exit(1); }
    if (size > mtd_info.erasesize) { fprintf(stderr, "Error: Write size (%zu) cannot be larger than a physical erase block (%u).\n", size, mtd_info.erasesize); exit(1); }

    unsigned char *data_buffer = malloc(size);
    if (!data_buffer || generate_pattern_data(pattern, data_buffer, size) != 0) {
        fprintf(stderr, "Error allocating or generating pattern data.\n");
        if(data_buffer) free(data_buffer);
        exit(1);
    }

    int fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); free(data_buffer); exit(1); }

    printf("Writing %zu bytes to block/sector %" PRIu64 " (Offset 0x%" PRIX64 ")...\n", size, block, offset);
    
    if (perform_erase) {
        uint64_t erase_offset = (offset / mtd_info.erasesize) * mtd_info.erasesize;
        printf("Pre-erasing block at offset 0x%" PRIX64 "...\n", erase_offset);
        if (mtd_erase_block(fd, erase_offset, &mtd_info) != 0) {
            free(data_buffer); close(fd); exit(1);
        }
    }

    if (mtd_write_data(fd, offset, data_buffer, size) != 0) {
        free(data_buffer); close(fd); exit(1);
    }
    
    free(data_buffer);
    close(fd);
    printf("Write successful.\n");
}

void handle_flash_read(int argc, char *argv[]) {
    if (argc != 3) { fprintf(stderr, "Usage: flash read <type> <block|sector> <size>\n"); exit(1); }
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    uint64_t block = strtoull(argv[1], NULL, 0);
    size_t size = strtoul(argv[2], NULL, 0);

    struct mtd_info_user mtd_info;
    if (get_mtd_info(&mtd_info) != 0 || validate_block(block, &mtd_info) != 0) exit(1);
    
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info.erasesize;
    uint64_t offset = block * block_size;

    if (size == 0 || size > WRITE_SIZE_MAX) { fprintf(stderr, "Error: Size must be between 1 and %d bytes.\n", WRITE_SIZE_MAX); exit(1); }

    unsigned char *data_buffer = malloc(size);
    if (!data_buffer) { fprintf(stderr, "Error: malloc failed.\n"); exit(1); }
    
    int fd = open(g_mtd_device, O_RDONLY);
    if (fd < 0) { perror("open"); free(data_buffer); exit(1); }
    
    if (mtd_read_data(fd, offset, data_buffer, size) != 0) {
        free(data_buffer); close(fd); exit(1);
    }
    close(fd);
    
    printf("sector=0x%" PRIX64 " size=%zu\n", offset, size);
    printf("Data read followed by sector 0x%" PRIX64 "\n", offset);
    hexdump(offset, data_buffer, size);
    free(data_buffer);
}

void handle_flash_erase(int argc, char *argv[]) {
    if (argc < 1) { fprintf(stderr, "Usage: flash erase <type> [<start_block|sector> <end_block|sector>]\n"); exit(1); }
    char type = argv[0][0];

    struct mtd_info_user mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);

    if (type == 'C') {
        if (argc != 1) { fprintf(stderr, "Usage: flash erase C\n"); exit(1); }
        printf("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
        printf("You are about to erase the ENTIRE MTD partition named \"%s\".\n", mtd_info.name);
        printf("This will destroy ALL data on this partition (%u bytes).\n", mtd_info.size);
        printf("This operation is IRREVERSIBLE.\n\n");
        printf("To confirm, type the exact phrase 'ERASE-PARTITION' and press Enter.\n> ");

        char confirmation[32];
        if (fgets(confirmation, sizeof(confirmation), stdin)) {
            confirmation[strcspn(confirmation, "\n")] = 0;
            if (strcmp(confirmation, "ERASE-PARTITION") == 0) {
                printf("\nConfirmation accepted. Proceeding with partition erase.\n");
            } else {
                printf("\nConfirmation failed. Aborting.\n");
                exit(1);
            }
        } else {
            printf("\nCould not read confirmation. Aborting.\n");
            exit(1);
        }

        printf("Erasing entire partition \"%s\" (%u bytes)...\n", mtd_info.name, mtd_info.size);
        int fd = open(g_mtd_device, O_RDWR);
        if (fd < 0) { perror("open"); exit(1); }
        
        if (mtd_info.erasesize == 0) { fprintf(stderr, "Error: Invalid erasesize 0.\n"); close(fd); exit(1); }
        uint64_t num_blocks = mtd_info.size / mtd_info.erasesize;
        for (uint64_t i = 0; i < num_blocks; i++) {
            if (g_signal_received) { break; }
            uint64_t current_offset = i * mtd_info.erasesize;
            printf("Erasing block %" PRIu64 "/%" PRIu64 " at offset 0x%" PRIX64 "...\n", i + 1, num_blocks, current_offset);
            if (mtd_erase_block(fd, current_offset, &mtd_info) != 0) {
                close(fd);
                exit(1);
            }
        }
        close(fd);
        if (!g_signal_received) {
            printf("Erase successful.\n");
        }
        return;
    }

    if (argc != 3) { fprintf(stderr, "Usage: flash erase <Z|Y|O> <start_block|sector> <end_block|sector>\n"); exit(1); }
    uint64_t start_block = strtoull(argv[1], NULL, 0);
    uint64_t end_block = strtoull(argv[2], NULL, 0);

    uint32_t requested_erase_size = 0;
    switch(type) {
        case 'Z': requested_erase_size = 4096; break;
        case 'Y': requested_erase_size = 32768; break;
        case 'O': requested_erase_size = 131072; break;
        default: fprintf(stderr, "Error: Invalid erase type '%c'. Use Z, Y, O, or C.\n", type); exit(1);
    }
    
    if (requested_erase_size != mtd_info.erasesize) {
        fprintf(stderr, "Error: Unsupported erase size. Requested %u bytes (Type %c), but device requires %u bytes.\n",
                requested_erase_size, type, mtd_info.erasesize);
        exit(1);
    }
    printf("Requested erase size %u bytes (Type %c) is supported by device.\n", requested_erase_size, type);

    if (validate_block(start_block, &mtd_info) != 0 || validate_block(end_block, &mtd_info) != 0) exit(1);
    if (start_block > end_block) { fprintf(stderr, "Error: Start block cannot be greater than end block.\n"); exit(1); }

    int fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); exit(1); }

    printf("Erasing from block/sector %" PRIu64 " to %" PRIu64 "...\n", start_block, end_block);
    
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info.erasesize;

    for (uint64_t i = start_block; i <= end_block; i++) {
        if (g_signal_received) { break; }
        uint64_t current_offset = i * block_size;
        
        uint64_t num_phys_blocks = block_size / mtd_info.erasesize;

        for (uint64_t j = 0; j < num_phys_blocks; j++) {
            if (g_signal_received) { goto end_erase_loop; }
            uint64_t physical_offset = current_offset + (j * mtd_info.erasesize);
            if (physical_offset < g_warn_addr) { 
                fprintf(stderr, "!! DANGER: Address 0x%" PRIX64 " is below warning address 0x%" PRIX64 ". Aborting.\n", physical_offset, g_warn_addr);
                goto end_erase_loop;
            }
            printf("Erasing physical block at offset 0x%" PRIX64 "...\n", physical_offset);
            if (mtd_erase_block(fd, physical_offset, &mtd_info) != 0) {
                close(fd);
                exit(1);
            }
        }
    }
end_erase_loop:
    
    close(fd);
    if (!g_signal_received) {
        printf("Erase successful.\n");
    }
}

void handle_flash_write_verify(int argc, char *argv[]) {
    if (argc < 6 || argc > 7) { fprintf(stderr, "Usage: flash write-verify <t> <block> <iter> <fail> <log> <full> [file]\n"); exit(1); }
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    uint64_t start_block = strtoull(argv[1], NULL, 0);
    uint64_t iterations = strtoull(argv[2], NULL, 0);
    uint64_t fail_stop_count = strtoull(argv[3], NULL, 0);
    int log_enable = atoi(argv[4]);
    int full_sector_util = atoi(argv[5]);
    const char* file_path = (argc == 7) ? argv[6] : NULL;

    unsigned long long iter_count = 0, fail_count = 0, logged_fails = 0, total_pass = 0;
    
    printf("--- Starting MTD Write-Verify Stress Test ---\n");
    printf("Start Block: %" PRIu64 " | Iterations: %s | Stop on Fails: %s\n", 
            start_block, (iterations == 0) ? "Infinite" : argv[2], (fail_stop_count == 0) ? "No" : argv[3]);

    struct mtd_info_user mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);
    if (validate_block(start_block, &mtd_info) != 0) exit(1);
    
    if (g_use_logical_sectors && (LOGICAL_SECTOR_SIZE % mtd_info.erasesize) != 0) {
        fprintf(stderr,"Error: logical sector size (%u) is not a multiple of device erasesize (%u).\n",
                LOGICAL_SECTOR_SIZE, mtd_info.erasesize);
        exit(1);
    }

    int fd = -1;
    unsigned char *write_buf = NULL;
    unsigned char *read_buf = NULL;

    fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); exit(1); }
    
    uint32_t block_size = g_use_logical_sectors ? LOGICAL_SECTOR_SIZE : mtd_info.erasesize;
    uint64_t max_blocks = mtd_info.size / block_size;
    write_buf = malloc(block_size);
    read_buf = malloc(block_size);
    if (!write_buf || !read_buf) { fprintf(stderr, "Malloc failed for test buffers\n"); close(fd); exit(1); }

    off_t file_size = 0;
    if (file_path) {
        printf("Using data from file: %s\n", file_path);
        FILE *f = fopen(file_path, "rb");
        if (!f) { perror("fopen"); free(write_buf); free(read_buf); close(fd); exit(1); }
        if (fseeko(f, 0, SEEK_END) != 0) { perror("fseeko"); fclose(f); exit(1); }
        file_size = ftello(f);
        if (fseeko(f, 0, SEEK_SET) != 0) { perror("fseeko"); fclose(f); exit(1); }
        if (file_size > block_size) {
            fprintf(stderr, "Error: File size (%" PRIdMAX ") exceeds block/sector size (%u).\n", (intmax_t)file_size, block_size);
            fclose(f); free(write_buf); free(read_buf); close(fd); exit(1);
        }
        memset(write_buf, 0xFF, block_size);
        if (fread(write_buf, 1, file_size, f) != (size_t)file_size) {
            fprintf(stderr, "Error reading from file.\n");
            fclose(f); free(write_buf); free(read_buf); close(fd); exit(1);
        }
        fclose(f);
    }

    while ((iterations == 0 || iter_count < iterations) && !g_signal_received) {
        iter_count++;
        uint64_t current_block = start_block;
        if (full_sector_util) {
            uint64_t safe_block_start = (g_warn_addr + block_size - 1) / block_size;
            uint64_t num_safe_blocks = max_blocks - safe_block_start;
            if (num_safe_blocks <= 0) { fprintf(stderr, "\nError: No safe blocks available for full utilization test.\n"); break; }
            current_block = safe_block_start + ((iter_count-1) % num_safe_blocks);
        }
        
        if (validate_block(current_block, &mtd_info) != 0) { fprintf(stderr, "\nError: Calculated block %" PRIu64 " is invalid. Stopping.\n", current_block); break; }
        
        uint64_t offset = current_block * block_size;
        if (!file_path) {
            generate_pattern_data("+", write_buf, block_size);
            write_buf[0] = iter_count & 0xFF;
        }

        printf("Test Progress: Iter %llu | Block %" PRIu64 " | Erasing... ", iter_count, current_block);
        fflush(stdout);
        if (mtd_erase_block(fd, offset, &mtd_info) != 0) { fail_count++; if(log_enable) fprintf(stderr, "\nErase fail on block %" PRIu64 "\n", current_block); continue; }
        
        printf("Writing... ");
        fflush(stdout);
        if (mtd_write_data(fd, offset, write_buf, block_size) != 0) { fail_count++; if(log_enable) fprintf(stderr, "\nWrite fail on block %" PRIu64 "\n", current_block); continue; }
        
        printf("Verifying... ");
        fflush(stdout);
        if (mtd_read_data(fd, offset, read_buf, block_size) != 0) { fail_count++; if(log_enable) fprintf(stderr, "\nRead fail on block %" PRIu64 "\n", current_block); continue; }

        if (memcmp(write_buf, read_buf, block_size) == 0) {
            total_pass++;
            printf("PASS\n");
        } else {
            fail_count++;
            printf("FAIL\n");
            if (log_enable && logged_fails < MAX_FAILURE_LOGS) {
                logged_fails++;
                uint64_t mismatch_offset = -1;
                for (uint32_t i = 0; i < block_size; i++) {
                    if (write_buf[i] != read_buf[i]) {
                        mismatch_offset = i;
                        break;
                    }
                }
                printf("[LOG %llu/%d] VERIFY FAILED!\n", logged_fails, MAX_FAILURE_LOGS);
                printf("----------------------------------------\n");
                printf("  - Failure Count: %llu\n", fail_count);
                printf("  - Block:         %" PRIu64 "\n", current_block);
                if (mismatch_offset != (uint64_t)-1) {
                    printf("  - Byte Offset:   0x%08" PRIX64 " (%" PRIu64 ")\n", mismatch_offset, mismatch_offset);
                    printf("  - Expected Data: 0x%02X\n", write_buf[mismatch_offset]);
                    printf("  - Actual Data:   0x%02X\n", read_buf[mismatch_offset]);
                }
                printf("----------------------------------------\n");
            }
            if (fail_stop_count > 0 && fail_count >= fail_stop_count) { fprintf(stderr, "Stopping test: Maximum fail count reached.\n"); break; }
        }
    }
    
    free(write_buf); 
    free(read_buf);
    close(fd);
    printf("--- Test Complete ---\n");
}
