meta-custom/
├── conf/
│   └── layer.conf
└── recipes-flash-tool/
    └── flash-tool/
        ├── files/
        │   ├── flash_tool.c
        │   ├── Makefile
        │   ├── README.txt
        │   └── SAMPLE_OUTPUT.txt
        └── flash-tool_0.1.bb

// meta-custom/conf/layer.conf
# We have a conf and classes directory, add to BBPATH
BBPATH .= ":${LAYERDIR}"

# We have recipes-* directories, add to BBFILES
BBFILES += "${LAYERDIR}/recipes-*/*/*.bb \
            ${LAYERDIR}/recipes-*/*/*.bbappend"

BBFILE_COLLECTIONS += "meta-custom"
BBFILE_PATTERN_meta-custom = "^${LAYERDIR}/"
BBFILE_PRIORITY_meta-custom = "6"

LAYERDEPENDS_meta-custom = "core"
# Added "zeus" for compatibility with older Yocto versions.
LAYERSERIES_COMPAT_meta-custom = "zeus kirkstone nanbield"


//meta-custom/recipes-flash-tool/flash-tool/flash-tool_0.1.bbSUMMARY = "An advanced CLI tool for safe flash operations via the MTD subsystem"
DESCRIPTION = "A non-interactive command-line utility that uses the native MTD subsystem to read, write, erase, and stress-test flash memory safely."
LICENSE = "CLOSED"

DEPENDS = "mtd-utils-native"

SRC_URI = "file://flash_tool.c \
           file://Makefile \
           file://README.txt \
           file://SAMPLE_OUTPUT.txt \
          "

S = "${WORKDIR}"

do_compile() {
	oe_runmake
}

do_install() {
	install -d ${D}${bindir}
	install -m 0755 ${S}/flash_tool ${D}${bindir}/flash_tool

    install -d ${D}${docdir}/${PN}
    install -m 0644 ${S}/README.txt ${D}${docdir}/${PN}/
    install -m 0644 ${S}/SAMPLE_OUTPUT.txt ${D}${docdir}/${PN}/
}

//meta-custom/recipes-flash-tool/flash-tool/files/Makefile
# Makefile for flash_tool
TARGET=flash_tool
SRCS=flash_tool.c

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(SRCS)
	$(CC) $(CFLAGS) -o $(TARGET) $(SRCS)

clean:
	rm -f $(TARGET)

 // meta-custom/recipes-flash-tool/flash-tool/files/README.txt
NXP i.MX8 Flash Tool (Advanced MTD Version)
============================================
Version: 7.2 (August 22, 2025)

This document provides instructions for the flash_tool CLI. This version uses the standard
Linux MTD subsystem for all flash operations, ensuring safety and compatibility.

1. GLOBAL OPTIONS
-------------------
  --mtd-dev <path>      (Default: /dev/mtd0)
  --warn-addr <hex>     (Default: 0x200000)

2. COMMAND REFERENCE & USAGE EXAMPLES
-------------------------------------

  **info**
    - Displays information about the selected MTD partition.

  ---
  **flash write [--no-erase] <type> <pattern> <sector> <size>**
    - Writes data to flash.

  ---
  **flash read <type> <sector> <size>**
    - Reads data from flash and displays it as a hex dump (8 bytes per row).

  ---
  **flash erase <type> [<start_sector> <end_sector>]**
    - Erases a region of flash with verbose, block-by-block progress.

  ---
  **flash write-verify <type> <sector> <iter> <fail> <log> <full> [file_path]**
    - Performs a continuous write-read-verify stress test.
    - **[file_path] (Optional):** Path to a file to use as the data source.
    - **<log> (1=Enabled):** When enabled, logs detailed information for the
      first 64 failures.
    - **<fail> (e.g., 5):** When set to a non-zero value, the test will stop
      automatically after this many failures are detected.

  ---
  **clr / help**
    - Clears the screen or displays the help message.

// meta-custom/recipes-flash-tool/flash-tool/files/SAMPLE_OUTPUT.txt
This file shows sample output for various flash-tool commands.

----------------------------------------------------------------------
1. Info Command
   # flash-tool --mtd-dev /dev/mtd4 info
----------------------------------------------------------------------
>> Using MTD device: /dev/mtd4
--- MTD Partition Information ---
Partition Name:      user-data
Total Size:          33554432 bytes (32.0 MiB)
Erase Block Size:    131072 bytes (128.0 KiB)
Min. IO Size:        1 bytes

----------------------------------------------------------------------
2. Write Command
   # flash-tool --mtd-dev /dev/mtd4 flash write P + 32 16
----------------------------------------------------------------------
>> Using MTD device: /dev/mtd4
Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.
Writing 16 bytes to sector 32 (Offset 0x2000000)...
Pre-erasing alignment block at 0x2000000...
Issuing MEMERASE: start=0x2000000, length=0x20000
Write successful.

----------------------------------------------------------------------
3. Read Command (8 bytes per row format)
   # flash-tool --mtd-dev /dev/mtd4 flash read P 32 16
----------------------------------------------------------------------
>> Using MTD device: /dev/mtd4
Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.
sector=0x2000000 size=16
Data read followed by sector 0x2000000
0x02000000 : 00 01 02 03 04 05 06 07
0x02000008 : 08 09 0A 0B 0C 0D 0E 0F

----------------------------------------------------------------------
4. Multi-Block Erase Command
   # flash-tool --mtd-dev /dev/mtd4 flash erase O 20 21
----------------------------------------------------------------------
>> Using MTD device: /dev/mtd4
Requested erase size 131072 bytes (Type O) is supported by device.
Erasing from sector 20 to 21 (Offset 0x1400000, Length 0x40000)...
Erasing block 1/2 at offset 0x1400000...
Issuing MEMERASE: start=0x1400000, length=0x20000
Erasing block 2/2 at offset 0x1420000...
Issuing MEMERASE: start=0x1420000, length=0x20000
Erase successful.

----------------------------------------------------------------------
5. Write-Verify Command Reaching Max Failures
   # flash-tool --mtd-dev /dev/mtd4 flash write-verify P 40 0 1 1 0
   (This test is set to stop after 1 failure)
----------------------------------------------------------------------
>> Using MTD device: /dev/mtd4
Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.
--- Starting MTD Write-Verify Stress Test ---
Start Sector: 40 | Iterations: Infinite | Stop on Fails: 1

[LOG 1/64] VERIFY FAILED!
----------------------------------------
  - Failure Count: 1
  - Sector:        40
  - Byte Offset:   0x0000001A (26)
  - Expected Data: 0x1A
  - Actual Data:   0xBA
----------------------------------------
Stopping test: Maximum fail count reached.
--- Test Complete ---

//meta-custom/recipes-flash-tool/flash-tool/files/flash_tool.c
/*
 * flash_tool.c
 *
 * An advanced, non-interactive command-line utility for an NXP i.MX8 board.
 * This version uses the native MTD subsystem for safe flash interaction.
 *
 * This version includes:
 * - An 'info' command to display MTD partition details.
 * - Configurable MTD device path and warning address.
 * - Optional no-erase flag for the write command.
 * - A dangerous but confirmed partition erase command.
 * - The proper MEMUNLOCK/MEMLOCK ioctl sequence for robust erasing.
 * - Signal handling for graceful shutdown on Ctrl+C.
 * - A reusable hexdump function for clean output (8 bytes per row).
 * - Advanced write-verify with optional file input and detailed failure logging.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <ctype.h>
#include <mtd/mtd-user.h>
#include <signal.h>

#define BOOTLOADER_WARN_ADDR_DEFAULT 0x200000
#define SECTOR_SIZE (128 * 1024)
#define WRITE_SIZE_MAX 256
#define MAX_FAILURE_LOGS 64

// Global variables for configuration
unsigned long g_warn_addr = BOOTLOADER_WARN_ADDR_DEFAULT;
const char *g_mtd_device = "/dev/mtd0";
volatile sig_atomic_t g_signal_received = 0;

// Prototypes
void signal_handler(int signum);
void hexdump(long base_offset, const unsigned char *data, long size);
void print_help(const char *app_name);
int generate_pattern_data(const char* pattern, unsigned char* buffer, long size);
int mtd_erase_region(int fd, long offset, long len, const mtd_info_t *mtd_info);
int get_mtd_info(mtd_info_t *mtd_info);
int validate_sector(long sector, const mtd_info_t *mtd_info);
void handle_flash_info(int argc, char *argv[]);
void handle_flash_write(int argc, char *argv[]);
void handle_flash_read(int argc, char *argv[]);
void handle_flash_erase(int argc, char *argv[]);
void handle_flash_write_verify(int argc, char *argv[]);

void signal_handler(int signum) {
    g_signal_received = 1;
    fprintf(stderr, "\nSignal %d received. Finishing current operation and shutting down gracefully...\n", signum);
}

int main(int argc, char *argv[]) {
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    char *exec_name = argv[0];
    int arg_offset = 1;
    while (arg_offset < argc) {
        if (strcmp(argv[arg_offset], "--warn-addr") == 0) {
            if (arg_offset + 1 >= argc) { fprintf(stderr, "Error: --warn-addr requires a value.\n"); return 1; }
            g_warn_addr = strtoul(argv[arg_offset + 1], NULL, 16);
            printf(">> Custom Warning Address set to 0x%lX\n", g_warn_addr);
            arg_offset += 2;
        } else if (strcmp(argv[arg_offset], "--mtd-dev") == 0) {
            if (arg_offset + 1 >= argc) { fprintf(stderr, "Error: --mtd-dev requires a path.\n"); return 1; }
            g_mtd_device = argv[arg_offset + 1];
            printf(">> Using MTD device: %s\n", g_mtd_device);
            arg_offset += 2;
        } else { break; }
    }
    
    argc -= arg_offset;
    argv += arg_offset;

    if (argc < 1) { print_help(exec_name); return 1; }
    
    if (strcmp(argv[0], "flash") == 0) {
        if (argc < 2) { fprintf(stderr, "Error: Missing flash subcommand.\n"); print_help(exec_name); return 1; }
        char *sub_cmd = argv[1];
        if (strcmp(sub_cmd, "write") == 0) handle_flash_write(argc-2, argv+2);
        else if (strcmp(sub_cmd, "read") == 0) handle_flash_read(argc-2, argv+2);
        else if (strcmp(sub_cmd, "erase") == 0) handle_flash_erase(argc-2, argv+2);
        else if (strcmp(sub_cmd, "write-verify") == 0) handle_flash_write_verify(argc-2, argv+2);
        else { fprintf(stderr, "Error: Unknown flash command '%s'.\n", sub_cmd); print_help(exec_name); return 1; }
    } else if (strcmp(argv[0], "info") == 0) { handle_flash_info(argc-1, argv+1);
    } else if (strcmp(argv[0], "clr") == 0) { printf("\033[H\033[J");
    } else if (strcmp(argv[0], "help") == 0) { print_help(exec_name);
    } else { fprintf(stderr, "Error: Unknown command '%s'.\n", argv[0]); print_help(exec_name); return 1; }
    
    return 0;
}

void print_help(const char *app_name) {
    printf("NXP i.MX8 Flash Tool (Advanced MTD Version)\n\n");
    printf("Usage: %s [--mtd-dev <path>] [--warn-addr <hex>] <command> [options]\n\n", app_name);
    printf("Commands:\n");
    printf("  info                                                - Display info about the MTD partition.\n");
    printf("  flash write [--no-erase] <type> <pattern> <sector> <size> - Write pattern.\n");
    printf("  flash read <type> <sector> <size>                   - Read data from flash.\n");
    printf("  flash erase <type> [<start_sector> <end_sector>]    - Erase flash region.\n");
    printf("  flash write-verify <t> <sec> <iter> <fail> <log> <full> [file] - Stress test.\n");
    printf("  clr                                                 - Clear terminal screen.\n");
    printf("  help                                                - Show this help message.\n\n");
}

void hexdump(long base_offset, const unsigned char *data, long size) {
    for (long i = 0; i < size; i++) {
        if (i % 8 == 0) {
            if (i > 0) printf("\n");
            printf("0x%08lX : ", base_offset + i);
        }
        printf("%02X ", data[i]);
    }
    printf("\n");
}

int mtd_erase_region(int fd, long offset, long len, const mtd_info_t *mtd_info) {
    struct erase_info_user lock_info = { .start = (uint32_t)offset, .length = (uint32_t)len };
    if (ioctl(fd, MEMUNLOCK, &lock_info) != 0) {
        perror("ioctl(MEMUNLOCK)");
        fprintf(stderr, "Warning: Could not unlock region. Continuing erase anyway.\n");
    }

    struct erase_info_user erase_info = { .start = (uint32_t)offset, .length = (uint32_t)len };
    printf("Issuing MEMERASE: start=0x%x, length=0x%x\n", erase_info.start, erase_info.length);
    if (ioctl(fd, MEMERASE, &erase_info) != 0) {
        perror("ioctl(MEMERASE)");
        ioctl(fd, MEMLOCK, &lock_info);
        return -1;
    }

    if (ioctl(fd, MEMLOCK, &lock_info) != 0) {
        perror("ioctl(MEMLOCK)");
        fprintf(stderr, "Warning: Could not re-lock region after erase.\n");
    }
    return 0;
}

int get_mtd_info(mtd_info_t *mtd_info) {
    int fd = open(g_mtd_device, O_RDONLY);
    if (fd < 0) { perror("open(MEMGETINFO)"); return -1; }
    if (ioctl(fd, MEMGETINFO, mtd_info) != 0) { perror("ioctl(MEMGETINFO)"); close(fd); return -1; }
    close(fd);
    return 0;
}

int validate_sector(long sector, const mtd_info_t *mtd_info) {
    long max_sector = mtd_info->size / SECTOR_SIZE - 1;
    if (sector < 0 || sector > max_sector) {
        fprintf(stderr, "Error: Sector %ld is out of range. Valid range for this device is 0-%ld.\n", sector, max_sector);
        return -1;
    }
    return 0;
}

int generate_pattern_data(const char* pattern, unsigned char* buffer, long size) {
    if (strcmp(pattern, "+") == 0) { for (long i = 0; i < size; i++) buffer[i] = (unsigned char)(i & 0xFF);
    } else if (strcmp(pattern, "-") == 0) { for (long i = 0; i < size; i++) buffer[i] = (unsigned char)((0xFF - i) & 0xFF);
    } else {
        char *endptr;
        long val = strtol(pattern, &endptr, 16);
        if (*endptr != '\0' || val < 0 || val > 255) { fprintf(stderr, "Error: Invalid hex pattern.\n"); return -1; }
        memset(buffer, (unsigned char)val, size);
    }
    return 0;
}

void handle_flash_info(int argc, char *argv[]) {
    if (argc != 0) { fprintf(stderr, "Usage: info\n"); exit(1); }
    
    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);

    printf("--- MTD Partition Information ---\n");
    printf("Partition Name:      %s\n", mtd_info.name);
    printf("Total Size:          %u bytes (%.1f MiB)\n", mtd_info.size, (float)mtd_info.size / (1024*1024));
    printf("Erase Block Size:    %u bytes (%.1f KiB)\n", mtd_info.erasesize, (float)mtd_info.erasesize / 1024);
    printf("Min. IO Size:        %u bytes\n", mtd_info.writesize);
}

void handle_flash_write(int argc, char *argv[]) {
    int perform_erase = 1;
    int arg_offset = 0;
    if (argc > 0 && strcmp(argv[0], "--no-erase") == 0) {
        perform_erase = 0;
        arg_offset = 1;
        printf(">> --no-erase flag set. Skipping pre-erase.\n");
    }

    if (argc - arg_offset != 4) { fprintf(stderr, "Usage: flash write [--no-erase] <type> <pattern> <sector> <size>\n"); exit(1); }
    
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    char *pattern = argv[arg_offset + 1];
    long sector = strtol(argv[arg_offset + 2], NULL, 0);
    long size = strtol(argv[arg_offset + 3], NULL, 0);
    long offset = sector * SECTOR_SIZE;

    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0 || validate_sector(sector, &mtd_info) != 0) exit(1);

    if (offset < g_warn_addr) { fprintf(stderr, "!! DANGER: Address 0x%lX is below warning address 0x%lX. Aborting.\n", offset, g_warn_addr); exit(1); }
    if (size <= 0 || size > WRITE_SIZE_MAX) { fprintf(stderr, "Error: Size must be between 1 and %d bytes.\n", WRITE_SIZE_MAX); exit(1); }

    unsigned char *data_buffer = malloc(size);
    if (!data_buffer || generate_pattern_data(pattern, data_buffer, size) != 0) {
        fprintf(stderr, "Error allocating or generating pattern data.\n");
        if(data_buffer) free(data_buffer);
        exit(1);
    }

    int fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); free(data_buffer); exit(1); }

    printf("Writing %ld bytes to sector %ld (Offset 0x%lX)...\n", size, sector, offset);
    
    if (perform_erase) {
        long erase_offset = (offset / mtd_info.erasesize) * mtd_info.erasesize;
        printf("Pre-erasing alignment block at 0x%lX...\n", erase_offset);
        if (mtd_erase_region(fd, erase_offset, mtd_info.erasesize, &mtd_info) != 0) {
            free(data_buffer); close(fd); exit(1);
        }
    }

    if (lseek(fd, offset, SEEK_SET) == (off_t)-1) { perror("lseek"); free(data_buffer); close(fd); exit(1); }
    
    ssize_t written = write(fd, data_buffer, size);
    
    free(data_buffer);
    close(fd);

    if (written != size) { fprintf(stderr, "Error: Wrote %ld of %ld bytes.\n", written, size); perror("write"); exit(1); }
    printf("Write successful.\n");
}

void handle_flash_read(int argc, char *argv[]) {
    if (argc != 3) { fprintf(stderr, "Usage: flash read <type> <sector> <size>\n"); exit(1); }
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    long sector = strtol(argv[1], NULL, 0);
    long size = strtol(argv[2], NULL, 0);
    long offset = sector * SECTOR_SIZE;

    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0 || validate_sector(sector, &mtd_info) != 0) exit(1);
    if (size <= 0 || size > WRITE_SIZE_MAX) { fprintf(stderr, "Error: Size must be between 1 and %d bytes.\n", WRITE_SIZE_MAX); exit(1); }

    unsigned char *data_buffer = malloc(size);
    if (!data_buffer) { fprintf(stderr, "Error: malloc failed.\n"); exit(1); }
    
    int fd = open(g_mtd_device, O_RDONLY);
    if (fd < 0) { perror("open"); free(data_buffer); exit(1); }
    
    lseek(fd, offset, SEEK_SET);
    ssize_t bytes_read = read(fd, data_buffer, size);
    close(fd);

    if (bytes_read < 0) { perror("read"); free(data_buffer); exit(1); }
    
    printf("sector=0x%lX size=%ld\n", offset, bytes_read);
    printf("Data read followed by sector 0x%lX\n", offset);
    hexdump(offset, data_buffer, bytes_read);
    free(data_buffer);
}

void handle_flash_erase(int argc, char *argv[]) {
    if (argc < 1) { fprintf(stderr, "Usage: flash erase <type> [<start_sector> <end_sector>]\n"); exit(1); }
    char type = argv[0][0];

    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);

    if (type == 'C') {
        if (argc != 1) { fprintf(stderr, "Usage: flash erase C\n"); exit(1); }
        printf("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
        printf("You are about to erase the ENTIRE MTD partition named \"%s\".\n", mtd_info.name);
        printf("This will destroy ALL data on this partition (%u bytes).\n", mtd_info.size);
        printf("This operation is IRREVERSIBLE.\n\n");
        printf("To confirm, type the exact phrase 'ERASE-PARTITION' and press Enter.\n> ");

        char confirmation[32];
        if (fgets(confirmation, sizeof(confirmation), stdin)) {
            confirmation[strcspn(confirmation, "\n")] = 0;
            if (strcmp(confirmation, "ERASE-PARTITION") == 0) {
                printf("\nConfirmation accepted. Proceeding with partition erase.\n");
            } else {
                printf("\nConfirmation failed. Aborting.\n");
                exit(1);
            }
        } else {
            printf("\nCould not read confirmation. Aborting.\n");
            exit(1);
        }

        printf("Erasing entire partition \"%s\" (%u bytes)...\n", mtd_info.name, mtd_info.size);
        int fd = open(g_mtd_device, O_RDWR);
        if (fd < 0) { perror("open"); exit(1); }
        if (mtd_erase_region(fd, 0, mtd_info.size, &mtd_info) != 0) {
            close(fd);
            exit(1);
        }
        close(fd);
        printf("Erase successful.\n");
        return;
    }

    if (argc != 3) { fprintf(stderr, "Usage: flash erase <Z|Y|O> <start_sector> <end_sector>\n"); exit(1); }
    long start_sector = strtol(argv[1], NULL, 0);
    long end_sector = strtol(argv[2], NULL, 0);

    long requested_erase_size = 0;
    switch(type) {
        case 'Z': requested_erase_size = 4096; break;
        case 'Y': requested_erase_size = 32768; break;
        case 'O': requested_erase_size = 131072; break;
        default: fprintf(stderr, "Error: Invalid erase type '%c'. Use Z, Y, O, or C.\n", type); exit(1);
    }
    
    if (requested_erase_size != mtd_info.erasesize) {
        fprintf(stderr, "Error: Unsupported erase size. Requested %ld bytes (Type %c), but device requires %u bytes.\n",
                requested_erase_size, type, mtd_info.erasesize);
        exit(1);
    }
    printf("Requested erase size %ld bytes (Type %c) is supported by device.\n", requested_erase_size, type);

    if (validate_sector(start_sector, &mtd_info) != 0 || validate_sector(end_sector, &mtd_info) != 0) exit(1);
    if (start_sector > end_sector) { fprintf(stderr, "Error: Start sector cannot be greater than end sector.\n"); exit(1); }

    long offset = start_sector * SECTOR_SIZE;
    long len = (end_sector - start_sector + 1) * SECTOR_SIZE;

    if (offset < g_warn_addr) { fprintf(stderr, "!! DANGER: Address 0x%lX is below warning address 0x%lX. Aborting.\n", offset, g_warn_addr); exit(1); }
    
    int fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); exit(1); }

    printf("Erasing from sector %ld to %ld (Offset 0x%lX, Length 0x%lX)...\n", start_sector, end_sector, offset, len);
    
    long num_blocks = len / mtd_info.erasesize;
    for (long i = 0; i < num_blocks; i++) {
        if (g_signal_received) { break; }
        long current_offset = offset + (i * mtd_info.erasesize);
        printf("Erasing block %ld/%ld at offset 0x%lX...\n", i + 1, num_blocks, current_offset);
        if (mtd_erase_region(fd, current_offset, mtd_info.erasesize, &mtd_info) != 0) {
            close(fd);
            exit(1);
        }
    }
    
    close(fd);
    if (!g_signal_received) {
        printf("Erase successful.\n");
    }
}

void handle_flash_write_verify(int argc, char *argv[]) {
    if (argc < 6 || argc > 7) { fprintf(stderr, "Usage: flash write-verify <t> <sec> <iter> <fail> <log> <full> [file]\n"); exit(1); }
    printf("Note: <type> parameter is for syntax compatibility; MTD driver selects hardware mode.\n");
    long start_sector = strtol(argv[1], NULL, 0);
    long iterations = strtol(argv[2], NULL, 0);
    long fail_stop_count = strtol(argv[3], NULL, 0);
    int log_enable = atoi(argv[4]);
    int full_sector_util = atoi(argv[5]);
    const char* file_path = (argc == 7) ? argv[6] : NULL;

    unsigned long long iter_count = 0, fail_count = 0, logged_fails = 0, total_pass = 0;
    
    printf("--- Starting MTD Write-Verify Stress Test ---\n");
    printf("Start Sector: %ld | Iterations: %s | Stop on Fails: %s\n", 
            start_sector, (iterations == 0) ? "Infinite" : argv[2], (fail_stop_count == 0) ? "No" : argv[3]);

    mtd_info_t mtd_info;
    if (get_mtd_info(&mtd_info) != 0) exit(1);
    if (validate_sector(start_sector, &mtd_info) != 0) exit(1);

    int fd = open(g_mtd_device, O_RDWR);
    if (fd < 0) { perror("open"); exit(1); }
    
    long max_sectors = mtd_info.size / SECTOR_SIZE;
    unsigned char *write_buf = malloc(SECTOR_SIZE);
    unsigned char *read_buf = malloc(SECTOR_SIZE);
    if (!write_buf || !read_buf) { fprintf(stderr, "Malloc failed for test buffers\n"); close(fd); exit(1); }

    long file_size = 0;
    if (file_path) {
        printf("Using data from file: %s\n", file_path);
        FILE *f = fopen(file_path, "rb");
        if (!f) { perror("fopen"); free(write_buf); free(read_buf); close(fd); exit(1); }
        fseek(f, 0, SEEK_END);
        file_size = ftell(f);
        fseek(f, 0, SEEK_SET);
        if (file_size > SECTOR_SIZE) {
            fprintf(stderr, "Error: File size (%ld) exceeds sector size (%d).\n", file_size, SECTOR_SIZE);
            fclose(f); free(write_buf); free(read_buf); close(fd); exit(1);
        }
        memset(write_buf, 0xFF, SECTOR_SIZE);
        if (fread(write_buf, 1, file_size, f) != file_size) {
            fprintf(stderr, "Error reading from file.\n");
            fclose(f); free(write_buf); free(read_buf); close(fd); exit(1);
        }
        fclose(f);
    }

    while ((iterations == 0 || iter_count < iterations) && !g_signal_received) {
        iter_count++;
        long current_sector = start_sector;
        if (full_sector_util) {
            long safe_sector_start = (g_warn_addr + SECTOR_SIZE - 1) / SECTOR_SIZE;
            long num_safe_sectors = max_sectors - safe_sector_start;
            if (num_safe_sectors <= 0) { fprintf(stderr, "\nError: No safe sectors available for full utilization test.\n"); break; }
            current_sector = safe_sector_start + ((iter_count-1) % num_safe_sectors);
        }
        
        if (validate_sector(current_sector, &mtd_info) != 0) { fprintf(stderr, "\nError: Calculated sector %ld is invalid. Stopping.\n", current_sector); break; }
        
        long offset = current_sector * SECTOR_SIZE;
        if (!file_path) {
            generate_pattern_data("+", write_buf, SECTOR_SIZE);
            write_buf[0] = iter_count & 0xFF;
        }

        if (mtd_erase_region(fd, offset, SECTOR_SIZE, &mtd_info) != 0) { fail_count++; if(log_enable) fprintf(stderr, "\nErase fail on sector %ld\n", current_sector); continue; }
        lseek(fd, offset, SEEK_SET);
        if (write(fd, write_buf, SECTOR_SIZE) != SECTOR_SIZE) { fail_count++; if(log_enable) fprintf(stderr, "\nWrite fail on sector %ld\n", current_sector); continue; }
        lseek(fd, offset, SEEK_SET);
        if (read(fd, read_buf, SECTOR_SIZE) != SECTOR_SIZE) { fail_count++; if(log_enable) fprintf(stderr, "\nRead fail on sector %ld\n", current_sector); continue; }

        if (memcmp(write_buf, read_buf, SECTOR_SIZE) == 0) {
            total_pass++;
        } else {
            fail_count++;
            if (log_enable && logged_fails < MAX_FAILURE_LOGS) {
                logged_fails++;
                long mismatch_offset = -1;
                for (long i = 0; i < SECTOR_SIZE; i++) {
                    if (write_buf[i] != read_buf[i]) {
                        mismatch_offset = i;
                        break;
                    }
                }
                printf("\n[LOG %llu/%d] VERIFY FAILED!\n", logged_fails, MAX_FAILURE_LOGS);
                printf("----------------------------------------\n");
                printf("  - Failure Count: %llu\n", fail_count);
                printf("  - Sector:        %ld\n", current_sector);
                if (mismatch_offset != -1) {
                    printf("  - Byte Offset:   0x%08lX (%ld)\n", mismatch_offset, mismatch_offset);
                    printf("  - Expected Data: 0x%02X\n", write_buf[mismatch_offset]);
                    printf("  - Actual Data:   0x%02X\n", read_buf[mismatch_offset]);
                }
                printf("----------------------------------------\n");
            }
            if (fail_stop_count > 0 && fail_count >= fail_stop_count) { fprintf(stderr, "\nStopping test: Maximum fail count reached.\n"); break; }
        }
        
        printf("Test Progress: Iter %llu | Sector %ld | Pass: %llu | Fail: %llu\n", iter_count, current_sector, total_pass, fail_count);
    }
    
    free(write_buf); free(read_buf);
    close(fd);
    printf("--- Test Complete ---\n");
}
