#ifndef CLOUD_COMM_H_
#define CLOUD_COMM_H_

#include <functional>
#include <string>
#include <string_view>
#include <cstdint>
#include <atomic>

// --- Include RapidJSON headers directly ---
#include "rapidjson/document.h"
#include "rapidjson/value.h"
// -----------------------------------------

// Include the AWS client header directly
#include "aws_iot_mqtt_client.hpp" // Defines AwsIot::MqttConfig

// --- Forward declare or include your custom logging header ---
// Assuming log_print::kERROR etc are defined elsewhere in your project
namespace log_print {
    enum LogLevel { kERROR, kWARN, kINFO, kDEBUG1, kVERBOSE };
}
// Assuming LOG_PRINT macro is defined elsewhere, e.g.:
// #define LOG_PRINT(level, tag, format, ...) YourLogImplementation(level, TAG, format, ##__VA_ARGS__)
// -------------------------------------------------------------


namespace CloudComms {

// --- Constants ---
constexpr std::size_t kMaxPayloadSize = 1024;   ///< Max JSON payload size for internal stack buffers
constexpr std::size_t kMaxCommandKeyLen = 64;   ///< Max length for a command key name from shadow
constexpr std::size_t kMaxThingNameLen = 128;   ///< Max length for the Thing Name itself
// Reconnect Timing Defaults
constexpr uint32_t kInitialBackoffMs = 1000;    // 1 second initial reconnect delay
constexpr uint32_t kMaxBackoffMs = 60000;       // 60 seconds maximum reconnect delay

/**
 * @brief Configuration struct passed to Initialize. All fields are required,
 * except for MQTT buffer sizes which have defaults.
 */
struct CloudCommConfig {
    // --- Connectivity ---
    std::string aws_endpoint; ///< REQUIRED AWS IoT Core endpoint URL.
    std::string client_id;    ///< REQUIRED Unique MQTT client ID for this device.
    std::string thing_name;   ///< REQUIRED AWS IoT Thing Name (max kMaxThingNameLen-1 chars).
    // Port 8883 is hardcoded internally

    // --- Certificates (Full Paths Required) ---
    std::string root_ca_path;       ///< REQUIRED Full path to the Root CA certificate PEM file.
    std::string device_cert_path;   ///< REQUIRED Full path to the device certificate PEM file.
    std::string private_key_path;   ///< REQUIRED Full path to the device private key PEM file.

    // --- Optional MQTT Tuning ---
    int mqtt_rx_buffer_size = 2048; ///< Underlying MQTT receive buffer size. Default 2048.
    int mqtt_tx_buffer_size = 2048; ///< Underlying MQTT transmit buffer size. Default 2048.
};


// --- Callbacks ---
/**
 * @brief Callback function type for handling control commands received via shadow.
 * @param command_name The key in the desired state object representing the command.
 * @param params A RapidJSON Value object containing the parameters for the command.
 * The object's lifetime is tied to the callback execution.
 * @return True if command processing was successful, false otherwise. If true, the
 * application should call ReportCurrentState() to update the shadow.
 */
using ControlCommandCallback = std::function<bool(const std::string& command_name, const rapidjson::Value& params)>;

/**
 * @brief Callback function type for connection status changes (informational).
 * @param connected True if connected, false if disconnected.
 */
using ConnectionStatusCallback = std::function<void(bool connected)>;


/**
 * @class CloudComm
 * @brief Provides an application-focused interface for cloud communication using AWS IoT.
 * Handles reporting telemetry and processing shadow commands. Requires periodic
 * calls to Process() for connection management.
 */
class CloudComm {
public:
    CloudComm();
    ~CloudComm();

    // Disable copy/move
    CloudComm(const CloudComm&) = delete;
    CloudComm& operator=(const CloudComm&) = delete;
    CloudComm(CloudComm&&) = delete;
    CloudComm& operator=(CloudComm&&) = delete;

    /**
     * @brief Initializes the cloud communication module using provided configuration.
     * Loads certificates from the fully specified paths in the config struct.
     * Configures the underlying client and sets up necessary subscriptions.
     * @param config Configuration settings containing endpoint, IDs, full cert paths etc.
     * @return True if initialization was successful, false otherwise.
     */
    bool Initialize(const CloudCommConfig& config);

    /**
     * @brief Initiates a connection attempt to AWS IoT Core.
     * Handles the transition to the CONNECTING state. Use Process() to manage retries.
     * @param reset_retry_state If true (default), resets the internal reconnect backoff state. Call with true for application-initiated connections.
     * @return True if the connection attempt was newly initiated or already in progress/connected, false on immediate error.
     */
    bool Connect(bool reset_retry_state = true);

    /**
     * @brief Disconnects from the AWS IoT Core broker.
     * Resets the internal state to DISCONNECTED and stops automatic retries.
     */
    void Disconnect();

    /**
     * @brief Checks the current connection status (based on last known event).
     * @return True if the internal state is CONNECTED, false otherwise.
     */
    bool IsConnected() const;

    /**
     * @brief Processes internal state, including reconnection logic.
     * MUST be called periodically by the application to handle connection retries.
     */
    void Process();

    // --- Device to Cloud Reports ---
    bool SendTimeSeriesData(const rapidjson::Value& data, int qos = 0);
    bool SendStatusReport(const rapidjson::Value& data, int qos = 1);
    bool SendEvent(const std::string& event_type, const rapidjson::Value& data, int qos = 1);

    // --- Device to Cloud Shadow State ---
    /**
     * @brief Reports the device's current state to the AWS IoT Shadow 'reported' section.
     * Call this after successfully processing a command from the shadow 'desired' state,
     * or anytime the device needs to proactively report its state.
     * @param reported_state A RapidJSON Value object (must be an object type) representing the state to report.
     * @param qos The Quality of Service level (usually 1).
     * @return True if the state report was successfully queued, false otherwise.
     */
    bool ReportCurrentState(const rapidjson::Value& reported_state, int qos = 1);

    // --- Callback Setters ---
    void SetControlCommandCallback(ControlCommandCallback callback);
    void SetConnectionStatusCallback(ConnectionStatusCallback callback);

private:
    // --- Internal State Machine ---
    enum class State { UNINITIALIZED, DISCONNECTED, CONNECTING, CONNECTED, WAITING_TO_RETRY };
    std::atomic<State> current_state_{State::UNINITIALIZED};

    // --- Private Constants ---
    static constexpr uint16_t kDefaultMqttPort = 8883;
    static constexpr int kDefaultMqttRxBufferSize = 2048;
    static constexpr int kDefaultMqttTxBufferSize = 2048;

    // --- Private Helper Methods ---
    bool LoadCertificateFromFile(const char* full_path, char* buffer, std::size_t buffer_size);
    bool BuildTopicString(char* buffer, std::size_t buffer_len, const char* type_suffix);
    bool PublishJsonToTopic(const char* topic, const rapidjson::Value& json_payload, int qos, bool retain = false);
    void RequestShadowState();
    // AcknowledgeControlCommand removed - replaced by application calling ReportCurrentState
    void ProcessReceivedShadowDelta(const rapidjson::Value& delta_state);
    void ProcessReceivedShadowDocument(std::string_view payload);
    uint64_t GetTimestampMs();
    void HandleDisconnectInternal();
    bool AttemptReconnect();
    bool CommonInitializeSetup();

    // --- Internal Callbacks ---
    void OnConnected();
    void OnDisconnected();
    void HandleShadowCallback(const std::string& update_type, std::string_view payload);

    // --- Member Variables ---
    AwsIot::AwsIotMqttClient aws_mqtt_client_;
    char thing_name_[kMaxThingNameLen] = {0};
    ControlCommandCallback control_command_callback_{nullptr};
    ConnectionStatusCallback connection_status_callback_{nullptr};
    // Reusable internal buffers
    char json_parse_buffer_[kMaxPayloadSize] = {0};
    char json_serialize_buffer_[kMaxPayloadSize] = {0};
    // Reconnect State
    uint64_t last_disconnect_time_ms_ = 0;
    uint32_t current_backoff_delay_ms_ = kInitialBackoffMs;
    int reconnect_attempts_ = 0;
};

} // namespace CloudComms

#endif // CLOUD_COMM_H_
------------------------------------------------------------------------------------------------------------
#include "cloud_comm.h"

#include <fstream>
#include <utility>   // For std::move
#include <cstring>   // For memcpy, strlen, strncpy, memset
#include <cstdio>    // For snprintf
#include <algorithm> // For std::min

// Required RapidJSON includes for implementation
#include "rapidjson/memorystream.h" // For MemoryOutputStream
#include "rapidjson/writer.h"       // For Writer

// --- Platform specific includes & Logging ---
#ifdef ESP_PLATFORM
#include "esp_timer.h" // For esp_timer_get_time
#include "esp_log.h"   // If using ESP_LOG for the LOG_PRINT macro backend
static const char* TAG = "CloudComm";
// Define LOG_PRINT using ESP_LOGx here if not defined globally
#ifndef LOG_PRINT
#define LOG_PRINT(level, tag, format, ...) do { \
    switch(level) { \
        case log_print::kERROR:   ESP_LOGE(tag, format, ##__VA_ARGS__); break; \
        case log_print::kWARN:    ESP_LOGW(tag, format, ##__VA_ARGS__); break; \
        case log_print::kINFO:    ESP_LOGI(tag, format, ##__VA_ARGS__); break; \
        case log_print::kDEBUG1:  ESP_LOGD(tag, format, ##__VA_ARGS__); break; \
        case log_print::kVERBOSE: ESP_LOGV(tag, format, ##__VA_ARGS__); break; \
        default:                  ESP_LOGI(tag, format, ##__VA_ARGS__); break; \
    } \
} while(0)
#endif // LOG_PRINT

#else
// Define basic logging macros and a dummy time function if not ESP_PLATFORM
#include <iostream>
#include <chrono>
#define LOG_PRINT(level, tag, format, ...) printf("[%s] %d: " format "\n", tag, static_cast<int>(level), ##__VA_ARGS__)
static const char* TAG = "CloudComm";
// Dummy time function for non-ESP platforms
uint64_t esp_timer_get_time() {
    auto now = std::chrono::high_resolution_clock::now();
    auto duration = now.time_since_epoch();
    return std::chrono::duration_cast<std::chrono::microseconds>(duration).count();
}
#endif
// ------------------------------------------


namespace CloudComms {

// --- Define static constexpr members ---
// No default paths needed anymore
constexpr uint16_t CloudComm::kDefaultMqttPort;
constexpr int CloudComm::kDefaultMqttRxBufferSize;
constexpr int CloudComm::kDefaultMqttTxBufferSize;

// --- Topic constants ---
const char* const kDefaultTopicPrefix = "dt";
const char* const kTimeSeriesTopicSuffix = "/timeseries";
const char* const kStatusTopicSuffix = "/status";
const char* const kEventTopicSuffix = "/event";

// --- Constructor / Destructor ---
CloudComm::CloudComm() : current_state_(State::UNINITIALIZED) {
    LOG_PRINT(log_print::kINFO, TAG, "CloudComm instance created.");
    memset(thing_name_, 0, sizeof(thing_name_));
    memset(json_parse_buffer_, 0, sizeof(json_parse_buffer_));
    memset(json_serialize_buffer_, 0, sizeof(json_serialize_buffer_));
}

CloudComm::~CloudComm() {
    LOG_PRINT(log_print::kINFO, TAG, "CloudComm instance destroying...");
    State current = current_state_.load();
    if (current != State::UNINITIALIZED && current != State::DISCONNECTED) {
         Disconnect();
    }
    LOG_PRINT(log_print::kINFO, TAG, "CloudComm instance destroyed.");
}


// --- Initialization ---
bool CloudComm::Initialize(const CloudCommConfig& config) {
     LOG_PRINT(log_print::kINFO, TAG, "Initializing CloudComm...");

    if (current_state_.load() != State::UNINITIALIZED) {
        LOG_PRINT(log_print::kWARN, TAG, "Already initialized or initializing.");
        return (current_state_.load() != State::UNINITIALIZED);
    }

    // --- Validate ALL Required Parameters ---
    if (config.aws_endpoint.empty() || config.client_id.empty() || config.thing_name.empty() ||
        config.root_ca_path.empty() || config.device_cert_path.empty() || config.private_key_path.empty()) {
        LOG_PRINT(log_print::kERROR, TAG, "Initialize failed: Endpoint, Client ID, Thing Name, and all Certificate Paths are required.");
        return false;
    }
    if (config.thing_name.length() >= sizeof(thing_name_)) {
         LOG_PRINT(log_print::kERROR, TAG, "Initialize failed: Thing name '%s' too long (max %zu chars).",
                 config.thing_name.c_str(), sizeof(thing_name_) - 1);
        return false;
    }

    // --- Store Thing Name ---
    strncpy(thing_name_, config.thing_name.c_str(), sizeof(thing_name_) - 1);
    thing_name_[sizeof(thing_name_) - 1] = '\0';

    // --- Prepare Underlying Client Config (Temporary on stack) ---
    AwsIot::MqttConfig client_config = {};
    client_config.aws_endpoint = config.aws_endpoint;
    client_config.client_id = config.client_id;
    client_config.thing_name = config.thing_name;
    client_config.port = kDefaultMqttPort;
    client_config.rx_buffer_size = config.mqtt_rx_buffer_size > 0 ? config.mqtt_rx_buffer_size : kDefaultMqttRxBufferSize;
    client_config.tx_buffer_size = config.mqtt_tx_buffer_size > 0 ? config.mqtt_tx_buffer_size : kDefaultMqttTxBufferSize;
    LOG_PRINT(log_print::kINFO, TAG, "MQTT Buffers: RX=%d, TX=%d", client_config.rx_buffer_size, client_config.tx_buffer_size);

    // --- Load Certificates using fully specified paths from config ---
    LOG_PRINT(log_print::kINFO, TAG, "Loading certificates from specified paths...");

    LOG_PRINT(log_print::kDEBUG1, TAG, "Loading CA from: %s", config.root_ca_path.c_str());
    if (!LoadCertificateFromFile(config.root_ca_path.c_str(), client_config.root_ca_pem, AwsIot::kMaxCertLen)) {
        LOG_PRINT(log_print::kERROR, TAG,"Failed to load CA cert: %s", config.root_ca_path.c_str()); return false;
    }
    LOG_PRINT(log_print::kDEBUG1, TAG, "Loading device cert from: %s", config.device_cert_path.c_str());
    if (!LoadCertificateFromFile(config.device_cert_path.c_str(), client_config.device_cert_pem, AwsIot::kMaxCertLen)) {
         LOG_PRINT(log_print::kERROR, TAG,"Failed to load device cert: %s", config.device_cert_path.c_str()); return false;
    }
    LOG_PRINT(log_print::kDEBUG1, TAG, "Loading private key from: %s", config.private_key_path.c_str());
    if (!LoadCertificateFromFile(config.private_key_path.c_str(), client_config.private_key_pem, AwsIot::kMaxCertLen)) {
        LOG_PRINT(log_print::kERROR, TAG,"Failed to load private key: %s", config.private_key_path.c_str()); return false;
    }
    LOG_PRINT(log_print::kDEBUG1, TAG, "Certificates loaded successfully.");

    // --- Initialize Underlying Client ---
    if (!aws_mqtt_client_.Initialize(client_config)) {
        LOG_PRINT(log_print::kERROR, TAG, "Failed to initialize underlying AwsIotMqttClient.");
        return false;
    }

    // --- Common Setup Steps (Callbacks & Subscriptions) ---
    if (!CommonInitializeSetup()) {
        aws_mqtt_client_.Disconnect(); // Attempt cleanup
        return false;
    }

    // --- Set Initial State ---
    current_state_.store(State::DISCONNECTED);
    last_disconnect_time_ms_ = 0;
    current_backoff_delay_ms_ = kInitialBackoffMs;
    reconnect_attempts_ = 0;
    LOG_PRINT(log_print::kINFO, TAG, "CloudComm initialized successfully for Thing: %s. State: DISCONNECTED.", thing_name_);
    return true;
}


/**
 * @brief Common setup steps called by Initialize.
 */
bool CloudComm::CommonInitializeSetup() {
    aws_mqtt_client_.SetOnConnectedCallback([this]() { this->OnConnected(); });
    aws_mqtt_client_.SetOnDisconnectedCallback([this]() { this->OnDisconnected(); });

    LOG_PRINT(log_print::kDEBUG1, TAG, "Setting up shadow subscriptions.");
    auto shadow_handler = [this](const std::string& type, std::string_view payload) {
        this->HandleShadowCallback(type, payload);
    };
    if (!aws_mqtt_client_.SubscribeToShadowUpdates(shadow_handler)) {
        LOG_PRINT(log_print::kERROR, TAG, "Common setup failed: Shadow update subscription failed!");
        return false;
    }
    if (!aws_mqtt_client_.SubscribeToShadowGetResponses(shadow_handler)) {
        LOG_PRINT(log_print::kERROR, TAG, "Common setup failed: Shadow get response subscription failed!");
        return false;
    }
    return true;
}


// --- Connection Management ---
bool CloudComm::Connect(bool reset_retry_state) {
    State current = current_state_.load();
    LOG_PRINT(log_print::kINFO, TAG, "Connect requested by application (reset_retry=%s). Current state: %d",
             reset_retry_state ? "true" : "false", static_cast<int>(current));

    if (current == State::UNINITIALIZED) { LOG_PRINT(log_print::kERROR, TAG, "Cannot connect: Not initialized."); return false; }
    if (current == State::CONNECTING || current == State::CONNECTED) { LOG_PRINT(log_print::kWARN, TAG, "Connect called while already %s.", (current == State::CONNECTING) ? "connecting" : "connected"); return true; }

    if (reset_retry_state) {
        LOG_PRINT(log_print::kDEBUG1, TAG, "Resetting reconnect state due to explicit connect call.");
        reconnect_attempts_ = 0;
        current_backoff_delay_ms_ = kInitialBackoffMs;
        last_disconnect_time_ms_ = 0;
    }
    return AttemptReconnect(); // AttemptReconnect changes state if successful initiation
}

// Internal function that actually calls the underlying client connect
bool CloudComm::AttemptReconnect() {
    LOG_PRINT(log_print::kINFO, TAG, "Attempting MQTT connection (Attempt #%d)...", reconnect_attempts_ + 1);
    State expected_disconnected = State::DISCONNECTED;
    State expected_waiting = State::WAITING_TO_RETRY;
    // Try to transition from WAITING or DISCONNECTED to CONNECTING atomically
    if (!current_state_.compare_exchange_strong(expected_waiting, State::CONNECTING) &&
        !current_state_.compare_exchange_strong(expected_disconnected, State::CONNECTING))
    {
         State actual_state = current_state_.load();
         LOG_PRINT(log_print::kWARN, TAG, "AttemptReconnect failed: Could not transition from WAITING/DISCONNECTED state. Current state: %d", static_cast<int>(actual_state));
         return false;
    }
    // --- State is now CONNECTING ---
    if (!aws_mqtt_client_.Connect()) { // Call underlying client's connect
        LOG_PRINT(log_print::kWARN, TAG, "Underlying aws_mqtt_client_.Connect() call failed initiation.");
        // Treat as immediate disconnect to trigger retry via Process()
        HandleDisconnectInternal();
        return false;
    }
    LOG_PRINT(log_print::kDEBUG1, TAG, "MQTT connection attempt initiated. State: CONNECTING.");
    reconnect_attempts_++;
    return true; // Indicate initiation succeeded
}

void CloudComm::Disconnect() {
    LOG_PRINT(log_print::kINFO, TAG, "Disconnect requested by application.");
    State previous_state = current_state_.exchange(State::DISCONNECTED); // Set state immediately
    if (previous_state != State::UNINITIALIZED && previous_state != State::DISCONNECTED) {
         LOG_PRINT(log_print::kDEBUG1, TAG,"Calling underlying MQTT disconnect.");
         aws_mqtt_client_.Disconnect();
    } else { LOG_PRINT(log_print::kDEBUG1, TAG,"Already disconnected or uninitialized."); }
    // Reset reconnect state
    reconnect_attempts_ = 0;
    current_backoff_delay_ms_ = kInitialBackoffMs;
    last_disconnect_time_ms_ = 0;
}

bool CloudComm::IsConnected() const {
    return (current_state_.load() == State::CONNECTED);
}

/**
 * @brief Helper to get timestamp in milliseconds using esp_timer.
 */
uint64_t CloudComm::GetTimestampMs() {
    return esp_timer_get_time() / 1000; // microseconds to milliseconds
}

/**
 * @brief Handles internal state updates and notifications upon disconnection event.
 */
void CloudComm::HandleDisconnectInternal() {
    State previous_state = current_state_.load();
    // Only process if we were previously connected or trying to connect
    if (previous_state == State::CONNECTED || previous_state == State::CONNECTING) {
        LOG_PRINT(log_print::kWARN, TAG, "Internal: Handling disconnection event. Previous state: %d", (int)previous_state);
        last_disconnect_time_ms_ = GetTimestampMs();
        // Calculate next backoff delay
        uint64_t next_delay = static_cast<uint64_t>(current_backoff_delay_ms_) * 2;
        current_backoff_delay_ms_ = static_cast<uint32_t>(std::min(next_delay, static_cast<uint64_t>(kMaxBackoffMs)));
        // Attempt to set state to WAITING_TO_RETRY
        State expected_state = previous_state;
        if (current_state_.compare_exchange_strong(expected_state, State::WAITING_TO_RETRY)) {
            LOG_PRINT(log_print::kINFO, TAG, "State changed to WAITING_TO_RETRY. Next attempt (#%d) in %u ms.", reconnect_attempts_ +1, current_backoff_delay_ms_);
             if (connection_status_callback_) { connection_status_callback_(false); }
        } else {
             LOG_PRINT(log_print::kWARN, TAG, "Disconnect handling aborted: State changed unexpectedly from %d to %d.", (int)previous_state, (int)expected_state);
        }
    } else {
        LOG_PRINT(log_print::kDEBUG1, TAG, "Internal: Ignoring redundant disconnect event while in state %d.", (int)previous_state);
    }
}

// --- Process Function ---
void CloudComm::Process() {
    State state = current_state_.load();

    if (state == State::WAITING_TO_RETRY) {
        uint64_t now_ms = GetTimestampMs();
        if (now_ms >= (last_disconnect_time_ms_ + current_backoff_delay_ms_)) {
            LOG_PRINT(log_print::kINFO, TAG, "Process: Retry timer elapsed. Attempting reconnect...");
            AttemptReconnect(); // Changes state to CONNECTING if successful initiation
        }
    }
    // Add verbose logging for other states if needed for debugging
    // else if (state == State::CONNECTING) { LOG_PRINT(log_print::kVERBOSE, TAG, "Process: In CONNECTING state..."); }
    // else if (state == State::CONNECTED) { LOG_PRINT(log_print::kVERBOSE, TAG, "Process: In CONNECTED state."); }
    // else if (state == State::DISCONNECTED) { LOG_PRINT(log_print::kVERBOSE, TAG, "Process: In DISCONNECTED state."); }
}


// --- Data Sending Logic ---
bool CloudComm::SendTimeSeriesData(const rapidjson::Value& data, int qos) { if (!IsConnected()) { LOG_PRINT(log_print::kWARN, TAG, "Not connected"); return false; } char topic_buffer[AwsIot::kMaxTopicLen]; if (!BuildTopicString(topic_buffer, sizeof(topic_buffer), kTimeSeriesTopicSuffix)) return false; LOG_PRINT(log_print::kDEBUG1, TAG, "Sending time series data to topic: %s", topic_buffer); return PublishJsonToTopic(topic_buffer, data, qos); }
bool CloudComm::SendStatusReport(const rapidjson::Value& data, int qos) { if (!IsConnected()) { LOG_PRINT(log_print::kWARN, TAG, "Not connected"); return false; } if (!data.IsObject()) { LOG_PRINT(log_print::kERROR, TAG, "Status data must be object"); return false; } char topic_buffer[AwsIot::kMaxTopicLen]; if (!BuildTopicString(topic_buffer, sizeof(topic_buffer), kStatusTopicSuffix)) return false; LOG_PRINT(log_print::kDEBUG1, TAG, "Sending status report to topic: %s", topic_buffer); return PublishJsonToTopic(topic_buffer, data, qos); }
bool CloudComm::SendEvent(const std::string& event_type, const rapidjson::Value& data, int qos) { if (!IsConnected()) { LOG_PRINT(log_print::kWARN, TAG, "Not connected"); return false; } if (event_type.empty() || !data.IsObject()) { LOG_PRINT(log_print::kERROR, TAG, "Invalid event args"); return false; } char topic_buffer[AwsIot::kMaxTopicLen]; if (!BuildTopicString(topic_buffer, sizeof(topic_buffer), kEventTopicSuffix)) return false; rapidjson::Document event_doc(rapidjson::kObjectType); auto& allocator = event_doc.GetAllocator(); event_doc.AddMember("event_type", rapidjson::StringRef(event_type.c_str()), allocator); event_doc.AddMember("details", rapidjson::Value(data, allocator).Move(), allocator); LOG_PRINT(log_print::kDEBUG1, TAG, "Sending event '%s' to topic: %s", event_type.c_str(), topic_buffer); return PublishJsonToTopic(topic_buffer, event_doc, qos); }
bool CloudComm::ReportCurrentState(const rapidjson::Value& reported_state, int qos) { if (!IsConnected()) { LOG_PRINT(log_print::kWARN, TAG,"Not connected"); return false; } if (!reported_state.IsObject()) { LOG_PRINT(log_print::kERROR, TAG,"Reported state must be object"); return false; } rapidjson::Document shadow_doc(rapidjson::kObjectType); auto& allocator = shadow_doc.GetAllocator(); rapidjson::Value state_val(rapidjson::kObjectType); state_val.AddMember("reported", rapidjson::Value(reported_state, allocator).Move(), allocator); shadow_doc.AddMember("state", state_val, allocator); memset(json_serialize_buffer_, 0, sizeof(json_serialize_buffer_)); rapidjson::MemoryOutputStream os(json_serialize_buffer_, sizeof(json_serialize_buffer_)); rapidjson::Writer<rapidjson::MemoryOutputStream> writer(os); shadow_doc.Accept(writer); const size_t json_len = os.Tell(); if (json_len >= sizeof(json_serialize_buffer_)) { LOG_PRINT(log_print::kERROR, TAG,"Report state JSON too large"); return false; } LOG_PRINT(log_print::kDEBUG1, TAG, "Reporting current state to shadow (%zu bytes): %.*s", json_len, (int)json_len, json_serialize_buffer_); return aws_mqtt_client_.UpdateShadow(std::string_view(json_serialize_buffer_, json_len), qos); }

// --- Callback Setters ---
void CloudComm::SetControlCommandCallback(ControlCommandCallback callback) { control_command_callback_ = std::move(callback); LOG_PRINT(log_print::kINFO, TAG,"Control cb set"); }
void CloudComm::SetConnectionStatusCallback(ConnectionStatusCallback callback) { connection_status_callback_ = std::move(callback); LOG_PRINT(log_print::kINFO, TAG,"Connection cb set"); }

// --- Private Helper Methods ---
bool CloudComm::LoadCertificateFromFile(const char* full_path, char* buffer, std::size_t buffer_size) { if (!full_path || !buffer || buffer_size == 0) return false; memset(buffer, 0, buffer_size); std::ifstream file(full_path); if (!file.is_open()) { LOG_PRINT(log_print::kERROR, TAG, "Failed to open file: %s", full_path); return false; } file.read(buffer, buffer_size - 1); if (file.eof()) { buffer[file.gcount()] = '\0'; file.close(); return true; } else { if (file.fail()) { LOG_PRINT(log_print::kERROR, TAG, "File read failed: %s", full_path); } else { LOG_PRINT(log_print::kERROR, TAG, "Buffer too small for file: %s (Size: %zu)", full_path, buffer_size); } buffer[0] = '\0'; file.close(); return false; } }
bool CloudComm::BuildTopicString(char* buffer, std::size_t buffer_len, const char* type_suffix) { if (!buffer || buffer_len == 0 || !type_suffix || thing_name_[0] == '\0') return false; int written = snprintf(buffer, buffer_len, "%s/%s%s", kDefaultTopicPrefix, thing_name_, type_suffix); if (written < 0 || static_cast<std::size_t>(written) >= buffer_len) { LOG_PRINT(log_print::kERROR, TAG, "BuildTopicString failed/truncated (suffix: %s, len: %zu)", type_suffix, buffer_len); buffer[0] = '\0'; return false; } return true; }
bool CloudComm::PublishJsonToTopic(const char* topic, const rapidjson::Value& json_payload, int qos, bool retain) { memset(json_serialize_buffer_, 0, sizeof(json_serialize_buffer_)); rapidjson::MemoryOutputStream os(json_serialize_buffer_, sizeof(json_serialize_buffer_)); rapidjson::Writer<rapidjson::MemoryOutputStream> writer(os); json_payload.Accept(writer); const size_t json_len = os.Tell(); if (json_len >= sizeof(json_serialize_buffer_)) { LOG_PRINT(log_print::kERROR, TAG,"Publish JSON too large (topic: %s)", topic); return false; } LOG_PRINT(log_print::kVERBOSE, TAG, "Publishing to %s (%zu bytes): %.*s", topic, json_len, (int)json_len, json_serialize_buffer_); return aws_mqtt_client_.Publish(topic, reinterpret_cast<const uint8_t*>(json_serialize_buffer_), json_len, qos, retain); }
void CloudComm::RequestShadowState() { LOG_PRINT(log_print::kINFO, TAG, "Requesting current shadow state..."); if (!aws_mqtt_client_.GetShadow("")) { LOG_PRINT(log_print::kERROR, TAG, "Failed to send shadow get request."); } }
// --- AcknowledgeControlCommand removed ---
void CloudComm::ProcessReceivedShadowDelta(const rapidjson::Value& delta_state) { if (!control_command_callback_) { LOG_PRINT(log_print::kDEBUG1, TAG, "Shadow delta received, but no control command callback registered."); return; } if (!delta_state.IsObject()) { LOG_PRINT(log_print::kERROR, TAG, "ProcessReceivedShadowDelta called with non-object."); return; } LOG_PRINT(log_print::kINFO, TAG, "Processing desired state delta for commands..."); for (auto itr = delta_state.MemberBegin(); itr != delta_state.MemberEnd(); ++itr ) { const char* key_ptr = itr->name.GetString(); const std::size_t key_len = itr->name.GetStringLength(); const rapidjson::Value& params = itr->value; char current_key[kMaxCommandKeyLen]; if (key_len >= sizeof(current_key)) { LOG_PRINT(log_print::kERROR, TAG, "Command key '%.*s...' too long (max %zu). Skipping.", 20, key_ptr, sizeof(current_key) - 1); continue; } memcpy(current_key, key_ptr, key_len); current_key[key_len] = '\0'; LOG_PRINT(log_print::kINFO, TAG, "Invoking callback for command: '%s'", current_key); bool success = control_command_callback_(current_key, params); if (success) { LOG_PRINT(log_print::kINFO, TAG, "Command '%s' processed successfully by application. Application should call ReportCurrentState().", current_key); /* App calls ReportCurrentState */ } else { LOG_PRINT(log_print::kWARN, TAG, "Command '%s' processing failed according to application callback.", current_key); /* Desired state persists */ } } LOG_PRINT(log_print::kINFO, TAG, "Finished processing shadow delta commands iteration."); }
void CloudComm::ProcessReceivedShadowDocument(std::string_view /*payload*/) { rapidjson::Document doc; doc.ParseInsitu(json_parse_buffer_); if (doc.HasParseError()) { LOG_PRINT(log_print::kERROR, TAG,"Re-parse failed in ProcessReceivedShadowDocument"); return; } if (doc.HasMember("state") && doc["state"].IsObject()) { const auto& state_obj = doc["state"]; if (state_obj.HasMember("desired") && state_obj["desired"].IsObject()) { LOG_PRINT(log_print::kINFO, TAG, "Processing 'desired' state from received document."); ProcessReceivedShadowDelta(state_obj["desired"]); } else { LOG_PRINT(log_print::kDEBUG1, TAG, "Received document has no 'desired' state."); } } else { LOG_PRINT(log_print::kWARN, TAG, "Received document missing 'state' object."); } }
void CloudComm::HandleShadowCallback(const std::string& update_type, std::string_view payload) { LOG_PRINT(log_print::kDEBUG1, TAG, "HandleShadowCallback: Type: '%s', Size: %zu", update_type.c_str(), payload.length()); if (payload.length() >= sizeof(json_parse_buffer_)) { LOG_PRINT(log_print::kERROR, TAG,"Shadow payload too large"); return; } memcpy(json_parse_buffer_, payload.data(), payload.length()); json_parse_buffer_[payload.length()] = '\0'; rapidjson::Document doc; doc.ParseInsitu(json_parse_buffer_); if (doc.HasParseError()) { LOG_PRINT(log_print::kERROR, TAG,"Shadow JSON parse error (type %s)", update_type.c_str()); return; } if (update_type == "delta") { if (doc.HasMember("state") && doc["state"].IsObject()) { ProcessReceivedShadowDelta(doc["state"]); } else { LOG_PRINT(log_print::kWARN, TAG, "Delta missing 'state' object."); } } else if (update_type == "accepted") { LOG_PRINT(log_print::kINFO, TAG, "Processing shadow accepted document."); ProcessReceivedShadowDocument(payload); } else if (update_type == "rejected") { LOG_PRINT(log_print::kWARN, TAG, "Received shadow operation rejection."); if (doc.HasMember("message") && doc["message"].IsString()) { LOG_PRINT(log_print::kWARN, TAG, " Rejection message: %s", doc["message"].GetString()); } } else { LOG_PRINT(log_print::kWARN, TAG, "Unhandled shadow callback type: %s", update_type.c_str()); } }

// --- Internal Callbacks (Update State) ---
void CloudComm::OnConnected() { LOG_PRINT(log_print::kINFO, TAG, "Internal: OnConnected event received."); reconnect_attempts_ = 0; current_backoff_delay_ms_ = kInitialBackoffMs; last_disconnect_time_ms_ = 0; current_state_.store(State::CONNECTED); if (connection_status_callback_) { connection_status_callback_(true); } RequestShadowState(); }
void CloudComm::OnDisconnected() { HandleDisconnectInternal(); } // Delegate to internal handler


} // namespace CloudComms
-------------------------------------------------------------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>
#include <string>
#include <chrono>

// Platform specific (ESP-IDF example)
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp_spiffs.h"
#include "esp_system.h"

// CloudComm Module Header
#include "cloud_comm.h" // Your CloudComm header

// RapidJSON Headers (Needed by Application)
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"

// --- Application TAG ---
static const char* APP_TAG = "ShadowExampleApp";

// --- EXAMPLE LOG_PRINT Implementation ---
// Define this properly according to your logging framework
namespace log_print { enum LogLevel { kERROR, kWARN, kINFO, kDEBUG1, kVERBOSE }; }
#ifndef LOG_PRINT
#define LOG_PRINT(level, tag, format, ...) do { \
    switch(level) { \
        case log_print::kERROR:   ESP_LOGE(tag, format, ##__VA_ARGS__); break; \
        case log_print::kWARN:    ESP_LOGW(tag, format, ##__VA_ARGS__); break; \
        case log_print::kINFO:    ESP_LOGI(tag, format, ##__VA_ARGS__); break; \
        case log_print::kDEBUG1:  ESP_LOGD(tag, format, ##__VA_ARGS__); break; \
        case log_print::kVERBOSE: ESP_LOGV(tag, format, ##__VA_ARGS__); break; \
        default:                  ESP_LOGI(tag, format, ##__VA_ARGS__); break; \
    } \
} while(0)
#endif // LOG_PRINT
// --- End EXAMPLE LOG_PRINT ---


// --- Global CloudComm instance ---
CloudComms::CloudComm cloud_comm;

// --- Placeholder for actual device state/actions ---
static bool g_current_led_state = false;
static int g_current_report_interval = 60; // Example state

void SetDeviceLedState(bool on) {
    g_current_led_state = on;
    LOG_PRINT(log_print::kINFO, APP_TAG, "Hardware: Setting LED to %s", on ? "ON" : "OFF");
    // TODO: Add actual hardware control code
}

bool GetDeviceLedState() {
    return g_current_led_state;
}

void SetDeviceReportInterval(int interval_sec) {
     if (interval_sec > 0) {
        g_current_report_interval = interval_sec;
        LOG_PRINT(log_print::kINFO, APP_TAG, "Config: Setting report interval to %d sec", interval_sec);
     } else {
         LOG_PRINT(log_print::kWARN, APP_TAG, "Config: Invalid report interval %d", interval_sec);
     }
}

int GetDeviceReportInterval() {
    return g_current_report_interval;
}

void TriggerReboot() {
    LOG_PRINT(log_print::kWARN, APP_TAG, "Hardware: Rebooting system in 5 seconds...");
    vTaskDelay(pdMS_TO_TICKS(5000));
    esp_restart();
}

// --- Application Callback Implementations ---

void HandleConnectionStatus(bool connected) {
    LOG_PRINT(log_print::kINFO, APP_TAG, "Application Notified: Connection Status = %s", connected ? "CONNECTED" : "DISCONNECTED");
    // Informational only - Process() handles reconnect attempts
}

/**
 * @brief Handles control commands received from the cloud via Shadow delta.
 * *** Application MUST call cloud_comm.ReportCurrentState() on success ***
 * *** to update reported state and clear the desired state.      ***
 * @return True if command processing was successful, False otherwise.
 */
bool HandleControlCommand(const std::string& command_name, const rapidjson::Value& params) {
    LOG_PRINT(log_print::kINFO, APP_TAG, "Application Received Control Command: '%s'", command_name.c_str());
    bool success = false;

    // Prepare a document to report the *resulting state* if successful
    rapidjson::Document reported_doc(rapidjson::kObjectType);
    auto& allocator = reported_doc.GetAllocator();

    if (command_name == "reboot") {
        LOG_PRINT(log_print::kWARN, APP_TAG, "Reboot command received! Executing...");
        TriggerReboot(); // Function won't return
        success = true; // Assume scheduling worked if we somehow get here briefly

    } else if (command_name == "set_led") {
        if (!params.IsObject() || !params.HasMember("state") || !params["state"].IsBool()) {
            LOG_PRINT(log_print::kERROR, APP_TAG, "Invalid params for set_led. Expected {\"state\": <boolean>}.");
            success = false; // Indicate failure: Invalid parameters
        } else {
            bool desired_state = params["state"].GetBool();
            SetDeviceLedState(desired_state); // Perform the action
            success = true; // Assume hardware control worked

            // --- Report Resulting State on Success ---
            if (success) {
                 // Report the *actual* current state using a descriptive key
                 reported_doc.AddMember("led_is_on", GetDeviceLedState(), allocator);
                 // Don't necessarily need to report "set_led": null. Reporting the
                 // actual state key "led_is_on" is often preferred.
            }
            // -----------------------------------------
        }
    } else if (command_name == "update_config") {
         if (!params.IsObject()) {
             LOG_PRINT(log_print::kERROR, APP_TAG, "Invalid params for update_config. Expected JSON object.");
             success = false;
         } else {
             LOG_PRINT(log_print::kINFO, APP_TAG, "Processing configuration update...");
             bool config_changed = false;
             // Example: Extract reporting interval
             if (params.HasMember("report_interval_sec") && params["report_interval_sec"].IsInt()) {
                 int interval = params["report_interval_sec"].GetInt();
                 if (interval >= 5 && interval != GetDeviceReportInterval()) { // Add validation
                    SetDeviceReportInterval(interval);
                    // --- Add to reported state on Success ---
                    // Report back the parameter that was successfully changed
                    reported_doc.AddMember("report_interval_sec", GetDeviceReportInterval(), allocator);
                    config_changed = true;
                 } else if (interval < 5){
                      LOG_PRINT(log_print::kWARN, APP_TAG, "Requested interval %d too low.", interval);
                      // Don't report success if value rejected
                 }
             }
             // Process other config parameters...

             // Assume overall success if at least one valid change occurred, or if no changes requested
             success = true; // Or track more accurately based on validation results
             // If !config_changed but params were present, maybe report status?
             if(success && !config_changed && !params.ObjectEmpty()) {
                 // E.g. requested value was same as current, or invalid value ignored
                 // Report null for the command key to clear desired, as no state changed
                 reported_doc.AddMember(rapidjson::StringRef(command_name.c_str()), rapidjson::Value(), allocator);
             }
             // -----------------------------------------
         }
    } else {
        LOG_PRINT(log_print::kWARN, APP_TAG, "Unknown command received: %s", command_name.c_str());
        success = false; // Indicate failure: Unknown command
    }


    // --- IMPORTANT: Call ReportCurrentState IF successful AND state needs reporting ---
    if (success && !reported_doc.ObjectEmpty()) {
        LOG_PRINT(log_print::kINFO, APP_TAG, "Reporting state back to shadow after processing '%s'.", command_name.c_str());
        if (!cloud_comm.ReportCurrentState(reported_doc)) {
            LOG_PRINT(log_print::kWARN, APP_TAG, "Failed to queue state report for command '%s'.", command_name.c_str());
            // Note: Desired state might not be cleared if reporting fails.
        }
    }
    // -----------------------------------------------------------------------------

    return success; // Return overall status for logging by CloudComm
}

// --- Filesystem Initialization (Example for ESP-IDF SPIFFS) ---
bool init_filesystem() { /* ... Same implementation ... */ LOG_PRINT(log_print::kINFO, APP_TAG,"FS Init done."); return true; }


// --- Main Application Task ---
extern "C" void app_main(void)
{
    LOG_PRINT(log_print::kINFO, APP_TAG, "Starting Application...");

    if (!init_filesystem()) { /* ... handle error ... */ return; }

    // --- Prepare CloudComm Configuration ---
    CloudComms::CloudCommConfig config = {};
    // !! IMPORTANT: Replace placeholders below !!
    config.aws_endpoint = "your_aws_endpoint.iot.region.amazonaws.com"; // CHANGE THIS
    config.client_id = "your_unique_client_id";                       // CHANGE THIS
    config.thing_name = "your_thing_name";                             // CHANGE THIS
    config.root_ca_path = "/spiffs/ca.pem";                           // CHANGE THIS PATH
    config.device_cert_path = "/spiffs/cert.pem";                     // CHANGE THIS PATH
    config.private_key_path = "/spiffs/key.pem";                      // CHANGE THIS PATH
    // config.mqtt_rx_buffer_size = 4096; // Optional override

    // --- Initialize CloudComm ---
    if (!cloud_comm.Initialize(config)) { /* ... handle error ... */ return; }

    // --- Register Callbacks ---
    cloud_comm.SetConnectionStatusCallback(HandleConnectionStatus);
    cloud_comm.SetControlCommandCallback(HandleControlCommand);

    // --- Initiate Connection ---
    LOG_PRINT(log_print::kINFO, APP_TAG, "Initiating connection...");
    cloud_comm.Connect(true); // Start connection attempts

    // --- Main Application Loop ---
    uint64_t loop_counter = 0;
    uint32_t last_proactive_report_time = 0;
    uint32_t proactive_report_interval_ms = 30000; // Report state every 30s

    while (true) {
        // --- CRITICAL: Call Process() periodically ---
        cloud_comm.Process(); // Handles connection state & reconnect timing

        uint64_t now_ms = cloud_comm.GetTimestampMs(); // Get time once per loop

        // --- Application Logic ---
        if (cloud_comm.IsConnected()) {
            // --- Send Periodic Telemetry (example) ---
            if ((loop_counter % 10) == 0) { /* ... SendTimeSeriesData ... */ }

            // --- Proactive State Reporting (example) ---
            if ((now_ms - last_proactive_report_time) >= proactive_report_interval_ms) {
                 last_proactive_report_time = now_ms;
                 LOG_PRINT(log_print::kINFO, APP_TAG, "Proactively reporting current state...");
                 rapidjson::Document current_state_doc(rapidjson::kObjectType);
                 auto& allocator = current_state_doc.GetAllocator();
                 // Include relevant current state information
                 current_state_doc.AddMember("led_is_on", GetDeviceLedState(), allocator);
                 current_state_doc.AddMember("uptime_seconds", (uint32_t)(loop_counter), allocator); // Approx uptime
                 current_state_doc.AddMember("report_interval_sec", GetDeviceReportInterval(), allocator);
                 // Add other important state...

                 if (!cloud_comm.ReportCurrentState(current_state_doc)) {
                      LOG_PRINT(log_print::kWARN, APP_TAG, "Failed to queue proactive state report.");
                 }
            }

        } else {
            // Application is disconnected, Process() handles retries
            LOG_PRINT(log_print::kDEBUG1, APP_TAG, "Waiting for connection...");
        }

        // --- Other application tasks ---
        // ...

        // --- Delay ---
        vTaskDelay(pdMS_TO_TICKS(1000)); // Call Process() approx every second
        loop_counter++;
    }
}
