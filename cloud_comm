#ifndef CLOUD_COMM_H_
#define CLOUD_COMM_H_

#include <functional>
#include <string>       // Still used for config struct members
#include <string_view>
#include <cstdint>
#include <atomic>

// --- Include RapidJSON headers directly ---
#include "rapidjson/document.h"
#include "rapidjson/value.h"
// -----------------------------------------

// Include the AWS client header directly
#include "aws_iot_mqtt_client.hpp" // Defines AwsIot::MqttConfig

// --- Forward declare or include your custom logging header ---
// Assuming log_print::kERROR etc are defined elsewhere in your project
namespace log_print {
    enum LogLevel { kERROR, kWARN, kINFO, kDEBUG1, kVERBOSE };
}
// Assuming LOG_PRINT macro is defined elsewhere
// #define LOG_PRINT(level, tag, format, ...) YourLogImplementation(level, TAG, format, ##__VA_ARGS__)
// -------------------------------------------------------------


namespace CloudComms {

// --- Constants ---
constexpr std::size_t kMaxPayloadSize = 1024;   ///< Max JSON payload size for internal PARSING buffer
constexpr std::size_t kMaxCommandKeyLen = 64;   ///< Max length for a command key name from shadow
constexpr std::size_t kMaxThingNameLen = 128;   ///< Max length for the Thing Name itself
constexpr std::size_t kMaxFilePathLen = 128;    ///< Max length for internal file path buffer if needed (not for config)
// Reconnect Timing Defaults
constexpr uint32_t kInitialBackoffMs = 1000;    // 1 second initial reconnect delay
constexpr uint32_t kMaxBackoffMs = 60000;       // 60 seconds maximum reconnect delay

/**
 * @brief Configuration struct passed to Initialize. All fields are required,
 * except for MQTT buffer sizes which have defaults.
 */
struct CloudCommConfig {
    // --- Connectivity ---
    std::string aws_endpoint; ///< REQUIRED AWS IoT Core endpoint URL.
    std::string client_id;    ///< REQUIRED Unique MQTT client ID for this device.
    std::string thing_name;   ///< REQUIRED AWS IoT Thing Name (max kMaxThingNameLen-1 chars).
    // Port 8883 is hardcoded internally

    // --- Certificates (Full Paths Required) ---
    std::string root_ca_path;       ///< REQUIRED Full path to the Root CA certificate PEM file.
    std::string device_cert_path;   ///< REQUIRED Full path to the device certificate PEM file.
    std::string private_key_path;   ///< REQUIRED Full path to the device private key PEM file.

    // --- Optional MQTT Tuning ---
    int mqtt_rx_buffer_size = 2048; ///< Underlying MQTT receive buffer size. Default 2048.
    int mqtt_tx_buffer_size = 2048; ///< Underlying MQTT transmit buffer size. Default 2048.
};


// --- Callbacks ---
/**
 * @brief Callback function type for handling control commands received via shadow.
 * @param command_name Null-terminated C-string representing the command key.
 * @param params A RapidJSON Value object containing the parameters for the command.
 * @return True if command processing was successful, false otherwise. If true, the
 * application should call ReportCurrentState() to update the shadow.
 */
using ControlCommandCallback = std::function<bool(const char* command_name, const rapidjson::Value& params)>;

/**
 * @brief Callback function type for connection status changes (informational).
 * @param connected True if connected, false if disconnected.
 */
using ConnectionStatusCallback = std::function<void(bool connected)>;


// --- CloudComm Class ---
class CloudComm {
public:
    CloudComm();
    ~CloudComm();

    // Disable copy/move
    CloudComm(const CloudComm&) = delete;
    CloudComm& operator=(const CloudComm&) = delete;
    CloudComm(CloudComm&&) = delete;
    CloudComm& operator=(CloudComm&&) = delete;

    /**
     * @brief Initializes the cloud communication module using provided configuration.
     * Loads certificates from the fully specified paths in the config struct.
     * Configures the underlying client and sets up necessary subscriptions.
     * @param config Configuration settings containing endpoint, IDs, full cert paths etc.
     * @return True if initialization was successful, false otherwise.
     */
    bool Initialize(const CloudCommConfig& config);

    /**
     * @brief Initiates a connection attempt to AWS IoT Core.
     * Handles the transition to the CONNECTING state. Use Process() to manage retries.
     * @param reset_retry_state If true (default), resets the internal reconnect backoff state.
     * @return True if the connection attempt was newly initiated or already in progress/connected, false on immediate error.
     */
    bool Connect(bool reset_retry_state = true);

    /**
     * @brief Disconnects from the AWS IoT Core broker.
     * Resets the internal state to DISCONNECTED and stops automatic retries.
     */
    void Disconnect();

    /**
     * @brief Checks the current connection status (based on last known event).
     * @return True if the internal state is CONNECTED, false otherwise.
     */
    bool IsConnected() const;

    /**
     * @brief Processes internal state, including reconnection logic.
     * MUST be called periodically by the application to handle connection retries.
     */
    void Process();

    // --- Device to Cloud Reports ---
    bool SendTimeSeriesData(const rapidjson::Value& data, int qos = 0);
    bool SendStatusReport(const rapidjson::Value& data, int qos = 1);
    /**
     * @brief Sends a specific event notification to the cloud. Uses dynamic memory
     * (StringBuffer) internally for JSON serialization.
     * @param event_type Null-terminated C-string identifying the type of event.
     * @param data A RapidJSON Value object (must be an object) containing event details.
     * @param qos The Quality of Service level (usually 1 for events).
     * @return True if the event was successfully queued for publishing, false otherwise.
     */
    bool SendEvent(const char* event_type, const rapidjson::Value& data, int qos = 1);

    // --- Device to Cloud Shadow State ---
    /**
     * @brief Reports the device's current state to the AWS IoT Shadow 'reported' section.
     * Call this after successfully processing a command from the shadow 'desired' state,
     * or anytime the device needs to proactively report its state. Uses dynamic memory
     * (StringBuffer) internally for JSON serialization.
     * @param reported_state A RapidJSON Value object (must be an object type) representing the state to report.
     * @param qos The Quality of Service level (usually 1).
     * @return True if the state report was successfully queued, false otherwise.
     */
    bool ReportCurrentState(const rapidjson::Value& reported_state, int qos = 1);

    // --- Callback Setters ---
    void SetControlCommandCallback(ControlCommandCallback callback);
    void SetConnectionStatusCallback(ConnectionStatusCallback callback);

private:
    // --- Internal State Machine ---
    enum class State { UNINITIALIZED, DISCONNECTED, CONNECTING, CONNECTED, WAITING_TO_RETRY };
    std::atomic<State> current_state_{State::UNINITIALIZED};

    // --- Private Constants ---
    static constexpr uint16_t kDefaultMqttPort = 8883;
    static constexpr int kDefaultMqttRxBufferSize = 2048;
    static constexpr int kDefaultMqttTxBufferSize = 2048;

    // --- Private Helper Methods ---
    bool LoadCertificateFromFile(const char* full_path, char* buffer, std::size_t buffer_size);
    bool BuildTopicString(char* buffer, std::size_t buffer_len, const char* type_suffix);
    /**
     * @brief Internal helper to serialize JSON using StringBuffer and publish.
     * NOTE: Uses dynamic memory allocation via StringBuffer.
     */
    bool PublishJsonToTopic(const char* topic, const rapidjson::Value& json_payload, int qos, bool retain = false);
    void RequestShadowState();
    // AcknowledgeControlCommand removed
    void ProcessReceivedShadowDelta(const rapidjson::Value& delta_state);
    void ProcessReceivedShadowDocument(std::string_view payload);
    uint64_t GetTimestampMs();
    void HandleDisconnectInternal();
    bool AttemptReconnect();
    bool CommonInitializeSetup();

    // --- Internal Callbacks ---
    void OnConnected();
    void OnDisconnected();
    // Use correct signature matching AwsIotMqttClient callback type
    void HandleShadowCallback(const std::string& update_type, std::string_view payload);

    // --- Member Variables ---
    AwsIot::AwsIotMqttClient aws_mqtt_client_;
    char thing_name_[kMaxThingNameLen] = {0}; // Fixed buffer
    ControlCommandCallback control_command_callback_{nullptr};
    ConnectionStatusCallback connection_status_callback_{nullptr};
    // Reusable internal buffers
    char json_parse_buffer_[kMaxPayloadSize] = {0}; // For parsing incoming JSON
    // json_serialize_buffer_ removed
    // Reconnect State
    uint64_t last_disconnect_time_ms_ = 0;
    uint32_t current_backoff_delay_ms_ = kInitialBackoffMs;
    int reconnect_attempts_ = 0;
};

} // namespace CloudComms

#endif // CLOUD_COMM_H_

------------------------------------------------------------------------------------------

#include "cloud_comm.h"

#include <fstream>
#include <utility>   // For std::move
#include <cstring>   // For memcpy, strlen, strncpy, memset
#include <cstdio>    // For snprintf
#include <algorithm> // For std::min
#include <string>    // Needed for temporary std::string during init

// --- Required RapidJSON includes for implementation ---
// #include "rapidjson/memorystream.h" // No longer needed
#include "rapidjson/stringbuffer.h" // Include for StringBuffer
#include "rapidjson/writer.h"       // For Writer
// ----------------------------------------------------

// --- Platform specific includes & Logging ---
#ifdef ESP_PLATFORM
#include "esp_timer.h" // For esp_timer_get_time
#include "esp_log.h"   // If using ESP_LOG for the LOG_PRINT macro backend
static const char* TAG = "CloudComm";
// Define LOG_PRINT using ESP_LOGx here if not defined globally
#ifndef LOG_PRINT
#define LOG_PRINT(level, tag, format, ...) do { \
    switch(level) { \
        case log_print::kERROR:   ESP_LOGE(tag, format, ##__VA_ARGS__); break; \
        case log_print::kWARN:    ESP_LOGW(tag, format, ##__VA_ARGS__); break; \
        case log_print::kINFO:    ESP_LOGI(tag, format, ##__VA_ARGS__); break; \
        case log_print::kDEBUG1:  ESP_LOGD(tag, format, ##__VA_ARGS__); break; \
        case log_print::kVERBOSE: ESP_LOGV(tag, format, ##__VA_ARGS__); break; \
        default:                  ESP_LOGI(tag, format, ##__VA_ARGS__); break; \
    } \
} while(0)
#endif // LOG_PRINT

#else
// Define basic logging macros and a dummy time function if not ESP_PLATFORM
#include <iostream>
#include <chrono>
#define LOG_PRINT(level, tag, format, ...) printf("[%s] %d: " format "\n", tag, static_cast<int>(level), ##__VA_ARGS__)
static const char* TAG = "CloudComm";
uint64_t esp_timer_get_time() { return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count(); }
#endif
// ------------------------------------------


namespace CloudComms {

// --- NO static constexpr definitions needed here ---

// --- Topic constants ---
const char* const kDefaultTopicPrefix = "dt";
const char* const kTimeSeriesTopicSuffix = "/timeseries";
const char* const kStatusTopicSuffix = "/status";
const char* const kEventTopicSuffix = "/event";

// --- Constructor / Destructor ---
CloudComm::CloudComm() : current_state_(State::UNINITIALIZED) {
    LOG_PRINT(log_print::kINFO, TAG, "CloudComm instance created.");
    memset(thing_name_, 0, sizeof(thing_name_));
    memset(json_parse_buffer_, 0, sizeof(json_parse_buffer_));
}

CloudComm::~CloudComm() {
    LOG_PRINT(log_print::kINFO, TAG, "CloudComm instance destroying...");
    State current = current_state_.load();
    if (current != State::UNINITIALIZED && current != State::DISCONNECTED) {
         Disconnect();
    }
    LOG_PRINT(log_print::kINFO, TAG, "CloudComm instance destroyed.");
}


// --- Initialization ---
bool CloudComm::Initialize(const CloudCommConfig& config) {
     LOG_PRINT(log_print::kINFO, TAG, "Initializing CloudComm...");

    if (current_state_.load() != State::UNINITIALIZED) {
        LOG_PRINT(log_print::kWARN, TAG, "Already initialized or initializing.");
        return (current_state_.load() != State::UNINITIALIZED);
    }

    // --- Validate ALL Required Parameters ---
    if (config.aws_endpoint.empty() || config.client_id.empty() || config.thing_name.empty() ||
        config.root_ca_path.empty() || config.device_cert_path.empty() || config.private_key_path.empty()) {
        LOG_PRINT(log_print::kERROR, TAG, "Initialize failed: Endpoint, Client ID, Thing Name, and all Certificate Paths are required.");
        return false;
    }
    if (config.thing_name.length() >= kMaxThingNameLen) { // Use kMax const directly
         LOG_PRINT(log_print::kERROR, TAG, "Initialize failed: Thing name '%s' too long (max %zu chars).",
                 config.thing_name.c_str(), kMaxThingNameLen - 1);
        return false;
    }

    // --- Store Thing Name ---
    strncpy(thing_name_, config.thing_name.c_str(), sizeof(thing_name_) - 1);
    thing_name_[sizeof(thing_name_) - 1] = '\0';

    // --- Prepare Underlying Client Config (Temporary on stack) ---
    AwsIot::MqttConfig client_config_internal = {};
    // **Create temporary std::string objects required by underlying client's config**
    client_config_internal.aws_endpoint = config.aws_endpoint; // Implicit conversion
    client_config_internal.client_id = config.client_id;       // Implicit conversion
    client_config_internal.thing_name = config.thing_name;     // Implicit conversion
    // ***********************************************************
    client_config_internal.port = kDefaultMqttPort;
    client_config_internal.rx_buffer_size = config.mqtt_rx_buffer_size > 0 ? config.mqtt_rx_buffer_size : kDefaultMqttRxBufferSize;
    client_config_internal.tx_buffer_size = config.mqtt_tx_buffer_size > 0 ? config.mqtt_tx_buffer_size : kDefaultMqttTxBufferSize;
    LOG_PRINT(log_print::kINFO, TAG, "MQTT Buffers: RX=%d, TX=%d", client_config_internal.rx_buffer_size, client_config_internal.tx_buffer_size);

    // --- Load Certificates using fully specified paths from config ---
    LOG_PRINT(log_print::kINFO, TAG, "Loading certificates from specified paths...");
    LOG_PRINT(log_print::kDEBUG1, TAG, "Loading CA from: %s", config.root_ca_path.c_str());
    if (!LoadCertificateFromFile(config.root_ca_path.c_str(), client_config_internal.root_ca_pem, AwsIot::kMaxCertLen)) { LOG_PRINT(log_print::kERROR, TAG,"Failed to load CA cert: %s", config.root_ca_path.c_str()); return false; }
    LOG_PRINT(log_print::kDEBUG1, TAG, "Loading device cert from: %s", config.device_cert_path.c_str());
    if (!LoadCertificateFromFile(config.device_cert_path.c_str(), client_config_internal.device_cert_pem, AwsIot::kMaxCertLen)) { LOG_PRINT(log_print::kERROR, TAG,"Failed to load device cert: %s", config.device_cert_path.c_str()); return false; }
    LOG_PRINT(log_print::kDEBUG1, TAG, "Loading private key from: %s", config.private_key_path.c_str());
    if (!LoadCertificateFromFile(config.private_key_path.c_str(), client_config_internal.private_key_pem, AwsIot::kMaxCertLen)) { LOG_PRINT(log_print::kERROR, TAG,"Failed to load private key: %s", config.private_key_path.c_str()); return false; }
    LOG_PRINT(log_print::kDEBUG1, TAG, "Certificates loaded successfully.");

    // --- Initialize Underlying Client ---
    if (!aws_mqtt_client_.Initialize(client_config_internal)) {
        LOG_PRINT(log_print::kERROR, TAG, "Failed to initialize underlying AwsIotMqttClient.");
        return false;
    }

    // --- Common Setup Steps (Callbacks & Subscriptions) ---
    if (!CommonInitializeSetup()) {
        aws_mqtt_client_.Disconnect(); // Attempt cleanup
        return false;
    }

    // --- Set Initial State ---
    current_state_.store(State::DISCONNECTED);
    last_disconnect_time_ms_ = 0;
    current_backoff_delay_ms_ = kInitialBackoffMs;
    reconnect_attempts_ = 0;
    LOG_PRINT(log_print::kINFO, TAG, "CloudComm initialized successfully for Thing: %s. State: DISCONNECTED.", thing_name_);
    return true;
}


/** @brief Common setup steps called by Initialize. */
bool CloudComm::CommonInitializeSetup() {
    aws_mqtt_client_.SetOnConnectedCallback([this]() { this->OnConnected(); });
    aws_mqtt_client_.SetOnDisconnectedCallback([this]() { this->OnDisconnected(); });

    LOG_PRINT(log_print::kDEBUG1, TAG, "Setting up shadow subscriptions.");
    // Define the lambda matching the expected signature directly
    auto shadow_handler = [this](const std::string& type, std::string_view payload) {
        this->HandleShadowCallback(type, payload); // Direct call, signatures match
    };
    if (!aws_mqtt_client_.SubscribeToShadowUpdates(shadow_handler)) {
        LOG_PRINT(log_print::kERROR, TAG, "Common setup failed: Shadow update subscription failed!");
        return false;
    }
    if (!aws_mqtt_client_.SubscribeToShadowGetResponses(shadow_handler)) {
        LOG_PRINT(log_print::kERROR, TAG, "Common setup failed: Shadow get response subscription failed!");
        return false;
    }
    return true;
}


/** @brief Initiates connection attempt. */
bool CloudComm::Connect(bool reset_retry_state) {
    State current = current_state_.load();
    LOG_PRINT(log_print::kINFO, TAG, "Connect requested by application (reset_retry=%s). Current state: %d",
             reset_retry_state ? "true" : "false", static_cast<int>(current));
    if (current == State::UNINITIALIZED) { LOG_PRINT(log_print::kERROR, TAG, "Cannot connect: Not initialized."); return false; }
    if (current == State::CONNECTING || current == State::CONNECTED) { LOG_PRINT(log_print::kWARN, TAG, "Connect called while already %s.", (current == State::CONNECTING) ? "connecting" : "connected"); return true; }
    if (reset_retry_state) {
        LOG_PRINT(log_print::kDEBUG1, TAG, "Resetting reconnect state due to explicit connect call.");
        reconnect_attempts_ = 0;
        current_backoff_delay_ms_ = kInitialBackoffMs;
        last_disconnect_time_ms_ = 0;
    }
    return AttemptReconnect();
}

/** @brief Internal function that actually calls the underlying client connect */
bool CloudComm::AttemptReconnect() {
    LOG_PRINT(log_print::kINFO, TAG, "Attempting MQTT connection (Attempt #%d)...", reconnect_attempts_ + 1);
    State expected_disconnected = State::DISCONNECTED;
    State expected_waiting = State::WAITING_TO_RETRY;
    if (!current_state_.compare_exchange_strong(expected_waiting, State::CONNECTING) &&
        !current_state_.compare_exchange_strong(expected_disconnected, State::CONNECTING))
    {
         State actual_state = current_state_.load();
         LOG_PRINT(log_print::kWARN, TAG, "AttemptReconnect failed: Could not transition from WAITING/DISCONNECTED state. Current state: %d", static_cast<int>(actual_state));
         return false;
    }
    if (!aws_mqtt_client_.Connect()) {
        LOG_PRINT(log_print::kWARN, TAG, "Underlying aws_mqtt_client_.Connect() call failed initiation.");
        HandleDisconnectInternal(); // Treat as immediate disconnect to trigger retry via Process()
        return false;
    }
    LOG_PRINT(log_print::kDEBUG1, TAG, "MQTT connection attempt initiated. State: CONNECTING.");
    reconnect_attempts_++;
    return true;
}

/** @brief Disconnects from the broker. */
void CloudComm::Disconnect() {
    LOG_PRINT(log_print::kINFO, TAG, "Disconnect requested by application.");
    State previous_state = current_state_.exchange(State::DISCONNECTED);
    if (previous_state != State::UNINITIALIZED && previous_state != State::DISCONNECTED) {
         LOG_PRINT(log_print::kDEBUG1, TAG,"Calling underlying MQTT disconnect.");
         aws_mqtt_client_.Disconnect();
    } else { LOG_PRINT(log_print::kDEBUG1, TAG,"Already disconnected or uninitialized."); }
    reconnect_attempts_ = 0;
    current_backoff_delay_ms_ = kInitialBackoffMs;
    last_disconnect_time_ms_ = 0;
}

/** @brief Checks connection status. */
bool CloudComm::IsConnected() const { return (current_state_.load() == State::CONNECTED); }

/** @brief Helper to get timestamp. */
uint64_t CloudComm::GetTimestampMs() { return esp_timer_get_time() / 1000; }

/** @brief Handles internal disconnect logic. */
void CloudComm::HandleDisconnectInternal() {
     State previous_state = current_state_.load();
    if (previous_state == State::CONNECTED || previous_state == State::CONNECTING) {
        LOG_PRINT(log_print::kWARN, TAG, "Internal: Handling disconnection event. Previous state: %d", (int)previous_state);
        last_disconnect_time_ms_ = GetTimestampMs();
        uint64_t next_delay = static_cast<uint64_t>(current_backoff_delay_ms_) * 2;
        current_backoff_delay_ms_ = static_cast<uint32_t>(std::min(next_delay, static_cast<uint64_t>(kMaxBackoffMs)));
        State expected_state = previous_state;
        if (current_state_.compare_exchange_strong(expected_state, State::WAITING_TO_RETRY)) {
            LOG_PRINT(log_print::kINFO, TAG, "State changed to WAITING_TO_RETRY. Next attempt (#%d) in %u ms.", reconnect_attempts_ +1, current_backoff_delay_ms_);
             if (connection_status_callback_) { connection_status_callback_(false); }
        } else { LOG_PRINT(log_print::kWARN, TAG, "Disconnect handling aborted: State changed unexpectedly from %d to %d.", (int)previous_state, (int)expected_state); }
    } else { LOG_PRINT(log_print::kDEBUG1, TAG, "Internal: Ignoring redundant disconnect event while in state %d.", (int)previous_state); }
}

/** @brief Processes internal state machine (call periodically). */
void CloudComm::Process() {
    State state = current_state_.load();
    if (state == State::WAITING_TO_RETRY) {
        uint64_t now_ms = GetTimestampMs();
        if (now_ms >= (last_disconnect_time_ms_ + current_backoff_delay_ms_)) {
            LOG_PRINT(log_print::kINFO, TAG, "Process: Retry timer elapsed. Attempting reconnect...");
            AttemptReconnect();
        }
    }
    // Add verbose logging if needed: LOG_PRINT(log_print::kVERBOSE, TAG, "Process: State=%d", (int)state);
}

// --- Data Sending Logic ---
bool CloudComm::SendTimeSeriesData(const rapidjson::Value& data, int qos) { if (!IsConnected()) { LOG_PRINT(log_print::kWARN, TAG, "Not connected"); return false; } char topic_buffer[AwsIot::kMaxTopicLen]; if (!BuildTopicString(topic_buffer, sizeof(topic_buffer), kTimeSeriesTopicSuffix)) return false; LOG_PRINT(log_print::kDEBUG1, TAG, "Sending time series data to topic: %s", topic_buffer); return PublishJsonToTopic(topic_buffer, data, qos); }
bool CloudComm::SendStatusReport(const rapidjson::Value& data, int qos) { if (!IsConnected()) { LOG_PRINT(log_print::kWARN, TAG, "Not connected"); return false; } if (!data.IsObject()) { LOG_PRINT(log_print::kERROR, TAG, "Status data must be object"); return false; } char topic_buffer[AwsIot::kMaxTopicLen]; if (!BuildTopicString(topic_buffer, sizeof(topic_buffer), kStatusTopicSuffix)) return false; LOG_PRINT(log_print::kDEBUG1, TAG, "Sending status report to topic: %s", topic_buffer); return PublishJsonToTopic(topic_buffer, data, qos); }
bool CloudComm::SendEvent(const char* event_type, const rapidjson::Value& data, int qos) { if (!IsConnected()) { LOG_PRINT(log_print::kWARN, TAG, "Not connected"); return false; } if (!event_type || event_type[0] == '\0' || !data.IsObject()) { LOG_PRINT(log_print::kERROR, TAG, "Invalid event args"); return false; } char topic_buffer[AwsIot::kMaxTopicLen]; if (!BuildTopicString(topic_buffer, sizeof(topic_buffer), kEventTopicSuffix)) return false; rapidjson::Document event_doc(rapidjson::kObjectType); auto& allocator = event_doc.GetAllocator(); event_doc.AddMember("event_type", rapidjson::StringRef(event_type), allocator); event_doc.AddMember("details", rapidjson::Value(data, allocator).Move(), allocator); LOG_PRINT(log_print::kDEBUG1, TAG, "Sending event '%s' to topic: %s", event_type, topic_buffer); return PublishJsonToTopic(topic_buffer, event_doc, qos); }
bool CloudComm::ReportCurrentState(const rapidjson::Value& reported_state, int qos) { if (!IsConnected()) { LOG_PRINT(log_print::kWARN, TAG,"Not connected"); return false; } if (!reported_state.IsObject()) { LOG_PRINT(log_print::kERROR, TAG,"Reported state must be object"); return false; } rapidjson::Document shadow_doc(rapidjson::kObjectType); auto& allocator = shadow_doc.GetAllocator(); rapidjson::Value state_val(rapidjson::kObjectType); state_val.AddMember("reported", rapidjson::Value(reported_state, allocator).Move(), allocator); shadow_doc.AddMember("state", state_val, allocator); rapidjson::StringBuffer string_buffer; rapidjson::Writer<rapidjson::StringBuffer> writer(string_buffer); shadow_doc.Accept(writer); const char* json_string = string_buffer.GetString(); size_t json_len = string_buffer.GetSize(); LOG_PRINT(log_print::kDEBUG1, TAG, "Reporting current state to shadow (%zu bytes): %s", json_len, json_string); return aws_mqtt_client_.UpdateShadow(std::string_view(json_string, json_len), qos); }

// --- Callback Setters ---
void CloudComm::SetControlCommandCallback(ControlCommandCallback callback) { control_command_callback_ = std::move(callback); LOG_PRINT(log_print::kINFO, TAG,"Control cb set"); }
void CloudComm::SetConnectionStatusCallback(ConnectionStatusCallback callback) { connection_status_callback_ = std::move(callback); LOG_PRINT(log_print::kINFO, TAG,"Connection cb set"); }

// --- Private Helper Methods ---
bool CloudComm::LoadCertificateFromFile(const char* full_path, char* buffer, std::size_t buffer_size) { if (!full_path || !buffer || buffer_size == 0) return false; memset(buffer, 0, buffer_size); std::ifstream file(full_path); if (!file.is_open()) { LOG_PRINT(log_print::kERROR, TAG, "Failed to open file: %s", full_path); return false; } file.read(buffer, buffer_size - 1); if (file.eof()) { buffer[file.gcount()] = '\0'; file.close(); return true; } else { if (file.fail()) { LOG_PRINT(log_print::kERROR, TAG, "File read failed: %s", full_path); } else { LOG_PRINT(log_print::kERROR, TAG, "Buffer too small for file: %s (Size: %zu)", full_path, buffer_size); } buffer[0] = '\0'; file.close(); return false; } }
bool CloudComm::BuildTopicString(char* buffer, std::size_t buffer_len, const char* type_suffix) { if (!buffer || buffer_len == 0 || !type_suffix || thing_name_[0] == '\0') return false; int written = snprintf(buffer, buffer_len, "%s/%s%s", kDefaultTopicPrefix, thing_name_, type_suffix); if (written < 0 || static_cast<std::size_t>(written) >= buffer_len) { LOG_PRINT(log_print::kERROR, TAG, "BuildTopicString failed/truncated (suffix: %s, len: %zu)", type_suffix, buffer_len); buffer[0] = '\0'; return false; } return true; }
bool CloudComm::PublishJsonToTopic(const char* topic, const rapidjson::Value& json_payload, int qos, bool retain) { rapidjson::StringBuffer string_buffer; rapidjson::Writer<rapidjson::StringBuffer> writer(string_buffer); json_payload.Accept(writer); const char* json_string = string_buffer.GetString(); size_t json_len = string_buffer.GetSize(); LOG_PRINT(log_print::kVERBOSE, TAG, "Publishing to %s (%zu bytes): %s", topic, json_len, json_string); return aws_mqtt_client_.Publish(topic, reinterpret_cast<const uint8_t*>(json_string), json_len, qos, retain); }
void CloudComm::RequestShadowState() { LOG_PRINT(log_print::kINFO, TAG, "Requesting current shadow state..."); if (!aws_mqtt_client_.GetShadow("")) { LOG_PRINT(log_print::kERROR, TAG, "Failed to send shadow get request."); } }
// AcknowledgeControlCommand removed
void CloudComm::ProcessReceivedShadowDelta(const rapidjson::Value& delta_state) { if (!control_command_callback_) { LOG_PRINT(log_print::kDEBUG1, TAG, "Shadow delta received, but no control command callback registered."); return; } if (!delta_state.IsObject()) { LOG_PRINT(log_print::kERROR, TAG, "ProcessReceivedShadowDelta called with non-object."); return; } LOG_PRINT(log_print::kINFO, TAG, "Processing desired state delta for commands..."); for (auto itr = delta_state.MemberBegin(); itr != delta_state.MemberEnd(); ++itr ) { const char* key_ptr = itr->name.GetString(); const std::size_t key_len = itr->name.GetStringLength(); const rapidjson::Value& params = itr->value; char current_key[kMaxCommandKeyLen]; if (key_len >= sizeof(current_key)) { LOG_PRINT(log_print::kERROR, TAG, "Command key '%.*s...' too long (max %zu). Skipping.", 20, key_ptr, sizeof(current_key) - 1); continue; } memcpy(current_key, key_ptr, key_len); current_key[key_len] = '\0'; LOG_PRINT(log_print::kINFO, TAG, "Invoking callback for command: '%s'", current_key); bool success = control_command_callback_(current_key, params); if (success) { LOG_PRINT(log_print::kINFO, TAG, "Command '%s' processed successfully by application. Application should call ReportCurrentState().", current_key); } else { LOG_PRINT(log_print::kWARN, TAG, "Command '%s' processing failed per app callback.", current_key); } } LOG_PRINT(log_print::kINFO, TAG, "Finished processing shadow delta commands iteration."); }
void CloudComm::ProcessReceivedShadowDocument(std::string_view /*payload*/) { rapidjson::Document doc; doc.ParseInsitu(json_parse_buffer_); if (doc.HasParseError()) { LOG_PRINT(log_print::kERROR, TAG,"Re-parse failed in ProcessReceivedShadowDocument"); return; } if (doc.HasMember("state") && doc["state"].IsObject()) { const auto& state_obj = doc["state"]; if (state_obj.HasMember("desired") && state_obj["desired"].IsObject()) { LOG_PRINT(log_print::kINFO, TAG, "Processing 'desired' state from received document."); ProcessReceivedShadowDelta(state_obj["desired"]); } else { LOG_PRINT(log_print::kDEBUG1, TAG, "Received document has no 'desired' state."); } } else { LOG_PRINT(log_print::kWARN, TAG, "Received document missing 'state' object."); } }
void CloudComm::HandleShadowCallback(const std::string& update_type, std::string_view payload) { LOG_PRINT(log_print::kDEBUG1, TAG, "HandleShadowCallback: Type: '%s', Size: %zu", update_type.c_str(), payload.length()); if (payload.length() >= sizeof(json_parse_buffer_)) { LOG_PRINT(log_print::kERROR, TAG,"Shadow payload too large"); return; } memcpy(json_parse_buffer_, payload.data(), payload.length()); json_parse_buffer_[payload.length()] = '\0'; rapidjson::Document doc; doc.ParseInsitu(json_parse_buffer_); if (doc.HasParseError()) { LOG_PRINT(log_print::kERROR, TAG,"Shadow JSON parse error (type %s)", update_type.c_str()); return; } if (update_type == "delta") { if (doc.HasMember("state") && doc["state"].IsObject()) { ProcessReceivedShadowDelta(doc["state"]); } else { LOG_PRINT(log_print::kWARN, TAG, "Delta missing 'state' object."); } } else if (update_type == "accepted") { LOG_PRINT(log_print::kINFO, TAG, "Processing shadow accepted document."); ProcessReceivedShadowDocument(payload); } else if (update_type == "rejected") { LOG_PRINT(log_print::kWARN, TAG, "Received shadow operation rejection."); if (doc.HasMember("message") && doc["message"].IsString()) { LOG_PRINT(log_print::kWARN, TAG, " Rejection message: %s", doc["message"].GetString()); } } else { LOG_PRINT(log_print::kWARN, TAG, "Unhandled shadow callback type: %s", update_type.c_str()); } }

// --- Internal Callbacks (Update State) ---
void CloudComm::OnConnected() { LOG_PRINT(log_print::kINFO, TAG, "Internal: OnConnected event received."); reconnect_attempts_ = 0; current_backoff_delay_ms_ = kInitialBackoffMs; last_disconnect_time_ms_ = 0; current_state_.store(State::CONNECTED); if (connection_status_callback_) { connection_status_callback_(true); } RequestShadowState(); }
void CloudComm::OnDisconnected() { HandleDisconnectInternal(); }


} // namespace CloudComms

---------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include <string>
#include <chrono>

// Platform specific (ESP-IDF example)
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp_spiffs.h"
#include "esp_system.h"

// CloudComm Module Header
#include "cloud_comm.h" // Your CloudComm header

// RapidJSON Headers (Needed by Application)
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h" // Useful for creating reported state

// --- Application TAG ---
static const char* APP_TAG = "ShadowExampleApp";

// --- EXAMPLE LOG_PRINT Implementation ---
// Define this properly according to your logging framework
namespace log_print { enum LogLevel { kERROR, kWARN, kINFO, kDEBUG1, kVERBOSE }; }
#ifndef LOG_PRINT
#define LOG_PRINT(level, tag, format, ...) do { /* Your logging implementation */ \
    switch(level) { \
        case log_print::kERROR:   ESP_LOGE(tag, format, ##__VA_ARGS__); break; \
        case log_print::kWARN:    ESP_LOGW(tag, format, ##__VA_ARGS__); break; \
        case log_print::kINFO:    ESP_LOGI(tag, format, ##__VA_ARGS__); break; \
        case log_print::kDEBUG1:  ESP_LOGD(tag, format, ##__VA_ARGS__); break; \
        case log_print::kVERBOSE: ESP_LOGV(tag, format, ##__VA_ARGS__); break; \
        default:                  ESP_LOGI(tag, format, ##__VA_ARGS__); break; \
    } \
} while(0)
#endif // LOG_PRINT
// --- End EXAMPLE LOG_PRINT ---


// --- Global CloudComm instance ---
CloudComms::CloudComm cloud_comm;

// --- Placeholder for actual device state/actions ---
static bool g_current_led_state = false;
static int g_current_report_interval = 60;

// Function to set hardware AND update internal state variable
void SetDeviceLedState(bool on) {
    g_current_led_state = on;
    LOG_PRINT(log_print::kINFO, APP_TAG, "Hardware: Setting LED to %s", on ? "ON" : "OFF");
    // TODO: Add actual hardware control code
}

// Function to get current state
bool GetDeviceLedState() {
    // TODO: Read actual hardware state if possible, otherwise return variable
    return g_current_led_state;
}

// Function to set config AND update internal state variable
void SetDeviceReportInterval(int interval_sec) {
     if (interval_sec >= 5 && interval_sec <= 3600) { // Example validation
        g_current_report_interval = interval_sec;
        LOG_PRINT(log_print::kINFO, APP_TAG, "Config: Setting report interval to %d sec", interval_sec);
        // TODO: Store persistently if needed
     } else {
         LOG_PRINT(log_print::kWARN, APP_TAG, "Config: Invalid report interval %d rejected.", interval_sec);
         // Optional: Throw an error or return false if SetDeviceReportInterval could fail
     }
}

int GetDeviceReportInterval() {
    return g_current_report_interval;
}

void TriggerReboot() {
    LOG_PRINT(log_print::kWARN, APP_TAG, "Hardware: Rebooting system in 5 seconds...");
    vTaskDelay(pdMS_TO_TICKS(5000));
    esp_restart();
}

// --- Application Callback Implementations ---

void HandleConnectionStatus(bool connected) {
    LOG_PRINT(log_print::kINFO, APP_TAG, "Application Notified: Connection Status = %s", connected ? "CONNECTED" : "DISCONNECTED");
    // Informational only for the app. CloudComm::Process handles retries.
}

/**
 * @brief Handles control commands received from the cloud via Shadow delta or initial Get.
 * @return True if command processing was successful, False otherwise.
 */
bool HandleControlCommand(const char* command_name, const rapidjson::Value& params) {
    LOG_PRINT(log_print::kINFO, APP_TAG, "Application Handling Command: '%s'", command_name);
    bool success = false;

    // Prepare a document *ONLY* for reporting the state *back* if successful
    rapidjson::Document reported_state_update(rapidjson::kObjectType);
    auto& allocator = reported_state_update.GetAllocator();

    // --- Process Specific Commands ---
    if (strcmp(command_name, "reboot") == 0) {
        LOG_PRINT(log_print::kWARN, APP_TAG, "Reboot command executing...");
        // No state to report back before rebooting
        TriggerReboot();
        success = true; // Technically won't return, but mark as success if scheduled

    } else if (strcmp(command_name, "set_led") == 0) {
        if (!params.IsObject() || !params.HasMember("state") || !params["state"].IsBool()) {
            LOG_PRINT(log_print::kERROR, APP_TAG, "Invalid params for set_led.");
            success = false;
        } else {
            bool desired_state = params["state"].GetBool();
            SetDeviceLedState(desired_state); // Perform the action
            success = true; // Assume hardware control worked

            // *** Prepare the reported state update ***
            if (success) {
                 // Use a key representing the actual device state
                 reported_state_update.AddMember("led_is_on", GetDeviceLedState(), allocator);
            }
        }
    } else if (strcmp(command_name, "update_config") == 0) {
         if (!params.IsObject()) {
             LOG_PRINT(log_print::kERROR, APP_TAG, "Invalid params for update_config.");
             success = false;
         } else {
             LOG_PRINT(log_print::kINFO, APP_TAG, "Processing configuration update...");
             bool config_changed = false;
             // Example: Extract reporting interval
             if (params.HasMember("report_interval_sec") && params["report_interval_sec"].IsInt()) {
                 int requested_interval = params["report_interval_sec"].GetInt();
                 int current_interval = GetDeviceReportInterval();
                 // Only apply and report if the value is valid and different
                 if (requested_interval >= 5 && requested_interval <= 3600 && requested_interval != current_interval) {
                     SetDeviceReportInterval(requested_interval);
                     // *** Prepare the reported state update ***
                     reported_state_update.AddMember("report_interval_sec", GetDeviceReportInterval(), allocator);
                     config_changed = true;
                 } else if (requested_interval == current_interval) {
                      LOG_PRINT(log_print::kINFO, APP_TAG,"Requested interval matches current value.");
                      // No actual change, but command is "handled"
                      config_changed = false; // Set flag explicitly
                 } else {
                      LOG_PRINT(log_print::kWARN, APP_TAG,"Requested interval %d invalid/rejected.", requested_interval);
                      // Config not changed for this parameter
                 }
             }
             // TODO: Process other config parameters...

             // Determine overall success (e.g., true if no errors encountered, even if no change made)
             success = true;

             // *** Handle reporting for config update ***
             if (success && !config_changed && !params.ObjectEmpty()) {
                 // If command was valid but caused no state change (e.g., value already set),
                 // report the command key itself back as null to clear the desired state.
                  reported_state_update.AddMember(rapidjson::StringRef(command_name), // Copy key name
                                                 rapidjson::Value(), // JSON null
                                                 allocator);
             }
             // If config_changed is true, the specific changed values are already in reported_state_update
         }
    } else {
        LOG_PRINT(log_print::kWARN, APP_TAG, "Unknown command received: %s", command_name);
        success = false; // Indicate failure: Unknown command
    }


    // --- IMPORTANT: Call ReportCurrentState IF successful AND there is state to report ---
    // This updates the 'reported' section and implicitly clears the 'desired' key
    if (success && reported_state_update.MemberCount() > 0) { // Check if we actually added members
        LOG_PRINT(log_print::kINFO, APP_TAG, "Reporting state back to shadow after processing '%s'.", command_name);
        if (!cloud_comm.ReportCurrentState(reported_state_update)) {
            LOG_PRINT(log_print::kWARN, APP_TAG, "Failed to queue state report for command '%s'. Shadow 'desired' state may persist.", command_name);
        }
    } else if (success) {
         LOG_PRINT(log_print::kINFO, APP_TAG, "Command '%s' processed successfully, but no specific state to report back.", command_name);
         // This might happen for commands like 'reboot' or simple actions.
         // The desired state might persist if not explicitly cleared by reporting null for the key,
         // but often this is acceptable for action-only commands. Alternatively, report null:
         // rapidjson::Document null_ack(rapidjson::kObjectType);
         // null_ack.AddMember(rapidjson::StringRef(command_name), rapidjson::Value(), null_ack.GetAllocator());
         // cloud_comm.ReportCurrentState(null_ack);
    }
    // If success is false, we do nothing, letting the desired state persist.
    // -----------------------------------------------------------------------------

    return success; // Return overall status for CloudComm internal logging
}

// --- Filesystem Initialization (Example) ---
bool init_filesystem() { /* ... Assume implementation works ... */ LOG_PRINT(log_print::kINFO, APP_TAG,"FS Init done."); return true; }


// --- Main Application Task ---
extern "C" void app_main(void)
{
    LOG_PRINT(log_print::kINFO, APP_TAG, "Starting Application...");
    if (!init_filesystem()) { /* ... handle error ... */ return; }

    // --- Prepare CloudComm Configuration ---
    CloudComms::CloudCommConfig config = {};
    // !! IMPORTANT: Populate with YOUR details and FULL paths !!
    const char* endpoint = "your_endpoint.amazonaws.com"; // CHANGE
    const char* client_id = "your_client_id";              // CHANGE
    const char* thing_name = "your_thing_name";            // CHANGE
    const char* ca_path = "/spiffs/ca.pem";              // CHANGE
    const char* cert_path = "/spiffs/cert.pem";            // CHANGE
    const char* key_path = "/spiffs/key.pem";            // CHANGE
    strncpy(config.aws_endpoint, endpoint, sizeof(config.aws_endpoint) - 1);
    strncpy(config.client_id, client_id, sizeof(config.client_id) - 1);
    strncpy(config.thing_name, thing_name, sizeof(config.thing_name) - 1);
    strncpy(config.root_ca_path, ca_path, sizeof(config.root_ca_path) - 1);
    strncpy(config.device_cert_path, cert_path, sizeof(config.device_cert_path) - 1);
    strncpy(config.private_key_path, key_path, sizeof(config.private_key_path) - 1);
    // Ensure null termination (safer if source strings might not be)
    config.aws_endpoint[sizeof(config.aws_endpoint)-1] = '\0';
    // ... null terminate others ...

    // --- Initialize CloudComm ---
    if (!cloud_comm.Initialize(config)) { /* ... handle error ... */ return; }

    // --- Register Callbacks ---
    cloud_comm.SetConnectionStatusCallback(HandleConnectionStatus);
    cloud_comm.SetControlCommandCallback(HandleControlCommand);

    // --- Initiate Connection ---
    LOG_PRINT(log_print::kINFO, APP_TAG, "Initiating connection...");
    cloud_comm.Connect(true); // Start connection attempts

    // --- Main Application Loop ---
    uint64_t loop_counter = 0;
    uint32_t last_proactive_report_time = 0;
    uint32_t proactive_report_interval_ms = 30000; // Report state every 30s

    while (true) {
        // --- CRITICAL: Call Process() periodically ---
        cloud_comm.Process(); // Handles connection state & reconnect timing

        uint64_t now_ms = cloud_comm.GetTimestampMs();

        // --- Application Logic ---
        if (cloud_comm.IsConnected()) {

            // --- Proactive State Reporting (Example) ---
            // Report state even if no command was received
            if ((now_ms - last_proactive_report_time) >= proactive_report_interval_ms) {
                 last_proactive_report_time = now_ms;
                 LOG_PRINT(log_print::kINFO, APP_TAG, "Proactively reporting current state...");
                 rapidjson::Document current_state_doc(rapidjson::kObjectType);
                 auto& allocator = current_state_doc.GetAllocator();
                 // Include important current state values
                 current_state_doc.AddMember("led_is_on", GetDeviceLedState(), allocator);
                 current_state_doc.AddMember("uptime_seconds", (uint32_t)(loop_counter), allocator);
                 current_state_doc.AddMember("report_interval_sec", GetDeviceReportInterval(), allocator);
                 // current_state_doc.AddMember("rssi", GetRssi(), allocator); // Add other state...

                 if (!cloud_comm.ReportCurrentState(current_state_doc)) {
                      LOG_PRINT(log_print::kWARN, APP_TAG, "Failed to queue proactive state report.");
                 }
            }

            // Send other telemetry data...
            // if ((loop_counter % 10) == 0) { /* ... SendTimeSeriesData ... */ }


        } else {
            LOG_PRINT(log_print::kDEBUG1, APP_TAG, "Waiting for connection...");
        }

        // Other application tasks...

        // --- Delay ---
        vTaskDelay(pdMS_TO_TICKS(1000)); // Call Process() approx every second
        loop_counter++;
    }
}

---------------------------------------------------------------------------------------------------
/**
 * @brief Manually initiates a connection attempt OR resets the retry cycle.
 * Typically only needed if automatic connection via Process() needs to be preempted
 * or if forcing a reconnect after manual Disconnect().
 */
bool CloudComm::Connect(bool reset_retry_state) {
    State current = current_state_.load();
    LOG_PRINT(log_print::kINFO, TAG, "Manual Connect requested (reset_retry=%s). Current state: %d",
             reset_retry_state ? "true" : "false", static_cast<int>(current));

    if (current == State::UNINITIALIZED) { LOG_PRINT(log_print::kERROR, TAG, "Cannot connect: Not initialized."); return false; }
    if (current == State::CONNECTING || current == State::CONNECTED || current == State::CONNECTED_GETTING_SHADOW) {
        LOG_PRINT(log_print::kWARN, TAG, "Manual Connect called while already connecting, getting shadow, or connected. Resetting retry state only.");
        if(reset_retry_state) {
             reconnect_attempts_ = 0;
             current_backoff_delay_ms_ = kInitialBackoffMs;
             last_disconnect_time_ms_ = 0; // Allow immediate retry by Process if currently WAITING
        }
        return true; // Indicate it's already active or state was reset
    }

    // If DISCONNECTED or WAITING_TO_RETRY, reset state if requested and attempt connect immediately
    if (reset_retry_state) {
        LOG_PRINT(log_print::kDEBUG1, TAG, "Resetting reconnect state due to manual connect call.");
        reconnect_attempts_ = 0;
        current_backoff_delay_ms_ = kInitialBackoffMs;
        last_disconnect_time_ms_ = 0;
    }
    // Attempt connection immediately, regardless of backoff timer when called manually
    return AttemptReconnect();
}

/** @brief Internal function that actually calls the underlying client connect */
bool CloudComm::AttemptReconnect() { /* ... Same logic, sets state to CONNECTING ... */ }
/** @brief Disconnects from the broker. */
void CloudComm::Disconnect() { /* ... Same: Sets state=DISCONNECTED, resets retry state, calls client disconnect ... */ }
/** @brief Checks connection status. */
bool CloudComm::IsConnected() const { /* ... Same ... */ }
/** @brief Helper to get timestamp. */
uint64_t CloudComm::GetTimestampMs() { /* ... Same ... */ }
/** @brief Handles internal disconnect logic. */
void CloudComm::HandleDisconnectInternal() { /* ... Same logic, sets state=WAITING_TO_RETRY, calculates backoff ... */ }

// --- Process Function ---
void CloudComm::Process() {
    State state = current_state_.load();
    uint64_t now_ms = GetTimestampMs(); // Get time once

    switch (state) {
        case State::DISCONNECTED: {
            // --- NEW: Auto-initiate connection from DISCONNECTED state ---
            // This assumes Process() is only called when prerequisites (like Wi-Fi) are met.
            LOG_PRINT(log_print::kINFO, TAG, "Process: State is DISCONNECTED, attempting initial connect...");
            AttemptReconnect(); // This changes state to CONNECTING if successful
            // Note: If AttemptReconnect fails immediately, state becomes WAITING_TO_RETRY,
            // which will be handled on the *next* Process() call's timing check.
            break;
            // --- End New Logic ---
            }
        case State::WAITING_TO_RETRY: {
            if (now_ms >= (last_disconnect_time_ms_ + current_backoff_delay_ms_)) {
                LOG_PRINT(log_print::kINFO, TAG, "Process: Reconnect timer elapsed. Attempting reconnect...");
                AttemptReconnect(); // Changes state to CONNECTING if successful
            }
            break;
        }
        case State::CONNECTED_GETTING_SHADOW: {
            if (initial_shadow_received_) {
                LOG_PRINT(log_print::kINFO, TAG, "Process: Initial shadow received. Transitioning to CONNECTED.");
                current_state_.store(State::CONNECTED);
                break;
            }
            if (get_shadow_attempts_ >= kMaxGetShadowAttempts) {
                LOG_PRINT(log_print::kERROR, TAG, "Process: Max GetShadow attempts reached. Giving up. Transitioning to CONNECTED.");
                current_state_.store(State::CONNECTED);
                break;
            }
            if (now_ms >= (last_get_shadow_attempt_ms_ + current_get_shadow_backoff_ms_)) {
                LOG_PRINT(log_print::kINFO, TAG, "Process: Attempting GetShadow (Attempt #%d)...", get_shadow_attempts_ + 1);
                RequestShadowState();
                last_get_shadow_attempt_ms_ = now_ms;
                get_shadow_attempts_++;
                current_get_shadow_backoff_ms_ = std::min(current_get_shadow_backoff_ms_ + kGetShadowRetryBaseMs, kMaxGetShadowRetryMs);
                LOG_PRINT(log_print::kDEBUG1, TAG, "Next GetShadow attempt in %u ms.", current_get_shadow_backoff_ms_);
            }
            break;
        }
        case State::CONNECTING:
             LOG_PRINT(log_print::kVERBOSE, TAG, "Process: In CONNECTING state...");
             // Optional: Add a timeout here?
             break;
        case State::CONNECTED:
             LOG_PRINT(log_print::kVERBOSE, TAG, "Process: In CONNECTED state.");
             break;
        case State::UNINITIALIZED:
             // Do nothing
             break;
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------

#include "cloud_comm.h" // To call cloud_comm.ReportCurrentState
#include <cstring>      // For strcmp
#include <vector>       // Example: Store schedule items

// --- Include your logging header/macro ---
// Assuming LOG_PRINT and log_print::LogLevel defined
#ifndef LOG_PRINT
#define LOG_PRINT(level, tag, format, ...) printf(/* Your log impl */)
#endif
static const char* APP_TAG = "MyAppCallbacks";
// ----------------------------------------

// --- Include RapidJSON headers needed by the callback ---
#include "rapidjson/document.h"
#include "rapidjson/writer.h"       // Potentially useful for logging params
#include "rapidjson/stringbuffer.h" // Potentially useful for logging params
// ------------------------------------------------------

// --- Access to CloudComm instance (assuming global or accessible) ---
extern CloudComms::CloudComm cloud_comm;
// -------------------------------------------------------------------

// --- Placeholder application state variables and functions ---
// Replace these with your actual application logic and state variables
static bool g_light_on_24x7 = true; // Example state
static std::string g_op_mode = "CONTINUOUS"; // Example state
static int g_local_op_mode = 1; // Example state

struct ScheduleEntry {
    int start_time;
    int end_time;
    std::string mode;
    std::string rc; // Assuming rc is a string, adjust if it's truly hex later
};
static std::vector<ScheduleEntry> g_schedule; // Example storage

void SetLightOn24x7(bool on) { g_light_on_24x7 = on; LOG_PRINT(log_print::kINFO, APP_TAG, "App State: LightOn24x7 set to %d", (int)on); }
bool GetLightOn24x7() { return g_light_on_24x7; }

void SetOperatingMode(const char* mode) { g_op_mode = mode; LOG_PRINT(log_print::kINFO, APP_TAG, "App State: OpMode set to %s", mode); }
const char* GetOperatingModeString() { return g_op_mode.c_str(); } // Return C-string

void SetLocalOperationMode(int mode) { g_local_op_mode = mode; LOG_PRINT(log_print::kINFO, APP_TAG, "App State: LocalOpMode set to %d", mode); }
int GetLocalOperationMode() { return g_local_op_mode; }

// Example function to process and store the received schedule
bool UpdateDeviceSchedule(const rapidjson::Value& schedule_array) {
    LOG_PRINT(log_print::kINFO, APP_TAG, "Updating device schedule...");
    std::vector<ScheduleEntry> new_schedule; // Build new schedule
    bool parse_ok = true;

    if (!schedule_array.IsArray()) {
        LOG_PRINT(log_print::kERROR, APP_TAG, "Schedule update failed: Input is not an array.");
        return false;
    }

    for (const auto& item : schedule_array.GetArray()) {
        if (!item.IsObject()) { LOG_PRINT(log_print::kWARN, APP_TAG, "Schedule item not an object, skipping."); parse_ok = false; continue; }

        // Validate and extract members
        if (!item.HasMember("st") || !item["st"].IsInt() ||
            !item.HasMember("et") || !item["et"].IsInt() ||
            !item.HasMember("m") || !item["m"].IsString() ||
            !item.HasMember("rc") || !item["rc"].IsString()) // Assuming rc is string for now
        {
            LOG_PRINT(log_print::kWARN, APP_TAG, "Invalid schedule item format, skipping.");
            parse_ok = false;
            continue;
        }

        ScheduleEntry entry;
        entry.start_time = item["st"].GetInt();
        entry.end_time = item["et"].GetInt();
        entry.mode = item["m"].GetString();
        entry.rc = item["rc"].GetString(); // Store rc as string

        // Add more validation (e.g., start < end, time ranges valid)
        // ...

        new_schedule.push_back(entry);
         LOG_PRINT(log_print::kDEBUG1, APP_TAG, "Parsed schedule item: st=%d, et=%d, m=%s, rc=%s",
                  entry.start_time, entry.end_time, entry.mode.c_str(), entry.rc.c_str());
    }

    // Atomically update the application's schedule
    // (Could use mutexes here in a real multi-threaded app)
    g_schedule = std::move(new_schedule);
    LOG_PRINT(log_print::kINFO, APP_TAG, "Device schedule updated with %d entries.", g_schedule.size());

    return parse_ok; // Return true if parsing finished, even if some items skipped (adjust as needed)
}
// -----------------------------------------------------------


/**
 * @brief Handles control commands received from the cloud via Shadow delta or initial Get.
 * @return True if command processing was successful, False otherwise.
 */
bool HandleControlCommand(const char* command_name, const rapidjson::Value& params) {
    LOG_PRINT(log_print::kINFO, APP_TAG, "HandleControlCommand: Received command '%s'", command_name);
    bool success = false; // Assume failure initially

    // Prepare a document *ONLY* for reporting the state *back* if successful
    // It's crucial this is created fresh for each command processed in the loop
    // within ProcessReceivedShadowDelta.
    rapidjson::Document reported_state_update(rapidjson::kObjectType);
    auto& allocator = reported_state_update.GetAllocator();

    // --- Process Specific Commands ---
    if (strcmp(command_name, "lon24x7") == 0) {
        if (!params.IsNumber()) { // Could be bool 0/1 or int 0/1
            LOG_PRINT(log_print::kERROR, APP_TAG, "Invalid param type for 'lon24x7', expected number (0 or 1).");
        } else {
            bool desired_state = params.IsBool() ? params.GetBool() : (params.GetInt() != 0);
            SetLightOn24x7(desired_state);
            success = true;
            // Prepare reported state update
            reported_state_update.AddMember("lon24x7", GetLightOn24x7(), allocator);
        }
    } else if (strcmp(command_name, "opmode") == 0) {
        if (!params.IsString()) {
            LOG_PRINT(log_print::kERROR, APP_TAG, "Invalid param type for 'opmode', expected string.");
        } else {
            const char* desired_mode = params.GetString();
            // Add validation if needed (e.g., check against list of valid modes)
            SetOperatingMode(desired_mode);
            success = true;
             // Prepare reported state update
            reported_state_update.AddMember("opmode", rapidjson::StringRef(GetOperatingModeString()), allocator); // Use StringRef
        }
    } else if (strcmp(command_name, "locpmode") == 0) {
        if (!params.IsInt()) {
            LOG_PRINT(log_print::kERROR, APP_TAG, "Invalid param type for 'locpmode', expected integer.");
        } else {
            int desired_mode = params.GetInt();
            // Add validation if needed
            SetLocalOperationMode(desired_mode);
            success = true;
            // Prepare reported state update
            reported_state_update.AddMember("locpmode", GetLocalOperationMode(), allocator);
        }
    } else if (strcmp(command_name, "schedule") == 0) {
        if (!params.IsArray()) {
            LOG_PRINT(log_print::kERROR, APP_TAG, "Invalid param type for 'schedule', expected array.");
        } else {
            // Pass the whole array to the application logic function
            if (UpdateDeviceSchedule(params)) {
                 success = true;
                 // Prepare reported state update - report the schedule back to confirm
                 // This performs a deep copy of the received array 'params'
                 reported_state_update.AddMember("schedule", rapidjson::Value(params, allocator).Move(), allocator);
            } else {
                 // UpdateDeviceSchedule might return false on partial or full failure
                 LOG_PRINT(log_print::kERROR, APP_TAG, "Failed to fully process 'schedule' update.");
                 success = false; // Mark as failure if processing wasn't fully successful
            }
        }
    }
    // --- Add other command handlers here ---
    // else if (strcmp(command_name, "some_other_command") == 0) { ... }
    else {
        LOG_PRINT(log_print::kWARN, APP_TAG, "Unknown command key in delta: '%s'", command_name);
        success = false; // Treat unknown command as failure? Or success (acknowledged but ignored)? Let's say failure.
    }

    // --- IMPORTANT: Call ReportCurrentState IF successful AND state needs reporting ---
    // This updates the 'reported' section and implicitly clears the 'desired' key
    if (success && reported_state_update.MemberCount() > 0) {
        LOG_PRINT(log_print::kINFO, APP_TAG, "Reporting state back to shadow after processing '%s'.", command_name);
        if (!cloud_comm.ReportCurrentState(reported_state_update)) {
            // Log failure to queue report. The desired state might persist on the broker.
            LOG_PRINT(log_print::kWARN, APP_TAG, "Failed to queue state report for command '%s'.", command_name);
        }
    } else if (success) {
         // Command succeeded but resulted in no specific state to report back
         // (e.g., maybe 'reboot' before it actually rebooted, or a simple ack needed)
         // Optionally report null for the command key to ensure desired state clears
         LOG_PRINT(log_print::kINFO, APP_TAG, "Command '%s' processed successfully, reporting null acknowledgment.", command_name);
         rapidjson::Document null_ack_doc(rapidjson::kObjectType);
         null_ack_doc.AddMember(rapidjson::StringRef(command_name), // Key is the command name
                                rapidjson::Value(), // Value is JSON null
                                null_ack_doc.GetAllocator());
         if (!cloud_comm.ReportCurrentState(null_ack_doc)) {
              LOG_PRINT(log_print::kWARN, APP_TAG, "Failed to queue null ack state report for command '%s'.", command_name);
         }
    }
    // If success was false, we report nothing, leaving the desired state intact.

    return success; // Return overall processing status for this command
}


// --- Main Application Task ---
extern "C" void app_main(void)
{
    LOG_PRINT(log_print::kINFO, APP_TAG, "Starting Application...");
    // init_filesystem();

    // --- Prepare CloudComm Configuration ---
    CloudComms::CloudCommConfig config = {};
    // !! Populate config with YOUR endpoint, ID, thing name, and FULL cert paths !!
    // Example: strncpy(config.aws_endpoint, "...", sizeof(config.aws_endpoint)-1); etc.
    const char* endpoint = "your_endpoint.amazonaws.com"; /* CHANGE */ strncpy(config.aws_endpoint, endpoint, sizeof(config.aws_endpoint) - 1); config.aws_endpoint[sizeof(config.aws_endpoint)-1] = '\0';
    const char* client_id = "your_client_id"; /* CHANGE */ strncpy(config.client_id, client_id, sizeof(config.client_id) - 1); config.client_id[sizeof(config.client_id)-1] = '\0';
    const char* thing_name = "your_thing_name"; /* CHANGE */ strncpy(config.thing_name, thing_name, sizeof(config.thing_name) - 1); config.thing_name[sizeof(config.thing_name)-1] = '\0';
    const char* ca_path = "/spiffs/ca.pem"; /* CHANGE */ strncpy(config.root_ca_path, ca_path, sizeof(config.root_ca_path) - 1); config.root_ca_path[sizeof(config.root_ca_path)-1] = '\0';
    const char* cert_path = "/spiffs/cert.pem"; /* CHANGE */ strncpy(config.device_cert_path, cert_path, sizeof(config.device_cert_path) - 1); config.device_cert_path[sizeof(config.device_cert_path)-1] = '\0';
    const char* key_path = "/spiffs/key.pem"; /* CHANGE */ strncpy(config.private_key_path, key_path, sizeof(config.private_key_path) - 1); config.private_key_path[sizeof(config.private_key_path)-1] = '\0';


    // --- Initialize CloudComm ---
    if (!cloud_comm.Initialize(config)) { /* ... handle error ... */ return; }

    // --- Register Callbacks ---
    cloud_comm.SetConnectionStatusCallback(HandleConnectionStatus);
    cloud_comm.SetControlCommandCallback(HandleControlCommand);

    // --- Initiate Connection ---
    LOG_PRINT(log_print::kINFO, APP_TAG, "Initiating connection...");
    // Process() will handle actual connection attempts when Wi-Fi is ready
    // but we might still call Connect() once to ensure state machine starts if desired
    // Or just rely on Process() finding DISCONNECTED state when Wi-Fi is up.
    // Let's rely on Process() as discussed. Commenting out Connect() call here.
    // cloud_comm.Connect(true);


    // --- Main Application Loop ---
    uint64_t loop_counter = 0;
    while (true) {
        // --- Check prerequisites ---
        bool wifi_ready = true; // Replace with your actual Wi-Fi check
        // bool time_synced = is_time_synced(); // Check time sync if needed

        if (wifi_ready /* && time_synced */) {
            // --- Call Process() ONLY when Wi-Fi is usable ---
            cloud_comm.Process(); // Handles connection state & reconnect timing

            // --- Perform actions only when fully connected ---
            if (cloud_comm.IsConnected()) {
                // Send data, etc.
                // if ((loop_counter % 10) == 0) { /* ... SendTimeSeriesData ... */ }

                // Example: Proactively report state occasionally
                 if ((loop_counter % 120) == 0 && loop_counter > 0) { // Every 2 minutes
                     LOG_PRINT(log_print::kINFO, APP_TAG, "Proactively reporting current state...");
                     rapidjson::Document current_state_doc(rapidjson::kObjectType);
                     auto& allocator = current_state_doc.GetAllocator();
                     current_state_doc.AddMember("led_is_on", GetDeviceLedState(), allocator);
                     current_state_doc.AddMember("uptime_seconds", (uint32_t)(loop_counter), allocator);
                     current_state_doc.AddMember("opmode", rapidjson::StringRef(GetOperatingModeString()), allocator);
                     if(!cloud_comm.ReportCurrentState(current_state_doc)) {
                         LOG_PRINT(log_print::kWARN, APP_TAG, "Failed to queue proactive state report.");
                     }
                 }

            } else {
                LOG_PRINT(log_print::kDEBUG1, APP_TAG, "Wi-Fi connected, but waiting for MQTT (State: %d)...", static_cast<int>(cloud_comm.current_state_.load()));
            }
        } else {
            LOG_PRINT(log_print::kWARN, APP_TAG, "Wi-Fi is disconnected. CloudComm::Process() paused.");
            // Ensure Wi-Fi manager is trying to reconnect Wi-Fi...
        }

        // Other application logic...

        vTaskDelay(pdMS_TO_TICKS(1000)); // Loop delay
        loop_counter++;
    }
}

