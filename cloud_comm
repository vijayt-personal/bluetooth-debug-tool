#ifndef CLOUD_COMM_H_
#define CLOUD_COMM_H_

#include <atomic>       // Required for std::atomic
#include <cstddef>      // For size_t
#include <cstdint>      // For uint types
#include <functional>   // For std::function
#include <string>       // Required for std::string
#include <string_view>  // For std::string_view

// --- Assumed Platform Includes ---
// NOTE: Adjust these based on your actual platform/framework
#include "platform/mutex.h"             // For platform::mutex::Mutex/LockGuard
#include "platform/storage/file_system.h" // Original include
#include "platform/network/aws_iot_mqtt_client.h" // Original include
// --- End Assumed Platform Includes ---

// --- Assumed Project Includes ---
#include "backlog_packets.h" // Assuming this holds the DataBuffer definition
#include "rapidjson/document.h" // For rapidjson types in callbacks/params
// --- End Assumed Project Includes ---


namespace visium {

// --- Type Definitions ---

/**
 * @brief Callback function type for control commands received via shadow delta.
 * @param command_key The key (command name) from the shadow delta state object.
 * @param params A RapidJSON Value (likely an object or primitive) containing parameters for the command.
 * @return True if the command was processed successfully by the application, false otherwise.
 * Returning true implies the application has actioned the command and the corresponding
 * 'reported' state should ideally be updated.
 */
using ControlCommandCallback = std::function<bool(const char* command_key, const rapidjson::Value& params)>;

/**
 * @brief Callback function type for connection status changes (informational).
 * @param connected True if connected, false if disconnected/connecting/retrying.
 */
using ConnectionStatusCallback = std::function<void(bool connected)>;


// --- CloudComm Class ---
class CloudComm {
   public:
    explicit CloudComm(platform::storage::FileSystem& file_manager);
    ~CloudComm();

    // Disable copy/move
    CloudComm(const CloudComm&) = delete;
    CloudComm& operator=(const CloudComm&) = delete;
    CloudComm(CloudComm&&) = delete;
    CloudComm& operator=(CloudComm&&) = delete;

    /**
     * @brief Initializes the cloud communication module using configuration loaded internally.
     * Loads certificates and MQTT endpoint details from files specified by member paths.
     * Configures the underlying client and sets up necessary subscriptions.
     * @return True if initialization was successful, false otherwise.
     */
    bool Initialize();

    /**
     * @brief Initiates a connection attempt to AWS IoT Core.
     * Handles the transition to the CONNECTING state. Use Process() to manage retries.
     * @param reset_retry_state If true (default), resets the internal reconnect backoff state.
     * @return True if the connection attempt was newly initiated or already in progress/connected,
     * false on immediate error (e.g., not initialized).
     */
    bool Connect(bool reset_retry_state = true);

    /**
     * @brief Disconnects from the AWS IoT Core broker.
     * Resets the internal state to DISCONNECTED and stops automatic retries.
     * Clears any pending shadow report.
     */
    void Disconnect();

    /**
     * @brief Checks the current connection status (based on last known event).
     * @return True if the internal state is CONNECTED, false otherwise.
     */
    bool IsConnected() const;

    /**
     * @brief Processes internal state, including reconnection logic and pending shadow reports.
     * MUST be called periodically by the application to handle connection retries,
     * process underlying client events, and send pending shadow updates.
     */
    void Process();

    /**
     * @brief Sends a status packet (e.g., sensor data, events) to the MQTT broker.
     * Constructs a JSON message and publishes to the appropriate topic (status or timeseries).
     * If not connected, data may be backlogged (implementation specific via DataBuffer).
     * @param packet_type The type identifier of the status packet.
     * @param packet_data A pointer to the raw packet data structure.
     * @param packet_size The size of the packet data structure.
     * @return true if the packet was sent immediately or successfully backlogged, false on error.
     */
    bool SendDataToCloud(uint8_t packet_type, const void* packet_data, size_t packet_size);

    /**
     * @brief Sends queued log events to the cloud logging topic. (Rate limited internally).
     * Intended to be called periodically, potentially from within Process().
     * @return True if a log event was successfully published, false otherwise (no event, not connected, or publish error).
     */
    bool SendLogEvent();

    /**
     * @brief Reports the device's current state PROACTIVELY to the AWS IoT Shadow 'reported' section.
     * Use this function when the application wants to push its state outside of responding to a delta.
     * Call this after successfully processing a command from the shadow 'desired' state,
     * or anytime the device needs to proactively report its state. Uses dynamic memory
     * (StringBuffer) internally for JSON serialization.
     * @param reported_state A RapidJSON Value object (must be an object type) representing the
     * state to report.
     * @param qos The Quality of Service level (usually 1).
     * @return True if the state report was successfully queued for publishing, false otherwise.
     */
    bool ReportCurrentState(const rapidjson::Value& reported_state, int qos = 1);

    // --- Callback Setters ---
    void SetControlCommandCallback(ControlCommandCallback callback);
    void SetConnectionStatusCallback(ConnectionStatusCallback callback);

   private:
    platform::storage::FileSystem& file_manager_;

    // --- Internal State Machine ---
    enum class State { UNINITIALIZED, DISCONNECTED, CONNECTING, CONNECTED, WAITING_TO_RETRY };
    std::atomic<State> current_state_{State::UNINITIALIZED};

    // --- MQTT Client ---
    platform::network::AwsIotMqttClient aws_mqtt_client_;

    // --- Configuration & Topics (Loaded from file) ---
    char thing_name_[kMaxThingNameLen] = {0};
    char staging_env_[10] = {0}; // Consider increasing size if needed
    char mqtt_endpoint_[kMaxMqttEndPointLen] = {0};
    char logger_topic_[kMaxTopicLen] = {0};
    char status_topic_[kMaxTopicLen] = {0};
    char timeseries_topic_[kMaxTopicLen] = {0};
    // Paths for configuration files (can be overridden if needed)
    const char* root_ca_path_ = "/certCA.pem";
    const char* device_cert_path_ = "/certificate.pem";
    const char* private_key_path_ = "/private.pem.key";
    const char* mqtt_config_path_ = "/mqttConfiguration.json";

    // --- Callbacks ---
    ControlCommandCallback control_command_callback_{nullptr};
    ConnectionStatusCallback connection_status_callback_{nullptr};

    // --- Buffers ---
    char json_parse_buffer_[kMaxPayloadSize] = {0}; // Buffer for parsing incoming JSON payloads
    DataBuffer backlog_packets_; // For queueing packets when offline (ensure class definition exists)

    // --- Reconnect Logic ---
    uint64_t last_disconnect_time_ms_ = 0;
    uint32_t current_backoff_delay_ms_ = kInitialBackoffMs;
    int reconnect_attempts_ = 0;

    // --- Shadow Handling ---
    bool initial_shadow_received_ = false;
    uint16_t get_shadow_attempts_ = 0;
    uint64_t last_get_shadow_attempt_ms_ = 0;
    uint32_t current_get_shadow_backoff_ms_ = kGetShadowRetryBaseMs; // Start with base retry delay

    // --- Pending Shadow Report State (NEW) ---
    std::atomic<bool> shadow_report_pending_{false}; // Flag to indicate a report is ready in the payload
    std::string pending_shadow_report_payload_;      // Stores the full JSON payload {"state":{"reported":{...}}}
    platform::mutex::Mutex pending_report_mutex_;    // Mutex to protect access to the payload string


    // --- Timers / Intervals ---
    uint64_t last_log_event_send_check_time_ = 0;
    uint64_t last_backlog_packet_sent_time_ = 0; // Added for potential backlog processing

    // --- Constants ---
    // Network Config
    static constexpr uint16_t kDefaultMqttPort = 8883;
    static constexpr int kDefaultMqttRxBufferSize = 2048; // Adjust if needed
    static constexpr int kDefaultMqttTxBufferSize = 2048; // Adjust if needed
    // Sizes
    static constexpr std::size_t kMaxPayloadSize = 2048;  // Max JSON payload size for internal PARSING buffer
    static constexpr size_t kMaxTopicLen = 128;          // Increased topic length buffer
    static constexpr size_t kMaxCommandKeyLen = 64;      // Max length for a command key name from shadow
    static constexpr size_t kMaxThingNameLen = 64;       // Increased thing name buffer
    static constexpr size_t kMaxMqttEndPointLen = 128;   // Increased endpoint buffer
    static constexpr size_t kMaxFilePathLen = 128;       // Max length for cert/config file paths
    // Reconnect Timing
    static constexpr uint32_t kInitialBackoffMs = 1000;  // 1 second initial reconnect delay
    static constexpr uint32_t kMaxBackoffMs = 60000;     // 60 seconds maximum reconnect delay
    // Get Shadow Retry Timing
    static constexpr uint16_t kMaxGetShadowAttempts = 10; // Limit initial get attempts
    static constexpr uint32_t kGetShadowRetryBaseMs = 5000; // Base retry for get shadow (e.g., 5s)
    static constexpr uint32_t kMaxGetShadowRetryMs = 30000; // Max retry for get shadow (e.g., 30s)
    // Log Event Interval
    static constexpr uint32_t kLogEventSendIntervalMs = 10000; // Check for logs every 10s

    // --- Private Helper Methods ---
    bool AttemptReconnect();
    bool CommonInitializeSetup();
    void HandleDisconnectInternal();
    void PollShadow(); // Renamed from PollShadow for clarity
    bool LoadCertificateFromFile(const char* full_path, char* buffer, std::size_t buffer_size);
    bool LoadMqttConfigs();
    bool PublishJsonToTopic(const char* topic, const rapidjson::Value& json_payload, int qos = 1, bool retain = false);
    void RequestShadowState();
    void ProcessReceivedShadowDelta(const rapidjson::Value& delta_state); // Processes commands, prepares report if needed
    void ProcessReceivedShadowDocument(rapidjson::Document& doc); // Processes full shadow doc (e.g., /get/accepted)

    // --- Internal Callbacks ---
    void OnConnected();
    void OnDisconnected();
    // Callback signature matching AwsIotMqttClient expected type
    void HandleShadowCallback(const std::string& update_type, std::string_view payload);

}; // class CloudComm

} // namespace visium

#endif // CLOUD_COMM_H_

----------------------------------------------------------------------------------------------------------------------------------------

#include "cloud_communication.h" // Include the header first

#include <algorithm>
#include <cstdio>
#include <cstring>
// <string>, <atomic>, <functional>, <string_view>, <cstddef>, <cstdint> are included via header
// <platform/mutex.h>, <platform/storage/file_system.h>, <platform/network/aws_iot_mqtt_client.h> included via header
// <rapidjson/document.h> included via header

// --- Assumed Project Includes ---
// Ensure these are accessible and correct
#include "log_print.h"          // For LOG_PRINT
#include "log_transfer.h"       // For GetLogEvent, CreateLogEvent
#include "status_packet.h"      // For TOTAL_STATUS_PACKET_TYPES etc. and CreateStatusPacketJSON placeholder
#include "system_uptime.h"      // For GetMs, ExceedsMs
#include "version.h"            // For VISIUM_FW_VERSION (make sure this define exists)
// --- End Assumed Project Includes ---

#include "rapidjson/stringbuffer.h" // Needed for serialization
#include "rapidjson/writer.h"       // Needed for serialization


namespace visium {

using namespace platform; // Assuming FileSystem, Mutex, etc. are in platform namespace

// --- Forward declare helper if needed ---
// Placeholder - ensure this exists and is implemented correctly elsewhere
bool CreateStatusPacketJSON(rapidjson::Document& doc, rapidjson::Document::AllocatorType& allocator, uint8_t packet_type, const void* packet_data);


// --- Constructor ---
CloudComm::CloudComm(storage::FileSystem& file_manager)
    : file_manager_(file_manager),
      current_state_(State::UNINITIALIZED),
      shadow_report_pending_{false} // Initialize new atomic flag
      // pending_report_mutex_ is default constructed
{
    // Existing initializations...
    memset(thing_name_, 0, sizeof(thing_name_));
    memset(json_parse_buffer_, 0, sizeof(json_parse_buffer_));
    // NOTE: Mutex (`pending_report_mutex_`) usually doesn't need explicit initialization
    // unless your platform specific mutex requires it.
}

// --- Destructor ---
CloudComm::~CloudComm() {
    State current = current_state_.load();
    if (current != State::UNINITIALIZED && current != State::DISCONNECTED) {
        Disconnect(); // Ensure disconnection on destruction if connected/connecting
    }
}

// --- Public Methods ---

bool CloudComm::Initialize() {
    LOG_PRINT(log_print::kVERBOSE, "Initializing CloudComm...");
    if (current_state_.load() != State::UNINITIALIZED) {
        LOG_PRINT(log_print::kWARN, "Already initialized or initializing.");
        return (current_state_.load() != State::UNINITIALIZED);
    }

    if (!LoadMqttConfigs()) { // Load config first to get thing name, endpoint etc.
         LOG_PRINT(log_print::kERROR, "Failed to load MQTT configurations.");
         return false;
    }

    network::MqttConfig client_config_internal = {};
    client_config_internal.aws_endpoint = mqtt_endpoint_;
    client_config_internal.client_id = thing_name_;
    client_config_internal.thing_name = thing_name_;
    client_config_internal.port = kDefaultMqttPort;
    client_config_internal.rx_buffer_size = kDefaultMqttRxBufferSize;
    client_config_internal.tx_buffer_size = kDefaultMqttTxBufferSize;

    LOG_PRINT(log_print::kDEBUG5, "Loading CA from: %s", root_ca_path_);
    // Allocate temporary buffers for certs on stack if kMaxCertLen is reasonable, else use members
    char root_ca_buffer[network::kMaxCertLen];
    char device_cert_buffer[network::kMaxCertLen];
    char private_key_buffer[network::kMaxCertLen];

    if (!LoadCertificateFromFile(root_ca_path_, root_ca_buffer, sizeof(root_ca_buffer))) {
        LOG_PRINT(log_print::kERROR, "Failed to load CA cert: %s", root_ca_path_);
        return false;
    }
    client_config_internal.root_ca_pem = root_ca_buffer;

    LOG_PRINT(log_print::kDEBUG5, "Loading device cert from: %s", device_cert_path_);
    if (!LoadCertificateFromFile(device_cert_path_, device_cert_buffer, sizeof(device_cert_buffer))) {
        LOG_PRINT(log_print::kERROR, "Failed to load device cert: %s", device_cert_path_);
        return false;
    }
    client_config_internal.device_cert_pem = device_cert_buffer;

    LOG_PRINT(log_print::kDEBUG5, "Loading private key from: %s", private_key_path_);
    if (!LoadCertificateFromFile(private_key_path_, private_key_buffer, sizeof(private_key_buffer))) {
        LOG_PRINT(log_print::kERROR, "Failed to load private key: %s", private_key_path_);
        return false;
    }
    client_config_internal.private_key_pem = private_key_buffer;

    LOG_PRINT(log_print::kDEBUG5, "Certificates loaded successfully.");

    // --- Initialize Underlying Client ---
    if (!aws_mqtt_client_.Initialize(client_config_internal)) {
        LOG_PRINT(log_print::kERROR, "Failed to initialize underlying AwsIotMqttClient.");
        return false;
    }

    // --- Common Setup Steps (Callbacks & Subscriptions) ---
    if (!CommonInitializeSetup()) {
        aws_mqtt_client_.Disconnect(); // Attempt cleanup
        return false;
    }

    // --- Set Initial State ---
    current_state_.store(State::DISCONNECTED);
    last_disconnect_time_ms_ = 0;
    current_backoff_delay_ms_ = kInitialBackoffMs;
    reconnect_attempts_ = 0;

    // Reset pending report state on initialization
    shadow_report_pending_.store(false);
    pending_shadow_report_payload_.clear();

    LOG_PRINT(log_print::kINFO,
              "CloudComm initialized successfully for Thing: %s. State: DISCONNECTED.",
              thing_name_);
    return true;
}

bool CloudComm::Connect(bool reset_retry_state) {
    State current = current_state_.load();
    LOG_PRINT(log_print::kINFO, "Manual Connect requested (reset_retry=%s). Current state: %d",
              reset_retry_state ? "true" : "false", static_cast<int>(current));

    if (current == State::UNINITIALIZED) {
        LOG_PRINT(log_print::kERROR, "Cannot connect: Not initialized.");
        return false;
    }

    if (current == State::CONNECTING || current == State::CONNECTED) {
        LOG_PRINT(log_print::kWARN,
                  "Manual Connect called while already connecting or connected. "
                  "Resetting retry state only.");
        if (reset_retry_state) {
            reconnect_attempts_ = 0;
            current_backoff_delay_ms_ = kInitialBackoffMs;
            last_disconnect_time_ms_ = 0; // Allow immediate retry by Process if currently WAITING
        }
        return true;
    }

    // If DISCONNECTED or WAITING_TO_RETRY, reset state if requested and attempt connect immediately
    if (reset_retry_state) {
        LOG_PRINT(log_print::kDEBUG1, "Resetting reconnect state due to manual connect call.");
        reconnect_attempts_ = 0;
        current_backoff_delay_ms_ = kInitialBackoffMs;
        last_disconnect_time_ms_ = 0;
    }

    // Attempt connection immediately, regardless of backoff timer when called manually
    return AttemptReconnect();
}

void CloudComm::Disconnect() {
    LOG_PRINT(log_print::kINFO, "Disconnect requested by application.");
    State previous_state = current_state_.exchange(State::DISCONNECTED); // Atomically set state

    if (previous_state != State::UNINITIALIZED && previous_state != State::DISCONNECTED) {
        LOG_PRINT(log_print::kDEBUG1, "Calling underlying MQTT disconnect.");
        aws_mqtt_client_.Disconnect();
    } else {
        LOG_PRINT(log_print::kDEBUG1, "Already disconnected or uninitialized.");
    }

    // Reset connection state regardless of previous state
    reconnect_attempts_ = 0;
    current_backoff_delay_ms_ = kInitialBackoffMs;
    last_disconnect_time_ms_ = 0;

    // Also clear any pending report on explicit disconnect
    {
        platform::mutex::LockGuard lock(pending_report_mutex_);
        shadow_report_pending_.store(false, std::memory_order_relaxed); // Relaxed ok inside lock
        pending_shadow_report_payload_.clear();
    }
     // Reset shadow flags as well
    initial_shadow_received_ = false;
    get_shadow_attempts_ = 0;
    last_get_shadow_attempt_ms_ = 0;
    current_get_shadow_backoff_ms_ = kGetShadowRetryBaseMs;
}

bool CloudComm::IsConnected() const {
    return (current_state_.load() == State::CONNECTED);
}

void CloudComm::Process() {
    State state = current_state_.load();

    switch (state) {
        case State::DISCONNECTED: {
            // Waiting for manual Connect() or external event.
            LOG_PRINT(log_print::kDEBUG4,"Process: State is DISCONNECTED.");
            break;
        }
        case State::WAITING_TO_RETRY: {
            if (system_uptime::ExceedsMs(last_disconnect_time_ms_, current_backoff_delay_ms_)) {
                LOG_PRINT(log_print::kINFO,
                          "Process: Reconnect timer elapsed. Attempting reconnect...");
                AttemptReconnect(); // This will change state to CONNECTING if successful
            } else {
                 LOG_PRINT(log_print::kDEBUG4,"Process: State is WAITING_TO_RETRY.");
            }
            break;
        }
        case State::CONNECTED: {
             LOG_PRINT(log_print::kDEBUG4,"Process: State is CONNECTED.");
            // --- Check for pending shadow report ---
            if (shadow_report_pending_.load(std::memory_order_acquire)) {
                std::string payload_to_send;
                bool report_was_pending = false;
                { // Mutex scope
                    platform::mutex::LockGuard lock(pending_report_mutex_);
                    // Re-check flag inside lock to handle race where flag was cleared between outer check and acquiring lock
                    if (shadow_report_pending_.load(std::memory_order_relaxed)) { // Relaxed is fine inside lock
                         payload_to_send = std::move(pending_shadow_report_payload_);
                         pending_shadow_report_payload_.clear();
                         shadow_report_pending_.store(false, std::memory_order_relaxed); // Clear flag inside lock
                         report_was_pending = true;
                    }
                } // Mutex released

                if (report_was_pending && !payload_to_send.empty()) {
                     LOG_PRINT(log_print::kINFO, "Process: Sending pending shadow state report (%zu bytes)...", payload_to_send.length());
                     // Perform potentially blocking call OUTSIDE the mutex lock
                     if (!aws_mqtt_client_.UpdateShadow(std::string_view(payload_to_send))) {
                         LOG_PRINT(log_print::kERROR, "Process: Failed to send pending shadow update via MQTT client.");
                         // Failure here doesn't reset the flag; the report payload is consumed.
                         // The system will rely on the next delta or application action to try again if needed.
                     } else {
                         LOG_PRINT(log_print::kDEBUG1, "Process: Pending shadow report sent successfully.");
                     }
                }
            } // End check for pending report

            // --- Poll for initial shadow if needed ---
            PollShadow();

            // --- Send Log Events ---
            // SendLogEvent(); // Call if desired

            // --- Send Backlogged Data ---
            // Add logic here if Process() should handle sending backlogged data
            // e.g., SendNextBacklogItem();

            break; // End CONNECTED case
        }
        case State::CONNECTING: {
             // Waiting for OnConnected or OnDisconnected callback from underlying client
             LOG_PRINT(log_print::kDEBUG3, "Process: State is CONNECTING. Waiting for connection result...");
             // Optional: Add a timeout check for the CONNECTING state here?
             break;
        }
        case State::UNINITIALIZED:
        default:
            // Do nothing
             LOG_PRINT(log_print::kDEBUG4,"Process: State is UNINITIALIZED or unknown (%d).", (int)state);
            break;
    } // End switch(state)

     // Yield or process underlying client events periodically regardless of state (MANDATORY for many clients)
    aws_mqtt_client_.Yield(); // Replace Yield() with the actual function name if different (e.g., loop(), ProcessLoop())
}


bool CloudComm::SendDataToCloud(uint8_t packet_type, const void* packet_data, size_t packet_size) {
    if (packet_type >= TOTAL_STATUS_PACKET_TYPES) { // Assuming TOTAL_STATUS_PACKET_TYPES is defined
         LOG_PRINT(log_print::kERROR, "SendDataToCloud: Invalid packet_type: %u", packet_type);
         return false;
    }
    if (!packet_data || packet_size == 0) {
         LOG_PRINT(log_print::kERROR, "SendDataToCloud: Invalid packet data or size for type %u.", packet_type);
         return false;
    }


    if (IsConnected()) {
        LOG_PRINT(log_print::kDEBUG1, "SendDataToCloud: Connected. Sending Packet Type: %u, Size: %zu", packet_type, packet_size);
        rapidjson::Document data_doc; // Use Document for allocator ownership
        rapidjson::Document::AllocatorType& allocator = data_doc.GetAllocator();
        data_doc.SetObject();

        // Create the JSON payload using the provided function (ensure it exists and works)
        if (!CreateStatusPacketJSON(data_doc, allocator, packet_type, packet_data)) {
             LOG_PRINT(log_print::kERROR, "SendDataToCloud: Failed to create JSON for packet type %u", packet_type);
             return false;
        }

        last_backlog_packet_sent_time_ = system_uptime::GetMs(); // Record time even if publish fails? Maybe only on success.

        // Determine the correct topic
        const char* topic_to_use = nullptr;
        if (packet_type == PACKET_TYPE_ENV_SENSOR_DATA) { // Assuming these constants exist
            topic_to_use = timeseries_topic_;
        } else {
            topic_to_use = status_topic_; // Default topic for other types
        }

         bool success = PublishJsonToTopic(topic_to_use, data_doc); // Pass the Document

         if (success) {
              last_backlog_packet_sent_time_ = system_uptime::GetMs(); // Update time on success
              if (packet_type != PACKET_TYPE_ENV_SENSOR_DATA) {
                   // Clear corresponding non-timeseries backlog entry *after* successful send.
                   // Assuming AddStatusData with size 0 means 'clear' or 'mark sent'
                   backlog_packets_.AddStatusData(packet_type, nullptr, 0); // Use nullptr for data
              }
         }
         return success;

    } else {
        // Not connected, add to backlog
        LOG_PRINT(log_print::kWARN, "SendDataToCloud: Not connected. Backlogging packet type %u.", packet_type);
        if (packet_type == PACKET_TYPE_ENV_SENSOR_DATA) {
            // Assuming AddData is for timeseries backlog
            return backlog_packets_.AddData(packet_type, static_cast<const uint8_t*>(packet_data), packet_size);
        } else {
            // Assuming AddStatusData is for other status/event backlog
            return backlog_packets_.AddStatusData(packet_type, static_cast<const uint8_t*>(packet_data), packet_size);
        }
        // Return value indicates success/failure of backlogging operation itself
    }
}

bool CloudComm::SendLogEvent() {
    if (!IsConnected()) {
        LOG_PRINT(log_print::kDEBUG2, "SendLogEvent: Cannot send, not connected.");
        return false;
    }

    // Check if it's time to check for logs
    if (system_uptime::ExceedsMs(last_log_event_send_check_time_, kLogEventSendIntervalMs)) {
        last_log_event_send_check_time_ = system_uptime::GetMs();

        // Check if log_transfer has an event
        uint8_t buffer[128]; // Adjust buffer size as needed
        uint32_t event_code = 0;
        uint64_t timestamp = 0;

        // Assuming GetLogEvent returns true if an event is available
        if (log_transfer::GetLogEvent(&event_code, &timestamp)) {
            size_t size =
                log_transfer::CreateLogEvent(event_code, timestamp, buffer, sizeof(buffer));

            if (size > 0 && size < sizeof(buffer)) { // Check size validity
                LOG_PRINT(log_print::kDEBUG1, "Sending log event: Code=%u, Timestamp=%llu, Size=%zu",
                         event_code, timestamp, size);
                // Publish directly using AwsIotMqttClient
                if (aws_mqtt_client_.Publish(logger_topic_, buffer, size)) {
                    // Optional: Add logic here if GetLogEvent needs confirmation before removing the event.
                    return true; // Successfully published
                } else {
                     LOG_PRINT(log_print::kERROR, "Failed to publish log event to topic: %s", logger_topic_);
                     // Optional: Put the event back? Or retry later? Current code just fails for this attempt.
                     return false; // Publish failed
                }
            } else {
                 LOG_PRINT(log_print::kERROR, "Failed to create log event payload (size %zu).", size);
                 return false; // Payload creation failed
            }
        } else {
            // No log event currently available
            LOG_PRINT(log_print::kDEBUG4, "No log event available to send.");
            return false; // No event to send
        }
    }
     return false; // Not time to check yet
}

bool CloudComm::ReportCurrentState(const rapidjson::Value& reported_state, int qos) {
    // This function is for *proactive* reporting initiated by the application.
    if (!IsConnected()) {
        LOG_PRINT(log_print::kWARN, "ReportCurrentState: Cannot report, not connected.");
        return false;
    }
    if (!reported_state.IsObject()) {
        LOG_PRINT(log_print::kERROR, "ReportCurrentState: Input 'reported_state' must be a JSON object.");
        return false;
    }

    // Construct the full shadow update payload: {"state":{"reported":{...}}}
    rapidjson::Document shadow_doc(rapidjson::kObjectType);
    auto& allocator = shadow_doc.GetAllocator();

    rapidjson::Value state_val(rapidjson::kObjectType);
    // IMPORTANT: Need to deep copy the incoming reported_state using the allocator
    state_val.AddMember("reported", rapidjson::Value(reported_state, allocator).Move(), allocator);

    shadow_doc.AddMember("state", state_val, allocator);

    // Serialize the document
    rapidjson::StringBuffer string_buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(string_buffer);
    shadow_doc.Accept(writer);

    const char* json_string = string_buffer.GetString();
    size_t json_len = string_buffer.GetSize();

    LOG_PRINT(log_print::kINFO, "Reporting application-initiated state to shadow (%zu bytes): %s", json_len,
              json_string);

    // Publish using the underlying client's UpdateShadow method
    return aws_mqtt_client_.UpdateShadow(std::string_view(json_string, json_len), qos);
}

void CloudComm::SetControlCommandCallback(ControlCommandCallback callback) {
    control_command_callback_ = std::move(callback);
    LOG_PRINT(log_print::kVERBOSE, "Control command callback registered.");
}

void CloudComm::SetConnectionStatusCallback(ConnectionStatusCallback callback) {
    connection_status_callback_ = std::move(callback);
    LOG_PRINT(log_print::kVERBOSE, "Connection status callback registered.");
}


// --- Private Helper Methods ---

bool CloudComm::CommonInitializeSetup() {
    aws_mqtt_client_.SetOnConnectedCallback([this]() { this->OnConnected(); });
    aws_mqtt_client_.SetOnDisconnectedCallback([this]() { this->OnDisconnected(); });

    LOG_PRINT(log_print::kVERBOSE, "Setting up shadow subscriptions.");
    auto shadow_handler = [this](const std::string& type, std::string_view payload) {
        this->HandleShadowCallback(type, payload);
    };

    // Subscribe to the topics needed for shadow interaction
    if (!aws_mqtt_client_.SubscribeToShadowUpdates(shadow_handler)) {
        LOG_PRINT(log_print::kERROR, "Common setup failed: Shadow update subscription failed!");
        return false;
    }

    if (!aws_mqtt_client_.SubscribeToShadowGetResponses(shadow_handler)) {
        LOG_PRINT(log_print::kERROR,
                  "Common setup failed: Shadow get response subscription failed!");
        return false;
    }
    return true;
}

bool CloudComm::AttemptReconnect() {
    LOG_PRINT(log_print::kINFO, "Attempting MQTT connection (Attempt #%d)...",
              reconnect_attempts_ + 1);
    State expected_disconnected = State::DISCONNECTED;
    State expected_waiting = State::WAITING_TO_RETRY;

    // Try to transition from WAITING or DISCONNECTED to CONNECTING
    if (!current_state_.compare_exchange_strong(expected_waiting, State::CONNECTING) &&
        !current_state_.compare_exchange_strong(expected_disconnected, State::CONNECTING))
    {
        State actual_state = current_state_.load();
        // This condition means we are already CONNECTING or CONNECTED, or maybe UNINITIALIZED. Don't try again.
        LOG_PRINT(log_print::kWARN,
                  "AttemptReconnect skipped: Could not transition from WAITING/DISCONNECTED state. "
                  "Current state: %d", static_cast<int>(actual_state));
        return false;
    }

    // --- State is now CONNECTING ---
    LOG_PRINT(log_print::kDEBUG1, "State changed to CONNECTING.");

    if (!aws_mqtt_client_.Connect()) {
        LOG_PRINT(log_print::kWARN,
                  "Underlying aws_mqtt_client_.Connect() call failed initiation immediately.");
        // Connection attempt failed immediately, go back to WAITING_TO_RETRY
        // Use HandleDisconnectInternal to manage the state transition and backoff.
        HandleDisconnectInternal(); // This should set state to WAITING_TO_RETRY
        return false; // Indicate immediate failure
    }

    // Underlying client initiated the connection attempt (async)
    LOG_PRINT(log_print::kDEBUG1, "MQTT connection attempt initiated via client. Waiting for callback.");
    reconnect_attempts_++; // Increment attempt count
    return true; // Indicate connection attempt was started
}


void CloudComm::HandleDisconnectInternal() {
    State previous_state = current_state_.load();

    // Only process disconnect if we were previously connected or trying to connect
    if (previous_state == State::CONNECTED || previous_state == State::CONNECTING) {
        LOG_PRINT(log_print::kWARN, "Internal: Handling disconnection event. Previous state: %d",
                  (int)previous_state);
        last_disconnect_time_ms_ = system_uptime::GetMs();

        // Calculate next backoff delay only if we were connected (don't increase delay if CONNECTING failed)
        if (previous_state == State::CONNECTED) {
             uint64_t next_delay = static_cast<uint64_t>(current_backoff_delay_ms_) * 2;
             current_backoff_delay_ms_ =
                 static_cast<uint32_t>(std::min(next_delay, static_cast<uint64_t>(kMaxBackoffMs)));
        } else {
            // If connect attempt failed (was CONNECTING), maybe use initial delay or keep current one?
            // Let's reset to initial for failed connection attempts.
             current_backoff_delay_ms_ = kInitialBackoffMs;
        }


        // Attempt to transition to WAITING_TO_RETRY atomically
        State expected_state = previous_state; // We expect to be in the state we just read
        if (current_state_.compare_exchange_strong(expected_state, State::WAITING_TO_RETRY)) {
            LOG_PRINT(log_print::kINFO,
                      "State changed to WAITING_TO_RETRY. Next attempt (#%d) in %u ms.",
                      reconnect_attempts_ + 1, current_backoff_delay_ms_);

            // Clear pending report on disconnect
            {
                platform::mutex::LockGuard lock(pending_report_mutex_);
                shadow_report_pending_.store(false, std::memory_order_relaxed);
                pending_shadow_report_payload_.clear();
            }
            // Reset shadow flags
            initial_shadow_received_ = false;
            get_shadow_attempts_ = 0;
            last_get_shadow_attempt_ms_ = 0;
            current_get_shadow_backoff_ms_ = kGetShadowRetryBaseMs; // Reset shadow retry backoff


            // Notify application about disconnection status change *after* state is updated
            if (connection_status_callback_) {
                connection_status_callback_(false);
            }
        } else {
            // This case means the state changed *again* between reading `previous_state`
            // and the `compare_exchange_strong`. Could be an external Disconnect() call.
            LOG_PRINT(log_print::kWARN,
                      "Disconnect handling aborted: State changed unexpectedly from %d to %d "
                      "before transitioning to WAITING_TO_RETRY.",
                      (int)previous_state, (int)expected_state);
            // State is already something else (likely DISCONNECTED), so don't force it back to WAITING.
            // Ensure pending report is cleared anyway if the new state is disconnected.
            if (expected_state == State::DISCONNECTED) {
                 platform::mutex::LockGuard lock(pending_report_mutex_);
                 shadow_report_pending_.store(false, std::memory_order_relaxed);
                 pending_shadow_report_payload_.clear();
            }
        }
    } else {
        // Ignore redundant disconnect events if we are already disconnected, waiting, or uninitialized.
        LOG_PRINT(log_print::kDEBUG1,
                  "Internal: Ignoring redundant disconnect event while in state %d.",
                  (int)previous_state);
    }
}


void CloudComm::PollShadow() {
    // Only poll if connected and initial shadow hasn't been received
    if (initial_shadow_received_ || current_state_.load() != State::CONNECTED) {
        return;
    }

    if (system_uptime::ExceedsMs(last_get_shadow_attempt_ms_, current_get_shadow_backoff_ms_)) {
        if (get_shadow_attempts_ >= kMaxGetShadowAttempts) {
            LOG_PRINT(log_print::kERROR,
                      "PollShadow: Max GetShadow attempts (%u) reached. Giving up polling.",
                      kMaxGetShadowAttempts);
            // Mark as received to stop polling, even though it failed.
            // Consider alternative error handling - maybe trigger disconnect/reconnect?
            initial_shadow_received_ = true; // Stop polling
            return;
        }

        LOG_PRINT(log_print::kINFO, "PollShadow: Attempting GetShadow (Attempt #%u)...",
                  get_shadow_attempts_ + 1);
        RequestShadowState(); // This sends the MQTT message for /get

        last_get_shadow_attempt_ms_ = system_uptime::GetMs();
        get_shadow_attempts_++;

        // Increase backoff delay for next attempt (simple linear increase for example)
        current_get_shadow_backoff_ms_ = std::min(
            current_get_shadow_backoff_ms_ + kGetShadowRetryBaseMs, kMaxGetShadowRetryMs);

        LOG_PRINT(log_print::kDEBUG1, "Next GetShadow attempt in %u ms.",
                  current_get_shadow_backoff_ms_);
    }
}

bool CloudComm::LoadCertificateFromFile(const char* file_path, char* buffer, size_t buffer_size) {
    if (!file_path || !buffer || buffer_size == 0) {
        LOG_PRINT(log_print::kERROR, "LoadCertificateFromFile: Invalid arguments.");
        return false;
    }

    memset(buffer, 0, buffer_size); // Clear buffer first
    size_t bytes_read = 0;
    // Read one less than buffer size to guarantee space for null terminator
    storage::FileSystem::ErrorCode err =
        file_manager_.Read(file_path, buffer, buffer_size - 1, &bytes_read);

    if (err == storage::FileSystem::ErrorCode::kOk) {
        buffer[bytes_read] = '\0'; // Ensure null termination
        LOG_PRINT(log_print::kDEBUG5, "Successfully read %zu bytes from %s", bytes_read, file_path);
        return true;
    } else {
        LOG_PRINT(log_print::kERROR, "Failed to read file %s. Error code: %d", file_path, static_cast<int>(err));
        memset(buffer, 0, buffer_size); // Clear buffer on failure
        return false;
    }
}

bool CloudComm::LoadMqttConfigs() {
    LOG_PRINT(log_print::kDEBUG1, "Loading MQTT config from: %s", mqtt_config_path_);
    // Use a dynamically sized buffer or a larger static one if needed
    char read_buffer[512]; // Adjust size as necessary
    size_t bytes_read = 0;

    storage::FileSystem::ErrorCode err =
        file_manager_.Read(mqtt_config_path_, read_buffer, sizeof(read_buffer) - 1 , &bytes_read);

    if (err != storage::FileSystem::ErrorCode::kOk) {
         LOG_PRINT(log_print::kERROR, "Failed to read MQTT config file: %s, Error: %d",
                 mqtt_config_path_, static_cast<int>(err));
        return false;
    }
    read_buffer[bytes_read] = '\0'; // Null terminate the read content

    rapidjson::Document mqtt_config;
    // Use Parse, not ParseInsitu, as read_buffer might change if file system reuses buffers etc.
    mqtt_config.Parse(read_buffer); // Parse the null-terminated string

    if (mqtt_config.HasParseError()) {
        LOG_PRINT(log_print::kERROR, "Failed to parse MQTT config JSON. Error '%s' at offset %zu",
                 rapidjson::GetParseError_En(mqtt_config.GetParseError()), // Get error string
                 mqtt_config.GetErrorOffset());
        return false;
    }

    if (!mqtt_config.IsObject()) {
         LOG_PRINT(log_print::kERROR, "MQTT config JSON root is not an object.");
         return false;
    }

    // Extract values safely using HasMember and type checks
    bool success = true;
    if (mqtt_config.HasMember("clientid") && mqtt_config["clientid"].IsString()) {
        strncpy(thing_name_, mqtt_config["clientid"].GetString(), sizeof(thing_name_) - 1);
        thing_name_[sizeof(thing_name_) - 1] = '\0'; // Ensure null termination
    } else {
        LOG_PRINT(log_print::kERROR, "MQTT config missing or invalid 'clientid' (string).");
        success = false;
    }

    if (mqtt_config.HasMember("env") && mqtt_config["env"].IsString()) {
        strncpy(staging_env_, mqtt_config["env"].GetString(), sizeof(staging_env_) - 1);
        staging_env_[sizeof(staging_env_) - 1] = '\0'; // Ensure null termination
    } else {
        LOG_PRINT(log_print::kERROR, "MQTT config missing or invalid 'env' (string).");
        success = false;
    }

    if (mqtt_config.HasMember("host") && mqtt_config["host"].IsString()) {
        strncpy(mqtt_endpoint_, mqtt_config["host"].GetString(), sizeof(mqtt_endpoint_) - 1);
        mqtt_endpoint_[sizeof(mqtt_endpoint_) - 1] = '\0'; // Ensure null termination
    } else {
        LOG_PRINT(log_print::kERROR, "MQTT config missing or invalid 'host' (string).");
        success = false;
    }

    // Allow execution to continue to construct topics even if some configs failed,
    // but return the overall success state.
    if (!success) {
         LOG_PRINT(log_print::kERROR, "One or more essential MQTT config values are missing or invalid.");
    }

    // Construct topics using snprintf for safety against buffer overflows
    // Ensure VISIUM_FW_VERSION is defined, perhaps in version.h
    snprintf(status_topic_, sizeof(status_topic_), "lit/%s/cloud/status/%s", staging_env_, VISIUM_FW_VERSION);
    snprintf(timeseries_topic_, sizeof(timeseries_topic_), "lit/%s/cloud/timeseries/%s", staging_env_, VISIUM_FW_VERSION);
    snprintf(logger_topic_, sizeof(logger_topic_), "lit/%s/cloud/logging/%s", staging_env_, thing_name_); // Use thing_name_ for logger topic

    LOG_PRINT(log_print::kINFO, "MQTT Config Loaded: Thing=%s, Endpoint=%s, Env=%s", thing_name_, mqtt_endpoint_, staging_env_);
    LOG_PRINT(log_print::kDEBUG5, "Status topic: %s", status_topic_);
    LOG_PRINT(log_print::kDEBUG5, "Timeseries topic: %s", timeseries_topic_);
    LOG_PRINT(log_print::kDEBUG5, "Logger topic: %s", logger_topic_);

    return success; // Return true only if all essential configs were found
}

bool CloudComm::PublishJsonToTopic(const char* topic, const rapidjson::Value& json_payload, int qos, bool retain) {
    if (!IsConnected()) {
        LOG_PRINT(log_print::kWARN, "PublishJsonToTopic: Cannot publish, not connected.");
        return false;
    }
    if (!topic || strlen(topic) == 0) {
         LOG_PRINT(log_print::kERROR, "PublishJsonToTopic: Invalid topic (null or empty).");
         return false;
    }
     // Allow publishing non-objects if necessary, but log if it's not an object.
    if (!json_payload.IsObject()) {
         LOG_PRINT(log_print::kDEBUG1,"PublishJsonToTopic: Payload is not a JSON object (type: %d).", json_payload.GetType());
    }

    rapidjson::StringBuffer string_buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(string_buffer);
    json_payload.Accept(writer);

    const char* json_string = string_buffer.GetString();
    size_t json_len = string_buffer.GetSize();

    if (json_len == 0) {
         LOG_PRINT(log_print::kWARN,"PublishJsonToTopic: Serialized JSON payload is empty.");
         // Depending on requirements, maybe return true or false here. Let's allow sending empty payload.
    }

    LOG_PRINT(log_print::kVERBOSE, "Publishing to %s (QoS %d, Retain %d, Size %zu): %s",
              topic, qos, retain, json_len, json_string);

    // Publish using the underlying client
    return aws_mqtt_client_.Publish(topic, reinterpret_cast<const uint8_t*>(json_string), json_len, qos, retain);
}

void CloudComm::RequestShadowState() {
     if (!IsConnected()) {
         LOG_PRINT(log_print::kWARN,"RequestShadowState: Cannot request, not connected.");
         return;
     }
    LOG_PRINT(log_print::kINFO, "Requesting current shadow state ($aws/things/%s/shadow/get)...", thing_name_);
    if (!aws_mqtt_client_.GetShadow("")) { // Empty client token for now
        LOG_PRINT(log_print::kERROR, "Failed to publish shadow get request via MQTT client.");
    } else {
         LOG_PRINT(log_print::kDEBUG1,"Shadow get request published.");
    }
}

void CloudComm::ProcessReceivedShadowDelta(const rapidjson::Value& delta_state) {
    // This function prepares the report payload but DOES NOT send it.
    // It's only called by HandleShadowCallback if a report is NOT already pending.

    if (!control_command_callback_) {
        LOG_PRINT(log_print::kDEBUG1,
                  "ProcessReceivedShadowDelta: No control command callback registered. Ignoring delta.");
        return;
    }
    if (!delta_state.IsObject()) {
        LOG_PRINT(log_print::kERROR, "ProcessReceivedShadowDelta: Input delta_state must be a JSON object.");
        return;
    }

    LOG_PRINT(log_print::kINFO, "Processing desired state delta commands...");

    // Local document to accumulate the state keys/values that were successfully processed
    rapidjson::Document reported_state_update(rapidjson::kObjectType);
    auto& allocator = reported_state_update.GetAllocator();
    bool command_processed_successfully = false;

    for (auto itr = delta_state.MemberBegin(); itr != delta_state.MemberEnd(); ++itr) {
        const char* key_ptr = itr->name.GetString();
        const std::size_t key_len = itr->name.GetStringLength();
        const rapidjson::Value& params = itr->value; // This is the desired value for the key

        char current_key[kMaxCommandKeyLen];
        if (key_len >= sizeof(current_key)) {
            LOG_PRINT(log_print::kERROR, "Command key '%.*s...' too long (max %zu). Skipping.",
                     20, key_ptr, sizeof(current_key) - 1); // Print first 20 chars
            continue;
        }
        memcpy(current_key, key_ptr, key_len);
        current_key[key_len] = '\0';

        LOG_PRINT(log_print::kINFO, "Invoking callback for command: '%s'", current_key);
        bool success = control_command_callback_(current_key, params);

        if (success) {
            LOG_PRINT(log_print::kINFO, "Command '%s' processed successfully by application.", current_key);
            command_processed_successfully = true;

            // Add the key and its *desired* value to the reported state update.
            // We report back the state we were asked to achieve.
            // Deep copy the key and the params value using the allocator.
            reported_state_update.AddMember(
                rapidjson::Value(current_key, allocator).Move(), // Copy key
                rapidjson::Value(params, allocator).Move(),      // Deep copy desired value (params)
                allocator);
        } else {
            LOG_PRINT(log_print::kWARN, "Command '%s' processing failed per application callback.", current_key);
            // Do not add to reported_state_update if processing failed.
            // The delta will likely persist until the command succeeds or desired state changes.
        }
    } // End for loop iterating through delta members

    // After processing all commands in this delta:
    if (command_processed_successfully) {
         LOG_PRINT(log_print::kINFO,"Finished processing delta. Preparing shadow report payload.");

         // Construct the full shadow update payload: {"state":{"reported":{...}}}
         rapidjson::Document shadow_doc(rapidjson::kObjectType);
         auto& shadow_allocator = shadow_doc.GetAllocator();
         rapidjson::Value state_val(rapidjson::kObjectType);

         // Move the accumulated reported updates into the state object
         // Ensure reported_state_update is valid before moving
         if (reported_state_update.IsObject()) {
             state_val.AddMember("reported", reported_state_update.Move(), shadow_allocator);
         } else {
              // Should not happen if commands succeeded, but handle defensively
              state_val.AddMember("reported", rapidjson::Value(rapidjson::kObjectType).Move(), shadow_allocator);
              LOG_PRINT(log_print::kERROR,"Internal error: reported_state_update was not an object after processing commands.");
         }

         shadow_doc.AddMember("state", state_val, shadow_allocator);

         // Serialize the full document
         rapidjson::StringBuffer string_buffer;
         rapidjson::Writer<rapidjson::StringBuffer> writer(string_buffer);
         shadow_doc.Accept(writer);

         // Store payload and set flag under mutex protection
         {
              platform::mutex::LockGuard lock(pending_report_mutex_);
              pending_shadow_report_payload_ = string_buffer.GetString();
              shadow_report_pending_.store(true, std::memory_order_release); // Set flag *after* payload is ready
              LOG_PRINT(log_print::kDEBUG1,"Shadow report payload generated (%zu bytes) and flagged as pending.",
                        pending_shadow_report_payload_.length());
         }
    } else {
         LOG_PRINT(log_print::kINFO, "Finished processing delta. No commands succeeded, no report generated.");
    }
}

void CloudComm::ProcessReceivedShadowDocument(rapidjson::Document& doc) {
    // Processes a full shadow document (e.g., from /get/accepted)

     bool was_initial = !initial_shadow_received_;
     if (was_initial) {
         LOG_PRINT(log_print::kINFO, "Processing initial shadow document received.");
         initial_shadow_received_ = true; // Mark initial shadow as processed
         // Reset retry logic for get shadow as we received one response
         get_shadow_attempts_ = 0;
         last_get_shadow_attempt_ms_ = 0;
         current_get_shadow_backoff_ms_ = kGetShadowRetryBaseMs;
     } else {
         LOG_PRINT(log_print::kINFO, "Processing updated shadow document received (e.g., /update/accepted).");
     }


    if (doc.HasMember("state") && doc["state"].IsObject()) {
        const auto& state_obj = doc["state"];

        // Process the 'desired' section if it exists to synchronize state
        if (state_obj.HasMember("desired") && state_obj["desired"].IsObject()) {
            LOG_PRINT(log_print::kINFO, "Processing 'desired' state from received document.");

            // According to our agreed logic, we should check the pending flag here too.
            // If a report is pending, we drop processing this 'desired' state, relying
            // on the shadow service to re-issue a delta later if needed after the pending
            // report is sent.
            if (shadow_report_pending_.load(std::memory_order_acquire)) {
                 LOG_PRINT(log_print::kWARN, "Processing 'desired' state from full document skipped: report already pending.");
            } else {
                // No report pending, process this desired state.
                ProcessReceivedShadowDelta(state_obj["desired"]); // This will trigger callbacks & potentially set flag/payload
            }

        } else {
            LOG_PRINT(log_print::kDEBUG1, "Received shadow document has no 'desired' state or it's not an object.");
            // If this was the initial shadow GET response and desired is empty, we are in sync initially.
        }

        // Optional: Process 'reported' section if needed by the application?
        // Generally, the application knows its own reported state.
        // if (state_obj.HasMember("reported") && state_obj["reported"].IsObject()) {
        //     LOG_PRINT(log_print::kDEBUG1, "Received document contains 'reported' state.");
        // }

    } else {
        LOG_PRINT(log_print::kWARN, "Received shadow document missing 'state' object.");
    }
}

void CloudComm::HandleShadowCallback(const std::string& update_type, std::string_view payload) {
    LOG_PRINT(log_print::kDEBUG1, "HandleShadowCallback: Type='%s', Size=%zu",
              update_type.c_str(), payload.length());

    // --- Handle Delta Updates ---
    if (update_type == "delta") {
        // **** CONDITIONAL PROCESSING LOGIC ****
        if (shadow_report_pending_.load(std::memory_order_acquire)) {
            LOG_PRINT(log_print::kWARN, "HandleShadowCallback: Delta received but report is already pending. Ignoring/dropping this delta.");
            return; // Ignore this delta - IMPORTANT PART OF THE AGREED LOGIC
        }
        // **** END CONDITIONAL PROCESSING LOGIC ****

        // Report not pending, proceed to parse and process this delta
        if (payload.empty()) {
             LOG_PRINT(log_print::kWARN,"HandleShadowCallback: Received empty delta payload.");
             return;
        }
        if (payload.length() >= sizeof(json_parse_buffer_)) {
            LOG_PRINT(log_print::kERROR, "HandleShadowCallback: Delta payload too large (%zu bytes, max %zu).",
                     payload.length(), sizeof(json_parse_buffer_)-1);
            return;
        }
        // Copy payload to mutable buffer for in-situ parsing
        memcpy(json_parse_buffer_, payload.data(), payload.length());
        json_parse_buffer_[payload.length()] = '\0'; // Null terminate

        rapidjson::Document doc;
        doc.ParseInsitu(json_parse_buffer_); // Use Insitu as buffer is prepared

        if (doc.HasParseError()) {
            LOG_PRINT(log_print::kERROR, "HandleShadowCallback: Delta JSON parse error: %s (offset %zu).",
                      rapidjson::GetParseError_En(doc.GetParseError()), doc.GetErrorOffset());
            return;
        }

        // The delta payload usually contains {"version": N, "timestamp": T, "state": {...delta_content...}}
        if (doc.HasMember("state") && doc["state"].IsObject()) {
             LOG_PRINT(log_print::kDEBUG1, "HandleShadowCallback: Processing delta state...");
             ProcessReceivedShadowDelta(doc["state"]); // Pass the actual delta state object
        } else {
             LOG_PRINT(log_print::kWARN, "HandleShadowCallback: Delta payload missing 'state' object or it's not an object.");
        }

    // --- Handle Get/Accepted Responses ---
    } else if (update_type == "accepted") {
        // This handles responses for both /get/accepted and /update/accepted
        if (payload.empty()) {
             LOG_PRINT(log_print::kWARN,"HandleShadowCallback: Received empty '/accepted' payload.");
             return;
        }
        if (payload.length() >= sizeof(json_parse_buffer_)) {
            LOG_PRINT(log_print::kERROR, "HandleShadowCallback: Accepted payload too large (%zu bytes, max %zu).",
                     payload.length(), sizeof(json_parse_buffer_)-1);
            return;
        }
        // Copy payload to mutable buffer
        memcpy(json_parse_buffer_, payload.data(), payload.length());
        json_parse_buffer_[payload.length()] = '\0';

        rapidjson::Document doc;
        doc.ParseInsitu(json_parse_buffer_);

        if (doc.HasParseError()) {
            LOG_PRINT(log_print::kERROR, "HandleShadowCallback: Accepted JSON parse error: %s (offset %zu).",
                      rapidjson::GetParseError_En(doc.GetParseError()), doc.GetErrorOffset());
            return;
        }

        LOG_PRINT(log_print::kINFO, "HandleShadowCallback: Processing '/accepted' document.");
        ProcessReceivedShadowDocument(doc); // Process the full document state

    // --- Handle Rejected Responses ---
    } else if (update_type == "rejected") {
        LOG_PRINT(log_print::kERROR, "HandleShadowCallback: Received shadow operation rejection.");
        // Parse payload for more details if possible/needed
         if (payload.length() < sizeof(json_parse_buffer_)) {
              memcpy(json_parse_buffer_, payload.data(), payload.length());
              json_parse_buffer_[payload.length()] = '\0';
              LOG_PRINT(log_print::kERROR, "Rejection payload: %s", json_parse_buffer_);
              // Example parsing:
              // rapidjson::Document doc;
              // doc.ParseInsitu(json_parse_buffer_);
              // if (!doc.HasParseError() && doc.HasMember("message")) {
              //    LOG_PRINT(log_print::kERROR, "Rejection message: %s", doc["message"].GetString());
              // }
         }
        // If an /update was rejected, clear the pending flag so the system can react to the next delta.
         {
             platform::mutex::LockGuard lock(pending_report_mutex_);
             if(shadow_report_pending_.load(std::memory_order_relaxed)) {
                 LOG_PRINT(log_print::kWARN,"Resetting pending report flag due to shadow operation rejection.");
                 pending_shadow_report_payload_.clear(); // Clear the rejected payload
                 shadow_report_pending_.store(false, std::memory_order_relaxed);
             }
         }

    } else {
        LOG_PRINT(log_print::kWARN, "HandleShadowCallback: Unhandled shadow callback type: %s", update_type.c_str());
    }
}

// --- Internal Callbacks ---

void CloudComm::OnConnected() {
    LOG_PRINT(log_print::kINFO, "MQTT client connection successful callback received!");
    State expected_state = State::CONNECTING;
    // Atomically transition from CONNECTING to CONNECTED
    if(current_state_.compare_exchange_strong(expected_state, State::CONNECTED)) {
         LOG_PRINT(log_print::kINFO, "State transitioned to CONNECTED.");

         // Reset backoff and retry counts on successful connection
         reconnect_attempts_ = 0;
         current_backoff_delay_ms_ = kInitialBackoffMs;
         last_disconnect_time_ms_ = 0; // Clear disconnect time

         // Reset initial shadow flag and retry logic, connection might have dropped before first shadow was received
         initial_shadow_received_ = false;
         get_shadow_attempts_ = 0;
         last_get_shadow_attempt_ms_ = 0;
         current_get_shadow_backoff_ms_ = kGetShadowRetryBaseMs;


         // Clear any potentially stale pending report from before connection drop
         {
             platform::mutex::LockGuard lock(pending_report_mutex_);
             shadow_report_pending_.store(false, std::memory_order_relaxed);
             pending_shadow_report_payload_.clear();
         }


         // Trigger application callback *after* internal state is consistent
         if (connection_status_callback_) {
              connection_status_callback_(true);
         }

         // PollShadow() in Process() will handle the initial Get request and retries.
         LOG_PRINT(log_print::kINFO,"Connection established. Initial shadow poll will start via Process() loop.");

    } else {
         // This could happen if Disconnect() was called while the client was connecting.
         LOG_PRINT(log_print::kWARN, "OnConnected callback received but state was not CONNECTING (current: %d). Might have been disconnected manually.", (int)expected_state);
         // If the current state is DISCONNECTED, ensure the underlying client is told to disconnect too, just in case.
         if(expected_state == State::DISCONNECTED) {
             aws_mqtt_client_.Disconnect();
         }
    }
}

void CloudComm::OnDisconnected() {
     // This is the callback from the underlying MQTT client when *it* detects disconnection.
     LOG_PRINT(log_print::kWARN, "MQTT client reported disconnection event via callback.");
     // Handle the state transition and backoff logic using the shared internal function
     HandleDisconnectInternal();
     // Note: The application callback (connection_status_callback_(false)) is called inside HandleDisconnectInternal if state changes.
}


// --- Placeholder Implementation ---
// Ensure this function is properly implemented based on your specific packet structures
bool CreateStatusPacketJSON(rapidjson::Document& doc, rapidjson::Document::AllocatorType& allocator, uint8_t packet_type, const void* packet_data) {
     // Implementation depends heavily on your packet structure definitions.
     // Example:
     doc.AddMember("packetType", packet_type, allocator);
     doc.AddMember("timestamp", system_uptime::GetMs(), allocator); // Add timestamp

     // Example: Cast packet_data based on packet_type and add members
     // if (packet_type == PACKET_TYPE_MOTION_SENSOR_DATA) {
     //     const MotionData* motion = static_cast<const MotionData*>(packet_data);
     //     doc.AddMember("motionDetected", motion->detected, allocator);
     //     doc.AddMember("axisX", motion->x, allocator);
     // } else if (...) {
     //     ...
     // }

     if (!packet_data) {
         // Handle cases where packet_data might be null if just sending type/timestamp
         LOG_PRINT(log_print::kDEBUG2, "CreateStatusPacketJSON called with null data for type %u", packet_type);
     }

     // Return true on success, false on failure (e.g., unknown type, bad data)
     LOG_PRINT(log_print::kDEBUG3, "Placeholder CreateStatusPacketJSON executed for type %u", packet_type);
     return true; // Placeholder success
}


} // namespace visium

-------------------------------------------------------------------------------------------
#ifndef CLOUD_COMM_H_
#define CLOUD_COMM_H_

#include <atomic>       // Required for std::atomic
#include <cstddef>      // For size_t
#include <cstdint>      // For uint types
#include <functional>   // For std::function
#include <string>       // Required for std::string
#include <string_view>  // For std::string_view

// --- Assumed Platform Includes ---
#include "platform/mutex.h"
#include "platform/storage/file_system.h"
#include "platform/network/aws_iot_mqtt_client.h"
// --- End Assumed Platform Includes ---

// --- Assumed Project Includes ---
#include "backlog_packets.h"
#include "rapidjson/document.h"
// --- End Assumed Project Includes ---


namespace visium {

// --- Type Definitions ---
using ControlCommandCallback = std::function<bool(const char* command_key, const rapidjson::Value& params)>;
using ConnectionStatusCallback = std::function<void(bool connected)>;


// --- CloudComm Class ---
class CloudComm {
   public:
    explicit CloudComm(platform::storage::FileSystem& file_manager);
    ~CloudComm();

    // Disable copy/move
    CloudComm(const CloudComm&) = delete; CloudComm& operator=(const CloudComm&) = delete;
    CloudComm(CloudComm&&) = delete; CloudComm& operator=(CloudComm&&) = delete;

    bool Initialize();
    bool Connect(bool reset_retry_state = true);
    void Disconnect();
    bool IsConnected() const;
    void Process();
    bool SendDataToCloud(uint8_t packet_type, const void* packet_data, size_t packet_size);
    bool SendLogEvent();
    bool ReportCurrentState(const rapidjson::Value& reported_state, int qos = 1);

    // --- Callback Setters ---
    void SetControlCommandCallback(ControlCommandCallback callback);
    void SetConnectionStatusCallback(ConnectionStatusCallback callback);

   private:
    platform::storage::FileSystem& file_manager_;

    // --- Internal State Machine ---
    enum class State { UNINITIALIZED, DISCONNECTED, CONNECTING, CONNECTED, WAITING_TO_RETRY };
    std::atomic<State> current_state_{State::UNINITIALIZED};

    // --- MQTT Client ---
    platform::network::AwsIotMqttClient aws_mqtt_client_;

    // --- Configuration & Topics ---
    char thing_name_[kMaxThingNameLen] = {0}; char staging_env_[10] = {0}; char mqtt_endpoint_[kMaxMqttEndPointLen] = {0};
    char logger_topic_[kMaxTopicLen] = {0}; char status_topic_[kMaxTopicLen] = {0}; char timeseries_topic_[kMaxTopicLen] = {0};
    const char* root_ca_path_ = "/certCA.pem"; const char* device_cert_path_ = "/certificate.pem";
    const char* private_key_path_ = "/private.pem.key"; const char* mqtt_config_path_ = "/mqttConfiguration.json";

    // --- Callbacks ---
    ControlCommandCallback control_command_callback_{nullptr}; ConnectionStatusCallback connection_status_callback_{nullptr};

    // --- Buffers ---
    char json_parse_buffer_[kMaxPayloadSize] = {0}; DataBuffer backlog_packets_;

    // --- Reconnect Logic ---
    uint64_t last_disconnect_time_ms_ = 0; uint32_t current_backoff_delay_ms_ = kInitialBackoffMs; int reconnect_attempts_ = 0;
    uint64_t connect_start_time_ms_ = 0; // For CONNECTING timeout (NEW)

    // --- Shadow Handling ---
    bool initial_shadow_received_ = false; uint16_t get_shadow_attempts_ = 0; uint64_t last_get_shadow_attempt_ms_ = 0;
    uint32_t current_get_shadow_backoff_ms_ = kGetShadowRetryBaseMs; uint32_t last_processed_shadow_version_ = 0;

    // --- Pending Shadow Report State ---
    std::atomic<bool> shadow_report_pending_{false}; std::string pending_shadow_report_payload_; platform::mutex::Mutex pending_report_mutex_;

    // --- Timers / Intervals ---
    uint64_t last_log_event_send_check_time_ = 0; uint64_t last_backlog_packet_sent_time_ = 0;

    // --- Constants ---
    static constexpr uint16_t kDefaultMqttPort = 8883; static constexpr int kDefaultMqttRxBufferSize = 2048; static constexpr int kDefaultMqttTxBufferSize = 2048;
    static constexpr std::size_t kMaxPayloadSize = 2048; static constexpr size_t kMaxTopicLen = 128; static constexpr size_t kMaxCommandKeyLen = 64;
    static constexpr size_t kMaxThingNameLen = 64; static constexpr size_t kMaxMqttEndPointLen = 128; static constexpr size_t kMaxFilePathLen = 128;
    static constexpr uint32_t kInitialBackoffMs = 1000; static constexpr uint32_t kMaxBackoffMs = 60000;
    static constexpr uint16_t kMaxGetShadowAttempts = 10; static constexpr uint32_t kGetShadowRetryBaseMs = 5000; static constexpr uint32_t kMaxGetShadowRetryMs = 30000;
    static constexpr uint32_t kLogEventSendIntervalMs = 10000;
    static constexpr uint32_t kConnectTimeoutMs = 30000; // Timeout for CONNECTING state (NEW)

    // --- Private Helper Methods ---
    bool AttemptReconnect(); bool CommonInitializeSetup(); void HandleDisconnectInternal(); void PollShadow();
    bool LoadCertificateFromFile(const char* full_path, char* buffer, std::size_t buffer_size); bool LoadMqttConfigs();
    bool PublishJsonToTopic(const char* topic, const rapidjson::Value& json_payload, int qos = 1, bool retain = false);
    void RequestShadowState(); void ProcessReceivedShadowDelta(const rapidjson::Value& delta_state); void ProcessReceivedShadowDocument(rapidjson::Document& doc);

    // --- Internal Callbacks ---
    void OnConnected(); void OnDisconnected(); void HandleShadowCallback(const std::string& update_type, std::string_view payload);

}; // class CloudComm
} // namespace visium
#endif // CLOUD_COMM_H_
--------------------------------------------------------
#include "cloud_communication.h" // Include the header first

#include <algorithm>
#include <cstdio>
#include <cstring>
// Includes via header: <atomic>, <string>, <functional>, <string_view>, <cstddef>, <cstdint>, <platform/mutex.h>, <platform/storage/file_system.h>, <platform/network/aws_iot_mqtt_client.h>, <rapidjson/document.h>

// --- Assumed Project Includes ---
#include "log_print.h" #include "log_transfer.h" #include "status_packet.h" #include "system_uptime.h" #include "version.h"
// --- End Assumed Project Includes ---

#include "rapidjson/error/en.h" #include "rapidjson/stringbuffer.h" #include "rapidjson/writer.h"

namespace visium {

using namespace platform;
// --- Forward declare helper ---
bool CreateStatusPacketJSON(rapidjson::Document& doc, rapidjson::Document::AllocatorType& allocator, uint8_t packet_type, const void* packet_data);

// --- Constructor/Destructor/Initialize/Connect/Disconnect/IsConnected (Unchanged from previous version) ---
CloudComm::CloudComm(platform::storage::FileSystem& file_manager): file_manager_(file_manager), current_state_(State::UNINITIALIZED), last_processed_shadow_version_{0}, shadow_report_pending_{false} { /* memset etc. */ memset(thing_name_,0,sizeof(thing_name_)); memset(json_parse_buffer_,0,sizeof(json_parse_buffer_)); }
CloudComm::~CloudComm() { State current = current_state_.load(); if (current != State::UNINITIALIZED && current != State::DISCONNECTED) { Disconnect(); } }
bool CloudComm::Initialize() { /* Unchanged - resets version */ if (current_state_.load() != State::UNINITIALIZED) { return true; } last_processed_shadow_version_ = 0; if (!LoadMqttConfigs()) { return false; } /* ... rest ... */ current_state_.store(State::DISCONNECTED); /* ... reset timers/flags ... */ return true; }
bool CloudComm::Connect(bool reset_retry_state) { /* Unchanged */ State c = current_state_.load(); if (c == State::UNINITIALIZED) return false; if (c == State::CONNECTING || c == State::CONNECTED) { if(reset_retry_state){/*reset*/} return true;} if(reset_retry_state){/*reset*/} return AttemptReconnect(); }
void CloudComm::Disconnect() { /* Unchanged - resets version */ State ps = current_state_.exchange(State::DISCONNECTED); if (ps != State::UNINITIALIZED && ps != State::DISCONNECTED) { aws_mqtt_client_.Disconnect(); } /* reset timers/flags/version */ last_processed_shadow_version_ = 0; /* clear pending report */ }
bool CloudComm::IsConnected() const { return (current_state_.load() == State::CONNECTED); }

// --- Process() **UPDATED** ---
void CloudComm::Process() {
    State state = current_state_.load();

    switch (state) {
        case State::DISCONNECTED: {
            LOG_PRINT(log_print::kINFO, "Process: State is DISCONNECTED. Attempting initial connection...");
            if (!AttemptReconnect()) {
                 // Attempt failed, likely because state changed concurrently or client refused immediately.
                 // HandleDisconnectInternal was likely called inside AttemptReconnect if client failed.
                 // If state check failed, we need to wait. Force into WAITING state.
                 LOG_PRINT(log_print::kWARN,"Process: AttemptReconnect from DISCONNECTED failed. Entering backoff.");
                 HandleDisconnectInternal(); // Force state to WAITING_TO_RETRY and apply initial backoff
            }
            // If successful, state is now CONNECTING
            break;
        }
        case State::WAITING_TO_RETRY: {
            if (system_uptime::ExceedsMs(last_disconnect_time_ms_, current_backoff_delay_ms_)) {
                LOG_PRINT(log_print::kINFO, "Process: Reconnect timer elapsed. Attempting reconnect...");
                if (!AttemptReconnect()) {
                    // Attempt failed after timer expired. State might have changed, or client failed.
                    // HandleDisconnectInternal was likely called inside AttemptReconnect if client failed.
                    // If state check failed, force into WAITING state again to reset timer with *next* backoff.
                    LOG_PRINT(log_print::kWARN,"Process: AttemptReconnect from WAITING_TO_RETRY failed. Re-entering backoff.");
                    HandleDisconnectInternal(); // Re-apply backoff logic (will increase delay)
                 }
                 // If successful, state is now CONNECTING
            } else {
                 LOG_PRINT(log_print::kDEBUG4,"Process: State is WAITING_TO_RETRY. Timer not expired.");
            }
            break;
        }
        case State::CONNECTED: {
             LOG_PRINT(log_print::kDEBUG4,"Process: State is CONNECTED.");
             // Check pending shadow report (Unchanged)
            if (shadow_report_pending_.load(std::memory_order_acquire)) {
                std::string payload_to_send; bool report_was_pending = false;
                { platform::mutex::LockGuard lock(pending_report_mutex_);
                    if (shadow_report_pending_.load(std::memory_order_relaxed)) {
                         payload_to_send = std::move(pending_shadow_report_payload_);
                         pending_shadow_report_payload_.clear();
                         shadow_report_pending_.store(false, std::memory_order_relaxed);
                         report_was_pending = true; } }
                if (report_was_pending && !payload_to_send.empty()) {
                     if (!aws_mqtt_client_.UpdateShadow(std::string_view(payload_to_send))) { /* Log Error */ }
                     else { /* Log Success */ } }
            }
            PollShadow(); // Poll for initial shadow (Unchanged)
            // SendLogEvent(); // Send logs if needed (Unchanged)
            break;
        }
        case State::CONNECTING: {
             LOG_PRINT(log_print::kDEBUG3, "Process: State is CONNECTING. Checking timeout...");
             // --- Check for CONNECTING timeout --- NEW ---
             if (system_uptime::ExceedsMs(connect_start_time_ms_, kConnectTimeoutMs)) {
                  LOG_PRINT(log_print::kERROR, "Process: CONNECTING state timed out after %u ms!", kConnectTimeoutMs);
                  // Force disconnect and enter backoff period
                  aws_mqtt_client_.Disconnect(); // Tell client to stop trying (if possible)
                  HandleDisconnectInternal(); // Transition to WAITING_TO_RETRY
             }
             // --- End Timeout Check ---
             break;
        }
        case State::UNINITIALIZED: default: {
             LOG_PRINT(log_print::kDEBUG4,"Process: State is UNINITIALIZED or unknown (%d).", (int)state);
            break;
        }
    } // End switch(state)

    aws_mqtt_client_.Yield(); // Process underlying client events
}


// --- AttemptReconnect **UPDATED** (Refined logic + sets connect_start_time_ms_) ---
bool CloudComm::AttemptReconnect() {
    LOG_PRINT(log_print::kINFO, "Attempting MQTT connection (Attempt #%d)...",
              reconnect_attempts_ + 1);

    // Read the current state first
    State current_state_val = current_state_.load(std::memory_order_relaxed);
    bool transitioned_to_connecting = false;

    // Check the state BEFORE trying CAS
    if (current_state_val == State::WAITING_TO_RETRY) {
        if (current_state_.compare_exchange_strong(current_state_val, State::CONNECTING, std::memory_order_acq_rel)) {
             LOG_PRINT(log_print::kDEBUG1, "State changed WAITING_TO_RETRY -> CONNECTING.");
             transitioned_to_connecting = true;
        } else {
             LOG_PRINT(log_print::kWARN, "AttemptReconnect CAS failed: State changed from WAITING_TO_RETRY to %d concurrently.", static_cast<int>(current_state_val));
             return false; // State changed before we could transition
        }
    } else if (current_state_val == State::DISCONNECTED) {
         if (current_state_.compare_exchange_strong(current_state_val, State::CONNECTING, std::memory_order_acq_rel)) {
              LOG_PRINT(log_print::kDEBUG1, "State changed DISCONNECTED -> CONNECTING.");
              transitioned_to_connecting = true;
         } else {
              LOG_PRINT(log_print::kWARN, "AttemptReconnect CAS failed: State changed from DISCONNECTED to %d concurrently.", static_cast<int>(current_state_val));
              return false; // State changed before we could transition
         }
    } else {
         // State was NEITHER WAITING NOR DISCONNECTED when initially checked.
         LOG_PRINT(log_print::kWARN, "AttemptReconnect failed: State was already %d (expected WAITING or DISCONNECTED).", static_cast<int>(current_state_val));
         return false;
    }

    // --- If we reach here, state was successfully transitioned to CONNECTING ---
    if (transitioned_to_connecting) {
         connect_start_time_ms_ = system_uptime::GetMs(); // Record start time for timeout (NEW)
         reconnect_attempts_++; // Increment attempt count only when starting client.Connect

         if (!aws_mqtt_client_.Connect()) { // Try to initiate the actual connection
             LOG_PRINT(log_print::kWARN, "Underlying aws_mqtt_client_.Connect() call failed initiation immediately.");
             // Connection attempt failed immediately, trigger disconnect logic which moves to WAITING_TO_RETRY
             // Don't increment reconnect_attempts_ again here, it was done above.
             HandleDisconnectInternal();
             return false; // Indicate immediate failure
         }

         LOG_PRINT(log_print::kDEBUG1, "MQTT connection attempt initiated via client (Attempt #%d). Waiting for callback.", reconnect_attempts_);
         return true; // Indicate connection attempt was started
    } else {
         // Should be unreachable due to checks above, but defensive return
         return false;
    }
}

// --- Other Methods (Unchanged from previous version) ---
// SendDataToCloud(), SendLogEvent(), ReportCurrentState()
bool CloudComm::SendDataToCloud(uint8_t pt, const void* pd, size_t ps) { /* Unchanged */ if(pt>=TOTAL_STATUS_PACKET_TYPES)return false; if(!pd||ps==0)return false; if(IsConnected()){ rapidjson::Document d;auto& a=d.GetAllocator();d.SetObject(); if(!CreateStatusPacketJSON(d,a,pt,pd))return false; const char* t=(pt==PACKET_TYPE_ENV_SENSOR_DATA)?timeseries_topic_:status_topic_; bool s=PublishJsonToTopic(t,d); if(s){last_backlog_packet_sent_time_=system_uptime::GetMs();if(pt!=PACKET_TYPE_ENV_SENSOR_DATA)backlog_packets_.AddStatusData(pt,nullptr,0);} return s;} else {if(pt==PACKET_TYPE_ENV_SENSOR_DATA)return backlog_packets_.AddData(pt,(const uint8_t*)pd,ps); else return backlog_packets_.AddStatusData(pt,(const uint8_t*)pd,ps);} }
bool CloudComm::SendLogEvent() { /* Unchanged */ if(!IsConnected())return false; if(system_uptime::ExceedsMs(last_log_event_send_check_time_,kLogEventSendIntervalMs)){ last_log_event_send_check_time_=system_uptime::GetMs(); uint8_t b[128];uint32_t ec=0;uint64_t ts=0; if(log_transfer::GetLogEvent(&ec,&ts)){size_t sz=log_transfer::CreateLogEvent(ec,ts,b,sizeof(b));if(sz>0&&sz<sizeof(b)){if(aws_mqtt_client_.Publish(logger_topic_,b,sz))return true;else return false;}else return false;}else return false;}return false;}
bool CloudComm::ReportCurrentState(const rapidjson::Value& rs, int q) { /* Unchanged */ if(!IsConnected())return false; if(!rs.IsObject())return false; rapidjson::Document sd;auto& al=sd.GetAllocator();sd.SetObject(); rapidjson::Value sv(rapidjson::kObjectType);sv.AddMember("reported", rapidjson::Value(rs, al).Move(), al); sd.AddMember("state",sv,al); rapidjson::StringBuffer sb;rapidjson::Writer<rapidjson::StringBuffer> wr(sb);sd.Accept(wr); return aws_mqtt_client_.UpdateShadow(std::string_view(sb.GetString(),sb.GetSize()), q); }
// SetControlCommandCallback(), SetConnectionStatusCallback()
void CloudComm::SetControlCommandCallback(ControlCommandCallback cb) { /* Unchanged */ control_command_callback_=std::move(cb); }
void CloudComm::SetConnectionStatusCallback(ConnectionStatusCallback cb) { /* Unchanged */ connection_status_callback_=std::move(cb); }
// CommonInitializeSetup(), HandleDisconnectInternal(), PollShadow()
bool CloudComm::CommonInitializeSetup() { /* Unchanged */ aws_mqtt_client_.SetOnConnectedCallback([this](){this->OnConnected();}); aws_mqtt_client_.SetOnDisconnectedCallback([this](){this->OnDisconnected();}); auto sh=[this](const std::string& t,std::string_view p){this->HandleShadowCallback(t,p);}; if(!aws_mqtt_client_.SubscribeToShadowUpdates(sh))return false; if(!aws_mqtt_client_.SubscribeToShadowGetResponses(sh))return false; return true; }
void CloudComm::HandleDisconnectInternal() { /* Unchanged */ State ps = current_state_.load(); if(ps==State::CONNECTED||ps==State::CONNECTING){ last_disconnect_time_ms_=system_uptime::GetMs(); if(ps==State::CONNECTED){uint64_t nd=(uint64_t)current_backoff_delay_ms_*2;current_backoff_delay_ms_=std::min((uint32_t)nd,kMaxBackoffMs);}else{current_backoff_delay_ms_=kInitialBackoffMs;} State es=ps; if(current_state_.compare_exchange_strong(es, State::WAITING_TO_RETRY)){ {platform::mutex::LockGuard lock(pending_report_mutex_);shadow_report_pending_.store(false);pending_shadow_report_payload_.clear();} initial_shadow_received_=false; get_shadow_attempts_=0; last_get_shadow_attempt_ms_=0; current_get_shadow_backoff_ms_=kGetShadowRetryBaseMs; last_processed_shadow_version_=0; if(connection_status_callback_)connection_status_callback_(false);} }}
void CloudComm::PollShadow() { /* Unchanged */ if(initial_shadow_received_||current_state_.load()!=State::CONNECTED)return; if(system_uptime::ExceedsMs(last_get_shadow_attempt_ms_,current_get_shadow_backoff_ms_)){ if(get_shadow_attempts_>=kMaxGetShadowAttempts){initial_shadow_received_=true;return;} RequestShadowState(); last_get_shadow_attempt_ms_=system_uptime::GetMs(); get_shadow_attempts_++; current_get_shadow_backoff_ms_=std::min(current_get_shadow_backoff_ms_+kGetShadowRetryBaseMs,kMaxGetShadowRetryMs);} }
// LoadCertificateFromFile(), LoadMqttConfigs(), PublishJsonToTopic(), RequestShadowState()
bool CloudComm::LoadCertificateFromFile(const char* fp, char* b, size_t bs) { /* Unchanged */ if(!fp||!b||bs==0)return false; memset(b,0,bs); size_t br=0; auto e=file_manager_.Read(fp,b,bs-1,&br); if(e==storage::FileSystem::ErrorCode::kOk){b[br]='\0';return true;}else{memset(b,0,bs);return false;} }
bool CloudComm::LoadMqttConfigs() { /* Unchanged */ char rb[512]; size_t br=0; auto e=file_manager_.Read(mqtt_config_path_,rb,sizeof(rb)-1,&br); if(e!=storage::FileSystem::ErrorCode::kOk)return false; rb[br]='\0'; rapidjson::Document mc;mc.Parse(rb); if(mc.HasParseError()||!mc.IsObject())return false; bool s=true; if(mc.HasMember("clientid")&&mc["clientid"].IsString()){strncpy(thing_name_,mc["clientid"].GetString(),sizeof(thing_name_)-1);}else{s=false;} if(mc.HasMember("env")&&mc["env"].IsString()){strncpy(staging_env_,mc["env"].GetString(),sizeof(staging_env_)-1);}else{s=false;} if(mc.HasMember("host")&&mc["host"].IsString()){strncpy(mqtt_endpoint_,mc["host"].GetString(),sizeof(mqtt_endpoint_)-1);}else{s=false;} snprintf(status_topic_,sizeof(status_topic_),"lit/%s/cloud/status/%s",staging_env_,VISIUM_FW_VERSION); snprintf(timeseries_topic_,sizeof(timeseries_topic_),"lit/%s/cloud/timeseries/%s",staging_env_,VISIUM_FW_VERSION); snprintf(logger_topic_,sizeof(logger_topic_),"lit/%s/cloud/logging/%s",staging_env_,thing_name_); return s; }
bool CloudComm::PublishJsonToTopic(const char* t, const rapidjson::Value& jp, int q, bool r) { /* Unchanged */ if(!IsConnected())return false; if(!t||strlen(t)==0)return false; rapidjson::StringBuffer sb; rapidjson::Writer<rapidjson::StringBuffer> wr(sb);jp.Accept(wr); return aws_mqtt_client_.Publish(t,(const uint8_t*)sb.GetString(),sb.GetSize(),q,r); }
void CloudComm::RequestShadowState() { /* Unchanged */ if(!IsConnected())return; if(!aws_mqtt_client_.GetShadow("")){/* Log error */} }
// ProcessReceivedShadowDelta(), ProcessReceivedShadowDocument()
void CloudComm::ProcessReceivedShadowDelta(const rapidjson::Value& ds) { /* Unchanged */ if(!control_command_callback_)return; if(!ds.IsObject())return; rapidjson::Document rsu(rapidjson::kObjectType); auto& al=rsu.GetAllocator(); bool cps=false; for(auto i=ds.MemberBegin();i!=ds.MemberEnd();++i){ const char* k=i->name.GetString(); const auto& p=i->value; char ck[kMaxCommandKeyLen]; size_t kl=i->name.GetStringLength(); if(kl>=sizeof(ck))continue; memcpy(ck,k,kl); ck[kl]='\0'; bool suc=control_command_callback_(ck,p); if(suc){cps=true;rsu.AddMember(rapidjson::Value(ck,al).Move(),rapidjson::Value(p,al).Move(),al);} } if(cps){ rapidjson::Document sd;auto& sa=sd.GetAllocator();sd.SetObject(); rapidjson::Value sv(rapidjson::kObjectType);if(rsu.IsObject())sv.AddMember("reported",rsu.Move(),sa);else sv.AddMember("reported",rapidjson::Value(rapidjson::kObjectType).Move(),sa); sd.AddMember("state",sv,sa); rapidjson::StringBuffer sb;rapidjson::Writer<rapidjson::StringBuffer> wr(sb);sd.Accept(wr); {platform::mutex::LockGuard lock(pending_report_mutex_); pending_shadow_report_payload_=sb.GetString(); shadow_report_pending_.store(true,std::memory_order_release);} } }
void CloudComm::ProcessReceivedShadowDocument(rapidjson::Document& doc) { /* Unchanged */ bool wi=!initial_shadow_received_;if(wi){initial_shadow_received_=true;get_shadow_attempts_=0;last_get_shadow_attempt_ms_=0;current_get_shadow_backoff_ms_=kGetShadowRetryBaseMs;} if(doc.HasMember("state")&&doc["state"].IsObject()){const auto& so=doc["state"]; if(so.HasMember("desired")&&so["desired"].IsObject()){if(shadow_report_pending_.load(std::memory_order_acquire)){/*skip*/}else{ProcessReceivedShadowDelta(so["desired"]);}}} }
// HandleShadowCallback()
void CloudComm::HandleShadowCallback(const std::string& ut, std::string_view pl) { /* Unchanged */ if(pl.empty()||pl.length()>=sizeof(json_parse_buffer_))return; memcpy(json_parse_buffer_,pl.data(),pl.length()); json_parse_buffer_[pl.length()]='\0'; rapidjson::Document d; d.ParseInsitu(json_parse_buffer_); if(d.HasParseError())return; uint32_t iv=0; if(d.HasMember("version")&&d["version"].IsUint()){iv=d["version"].GetUint();}else{return;} if(iv<=last_processed_shadow_version_)return; last_processed_shadow_version_=iv; if(ut=="delta"){if(shadow_report_pending_.load(std::memory_order_acquire))return; if(d.HasMember("state")&&d["state"].IsObject()){ProcessReceivedShadowDelta(d["state"]);}} else if(ut=="accepted"){ProcessReceivedShadowDocument(d);} else if(ut=="rejected"){ {platform::mutex::LockGuard lock(pending_report_mutex_);if(shadow_report_pending_.load(std::memory_order_relaxed)){pending_shadow_report_payload_.clear();shadow_report_pending_.store(false,std::memory_order_relaxed);}} } }
// OnConnected(), OnDisconnected()
void CloudComm::OnConnected() { /* Unchanged */ State es=State::CONNECTING; if(current_state_.compare_exchange_strong(es,State::CONNECTED)){ reconnect_attempts_=0;current_backoff_delay_ms_=kInitialBackoffMs;last_disconnect_time_ms_=0;initial_shadow_received_=false;get_shadow_attempts_=0;last_get_shadow_attempt_ms_=0;current_get_shadow_backoff_ms_=kGetShadowRetryBaseMs;last_processed_shadow_version_=0; {platform::mutex::LockGuard lock(pending_report_mutex_);shadow_report_pending_.store(false);pending_shadow_report_payload_.clear();} if(connection_status_callback_)connection_status_callback_(true);} }
void CloudComm::OnDisconnected() { /* Unchanged */ HandleDisconnectInternal(); }
// CreateStatusPacketJSON()
bool CreateStatusPacketJSON(rapidjson::Document& d, rapidjson::Document::AllocatorType& a, uint8_t pt, const void* pd) { /* Unchanged */ d.AddMember("packetType",pt,a);d.AddMember("timestamp",system_uptime::GetMs(),a);return true; }

} // namespace visium
