This document contains all the necessary files and code for the MTD Flash Tool. You can copy and paste the contents of each file into your development environment according to the specified folder structure.1. Project Folder StructureCreate the following directory layout for your project. The contents for each file are provided below.flash-tool/
├── bsp/
│   └── recipes-utils/
│       └── flash-tool/
│           └── flash-tool_0.1.bb
├── src/
│   ├── include/
│   │   ├── cli.h
│   │   ├── config.h
│   │   ├── flash_interface.h
│   │   ├── logger.h
│   │   └── utils.h
│   ├── backend/
│   │   ├── flash_libmtd.c
│   │   └── flash_ioctl.c
│   ├── cli.c
│   ├── main.c
│   ├── logger.c
│   └── utils.c
├── Makefile
└── README.txt
2. README.txtThis is the main documentation for the tool.================
Flash Tool v0.1
================

A command-line interface (CLI) utility for reading, writing, erasing, and
verifying MTD (Memory Technology Device) flash chips on embedded Linux systems
built with Yocto.

This tool provides two backends for interacting with the MTD subsystem:
1.  **libmtd**: Uses the high-level library from mtd-utils. (Default)
2.  **ioctl**: Uses direct low-level ioctl calls, similar to flash_erase, etc.

-----------------
Table of Contents
-----------------
1.  Features
2.  Build Instructions
3.  Command Reference
4.  Sample Usage

----------
1. Features
----------
-   **Dual Backends**: Select between `libmtd` and `ioctl` at compile time.
-   **Rich Command Set**: Supports write, read, erase (sector and chip), and write-verify operations.
-   **Flexible Patterns**: Write ascending (`+`), descending (`-`), or user-defined hex patterns.
-   **Robust Erase**: Auto-detects MTD erase size (`A` type) and handles block locking/unlocking (ioctl backend).
-   **Dual Logging**:
    -   **Functional Logs**: Always-on `printf` for direct user feedback.
    -   **Controlled Logs**: Verbose debug, info, warning, and error logs that can be enabled/disabled at compile time.
-   **Linux Kernel Coding Style**: Code is formatted for readability and maintainability.
-   **Doxygen Documentation**: Fully documented source code for developers.

--------------------
2. Build Instructions
--------------------

**Prerequisites:**
-   A Yocto build environment (Zeus/Warrior).
-   The `mtd-utils` package must be included in your image to provide `libmtd`.

**A. Compiling Manually (on the target):**
1.  Copy the `flash-tool` directory to your target device.
2.  Navigate to the directory: `cd flash-tool`
3.  Build with the default `libmtd` backend:
    ```sh
    make
    ```
4.  Build with the `ioctl` backend:
    ```sh
    make CLEAN_FIRST=y BACKEND=IOCTL
    ```
5.  The executable `flash_tool` will be created in the root directory.

**B. Compiling with Yocto (Recommended):**
1.  Copy the `bsp/recipes-utils/flash-tool` directory into your Yocto layer.
2.  Add the recipe to your image by adding the following to your `local.conf` or image recipe:
    ```
    IMAGE_INSTALL_append = " flash-tool"
    ```
3.  To change the backend, you can modify the `.bb` file or use a `.bbappend`. The default is `libmtd`.
4.  Build your Yocto image. The `flash_tool` binary will be installed in `/usr/bin`.

-------------------
3. Command Reference
-------------------

**General Commands:**
-   `help`: Displays the help message.
-   `clr`: Clears the terminal screen.
-   `exit`: Exits the application.

**Write Command:**
`flash write <type> <pattern> <sector> <size>`
-   `<type>`: `P`, `Z`, `Y` (ignored, for compatibility).
-   `<pattern>`: `+` (ascending), `-` (descending), or a hex value (e.g., `0xAA`).
-   `<sector>`: The MTD erase block number to start writing to.
-   `<size>`: Number of bytes to write. Max is the MTD erase block size.

**Read Command:**
`flash read <type> <sector> <size>`
-   `<type>`: `Z`, `Y`, `O`, etc. (ignored).
-   `<sector>`: The MTD erase block number to read from.
-   `<size>`: Number of bytes to read.

**Write-Verify Command:**
`flash write-verify <type> <sector> <iter> <fail_cnt> <log> <full_util>`
-   (Note: This command is a complex stub and prints a message.)

**Erase Command:**
`flash erase <type> <start_sector> [end_sector]`
-   `<type>`:
    -   `A`: Auto-detect and use the device's native erase block size.
    -   `O`: Assumes 128KiB sectors for addressing.
    -   `Y`: Assumes 32KiB sectors for addressing.
    -   `Z`: Assumes 4KiB sectors for addressing.
    -   `C`: Chip Erase. Erases the entire device. No sector args needed.
-   `<start_sector>`: The first sector to erase (based on the `<type>` size).
-   `[end_sector]`: Optional. If omitted, only `start_sector` is erased.

---------------
4. Sample Usage
---------------

./flash_toolFlash Tool Initializing...[INFO]  libmtd backend selected.MTD device '/dev/mtd0' opened. Size: 32 MB, Erase size: 64 KBInitialization complete. Type 'help' for commands.flash erase A 10Auto-detected erase size: 65536 bytes.Erasing 1 block(s) from offset 0x000a0000...Erase successful.flash write P + 10 256Preparing to write 256 bytes to sector 10 (offset 0x000a0000).Write successful.flash read Y 10 64Reading 64 bytes from sector 10 (offset 0x000a0000).Read successful. Hexdump:0x00000000: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  |................|0x00000010: 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F  |................|0x00000020: 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F  | !"#$%&'()*+,-./|0x00000030: 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F  |0123456789:;<=>?|flash erase CPerforming CHIP ERASE on MTD device. This will erase the ENTIRE flash.Are you sure? (y/N): yErasing entire device (33554432 bytes)...Chip erase successful.exitExiting. Cleaning up...MTD device closed.
---

### 3. Makefile

```makefile
#
# Makefile for the MTD Flash Tool
#

# Compiler and core flags
CC ?= $(CROSS_COMPILE)gcc
CFLAGS := -Wall -Wextra -std=c99 -I$(CURDIR)/src/include -g

# Target executable
TARGET := flash_tool

# Source files
SRCS := $(wildcard src/*.c) $(wildcard src/backend/*.c)
OBJS := $(patsubst src/%.c,obj/%.o,$(SRCS))

# Default backend is libmtd
BACKEND ?= LIBMDT

# Add backend-specific flags and libraries
ifeq ($(BACKEND),LIBMDT)
	CFLAGS += -DUSE_LIBMTD_BACKEND
	LDFLAGS += -lmtd
	# Exclude the ioctl backend from the build
	SRCS := $(filter-out src/backend/flash_ioctl.c, $(SRCS))
else ifeq ($(BACKEND),IOCTL)
	CFLAGS += -DUSE_IOCTL_BACKEND
	# Exclude the libmtd backend from the build
	SRCS := $(filter-out src/backend/flash_libmtd.c, $(SRCS))
else
	$(error "Invalid BACKEND specified. Use LIBMDT or IOCTL.")
endif

# Re-calculate objects based on filtered sources
OBJS := $(patsubst src/%.c,obj/%.o,$(SRCS))

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(OBJS)
	@echo "  LD      $@"
	@$(CC) $(OBJS) -o $@ $(LDFLAGS)

obj/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "  CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Allow cleaning before a build, e.g., 'make CLEAN_FIRST=y'
ifeq ($(CLEAN_FIRST),y)
all: clean $(TARGET)
endif

clean:
	@echo "  CLEAN"
	@rm -rf $(TARGET) obj/
4. Yocto Recipe (bsp/recipes-utils/flash-tool/flash-tool_0.1.bb)SUMMARY = "Command-line utility for MTD flash operations"
DESCRIPTION = "A tool to read, write, and erase MTD flash devices, \
with support for both libmtd and direct ioctl backends."
LICENSE = "GPL-2.0-only"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/GPL-2.0-only;md5=801f80980d17102532565de542a6cc66"

# This recipe assumes the source code is placed next to it in a 'flash-tool' subdir
SRC_URI = "file://flash-tool/"

S = "${WORKDIR}/flash-tool"

# The tool depends on mtd-utils for the libmtd library
DEPENDS = "mtd-utils"

# By default, the Makefile builds with the LIBMDT backend.
# To build with the ioctl backend, uncomment the following line in a .bbappend:
# EXTRA_OEMAKE += "BACKEND=IOCTL"

do_compile() {
	oe_runmake
}

do_install() {
	install -d ${D}${bindir}
	install -m 0755 ${S}/flash_tool ${D}${bindir}
}
5. Source Code Filessrc/include/config.h#ifndef CONFIG_H
#define CONFIG_H

#include "logger.h"

/**
 * @file config.h
 * @brief Central configuration file for the flash tool.
 */

/**
 * @def DEFAULT_MTD_DEVICE
 * @brief The default MTD character device to open if none is specified.
 */
#define DEFAULT_MTD_DEVICE      "/dev/mtd0"

/**
 * @def MAX_CLI_INPUT_SIZE
 * @brief Maximum number of characters for a single line of CLI input.
 */
#define MAX_CLI_INPUT_SIZE      1024

/**
 * @def MAX_CLI_ARGS
 * @brief Maximum number of arguments (tokens) in a single command.
 */
#define MAX_CLI_ARGS            16

/**
 * @def LOG_LEVEL
 * @brief Sets the compile-time log level for controlled logging.
 *
 * All log messages with a level equal to or higher than this will be printed.
 * To disable all controlled logs, set this to a value higher than
 * LOG_LEVEL_ERROR.
 *
 * Available levels:
 * - LOG_LEVEL_DEBUG
 * - LOG_LEVEL_INFO
 * - LOG_LEVEL_WARN
 * - LOG_LEVEL_ERROR
 */
#define LOG_LEVEL               LOG_LEVEL_INFO

#endif /* CONFIG_H */
src/include/logger.h#ifndef LOGGER_H
#define LOGGER_H

#include <stdio.h>

/**
 * @file logger.h
 * @brief A dual-mode logging utility.
 */

/**
 * @enum log_level_t
 * @brief Defines the severity levels for log messages.
 */
typedef enum {
	LOG_LEVEL_DEBUG,
	LOG_LEVEL_INFO,
	LOG_LEVEL_WARN,
	LOG_LEVEL_ERROR
} log_level_t;

/**
 * @def LOG
 * @brief The main macro for controlled logging.
 *
 * This macro checks the compile-time LOG_LEVEL from config.h before calling
 * the internal logging function. This ensures that disabled log messages
 * are completely compiled out, resulting in zero performance overhead.
 *
 * @param level The log_level_t of the message.
 * @param fmt The format string, like printf.
 * @param ... Variable arguments for the format string.
 */
#define LOG(level, fmt, ...) \
	do { \
		if (level >= LOG_LEVEL) { \
			logger_log(level, __FILE__, __LINE__, fmt, ##__VA_ARGS__); \
		} \
	} while (0)

/**
 * @brief Internal log function that formats and prints messages.
 *
 * This function should not be called directly. Use the LOG() macro instead.
 *
 * @param level The log level.
 * @param file The source file name where the log was generated.
 * @param line The line number in the source file.
 * @param fmt The format string.
 * @param ... Variable arguments.
 */
void logger_log(log_level_t level, const char *file, int line,
		const char *fmt, ...);

#endif /* LOGGER_H */
src/include/utils.h#ifndef UTILS_H
#define UTILS_H

#include <stdint.h>
#include <stddef.h>

/**
 * @file utils.h
 * @brief Declaration of various helper functions.
 */

/**
 * @brief Prints a block of memory in a classic hexdump format.
 *
 * @param prefix A string to print at the beginning of each line (can be NULL).
 * @param data Pointer to the data to dump.
 * @param size The number of bytes to dump.
 */
void hexdump(const char *prefix, const void *data, size_t size);

/**
 * @brief Fills a buffer with a specified data pattern.
 *
 * @param buffer The buffer to fill.
 * @param size The size of the buffer.
 * @param pattern A string defining the pattern:
 * - "+": Ascending pattern (00, 01, 02, ...).
 * - "-": Descending pattern (FF, FE, FD, ...).
 * - "0x..": A specific hex value to fill the buffer with.
 * @return 0 on success, -1 on failure (e.g., invalid pattern).
 */
int generate_pattern(uint8_t *buffer, size_t size, const char *pattern);

/**
 * @brief Safely parses a string into a long integer.
 *
 * Supports decimal and hexadecimal (with "0x" prefix) formats.
 *
 * @param str The string to parse.
 * @param val Pointer to a long where the result will be stored.
 * @return 0 on success, -1 if the string contains invalid characters.
 */
int parse_number(const char *str, long *val);

#endif /* UTILS_H */
src/include/flash_interface.h#ifndef FLASH_INTERFACE_H
#define FLASH_INTERFACE_H

#include <stdint.h>
#include <stddef.h>
#include <mtd/mtd-user.h>

/**
 * @file flash_interface.h
 * @brief Defines the abstract interface for flash backend operations.
 */

/**
 * @struct flash_ops
 * @brief A structure of function pointers defining the backend API.
 *
 * This abstraction allows the main application logic to be independent of the
 * underlying MTD access method (libmtd vs. ioctl).
 */
typedef struct flash_ops {
	/**
	 * @brief Initializes the backend and opens the MTD device.
	 * @param device Path to the MTD device (e.g., "/dev/mtd0").
	 * @return 0 on success, -1 on failure.
	 */
	int (*init)(const char *device);

	/**
	 * @brief Closes the MTD device and cleans up resources.
	 */
	void (*deinit)(void);

	/**
	 * @brief Erases one or more erase blocks.
	 * @param offset The starting offset for the erase operation.
	 * @param len The total number of bytes to erase.
	 * @return 0 on success, -1 on failure.
	 */
	int (*erase)(uint32_t offset, uint32_t len);

	/**
	 * @brief Writes data to the flash device.
	 * @param offset The starting offset for the write operation.
	 * @param data Pointer to the data buffer to write.
	 * @param len The number of bytes to write.
	 * @return 0 on success, -1 on failure.
	 */
	int (*write)(uint32_t offset, const void *data, size_t len);

	/**
	 * @brief Reads data from the flash device.
	 * @param offset The starting offset for the read operation.
	 * @param data Pointer to the buffer to store the read data.
	 * @param len The number of bytes to read.
	 * @return 0 on success, -1 on failure.
	 */
	int (*read)(uint32_t offset, void *data, size_t len);

	/**
	 * @brief Retrieves information about the MTD device.
	 * @param info Pointer to a struct to be filled with device info.
	 * @return 0 on success, -1 on failure.
	 */
	int (*get_info)(struct mtd_info_user *info);

} flash_ops_t;

/**
 * @brief Global pointer to the active backend implementation.
 *
 * This pointer is initialized by backend_init() based on compile-time flags.
 */
extern const flash_ops_t *g_flash_backend;

/**
 * @brief Initializes the global g_flash_backend pointer.
 *
 * This function must be called once at application startup. It selects the
 * appropriate backend implementation based on defines from the Makefile
 * (USE_LIBMDT_BACKEND or USE_IOCTL_BACKEND).
 */
void backend_init(void);

#endif /* FLASH_INTERFACE_H */
src/include/cli.h#ifndef CLI_H
#define CLI_H

/**
 * @file cli.h
 * @brief Declarations for the command-line interface.
 */

/**
 * @brief Parses and executes a command received from the user.
 *
 * @param argc The number of arguments in the command.
 * @param argv An array of strings representing the command and its arguments.
 */
void cli_process_command(int argc, char *argv[]);

/**
 * @brief Prints the main help message to the console.
 */
void print_help(void);

#endif /* CLI_H */
src/logger.c#include <stdio.h>
#include <stdarg.h>
#include <time.h>
#include "include/logger.h"
#include "include/config.h"

/**
 * @file logger.c
 * @brief Implementation of the controlled logging system.
 */

/**
 * See logger.h for documentation.
 */
void logger_log(log_level_t level, const char *file, int line,
		const char *fmt, ...)
{
	/* This check is redundant if using the macro, but serves as a safeguard */
	if (level < LOG_LEVEL)
		return;

	switch (level) {
	case LOG_LEVEL_DEBUG:
		fprintf(stderr, "[DEBUG] ");
		break;
	case LOG_LEVEL_INFO:
		fprintf(stderr, "[INFO]  ");
		break;
	case LOG_LEVEL_WARN:
		fprintf(stderr, "[WARN]  ");
		break;
	case LOG_LEVEL_ERROR:
		fprintf(stderr, "[ERROR] (%s:%d): ", file, line);
		break;
	}

	va_list args;
	va_start(args, fmt);
	vfprintf(stderr, fmt, args);
	va_end(args);
	fprintf(stderr, "\n");
}
src/utils.c#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "include/utils.h"
#include "include/logger.h"

/**
 * @file utils.c
 * @brief Implementation of helper functions.
 */

/**
 * See utils.h for documentation.
 */
int parse_number(const char *str, long *val)
{
	char *endptr;

	if (!str || !val)
		return -1;

	*val = strtol(str, &endptr, 0);
	if (*endptr != '\0') {
		LOG(LOG_LEVEL_ERROR, "Invalid character in number: '%s'", str);
		return -1;
	}
	return 0;
}

/**
 * See utils.h for documentation.
 */
int generate_pattern(uint8_t *buffer, size_t size, const char *pattern)
{
	size_t i;
	long val;

	if (strcmp(pattern, "+") == 0) {
		LOG(LOG_LEVEL_DEBUG, "Generating ascending pattern");
		for (i = 0; i < size; i++)
			buffer[i] = i & 0xFF;
	} else if (strcmp(pattern, "-") == 0) {
		LOG(LOG_LEVEL_DEBUG, "Generating descending pattern");
		for (i = 0; i < size; i++)
			buffer[i] = 0xFF - (i & 0xFF);
	} else {
		LOG(LOG_LEVEL_DEBUG, "Generating user-defined hex pattern: %s",
		    pattern);
		if (parse_number(pattern, &val) != 0 || val < 0 || val > 0xFF) {
			LOG(LOG_LEVEL_ERROR,
			    "Invalid hex pattern '%s'. Must be 0x00-0xFF.",
			    pattern);
			return -1;
		}
		memset(buffer, (int)val, size);
	}
	return 0;
}

/**
 * See utils.h for documentation.
 */
void hexdump(const char *prefix, const void *data, size_t size)
{
	const unsigned char *p = data;
	size_t i, j;

	for (i = 0; i < size; i += 16) {
		if (prefix)
			printf("%s", prefix);

		printf("0x%08zX: ", i);
		for (j = 0; j < 16; j++) {
			if (i + j < size)
				printf("%02X ", p[i + j]);
			else
				printf("   ");
		}

		printf(" |");
		for (j = 0; j < 16; j++) {
			if (i + j < size)
				printf("%c", isprint(p[i + j]) ? p[i + j] : '.');
		}
		printf("|\n");
	}
}
src/backend/flash_libmtd.c#include <stdio.h>
#include <string.h>
#include <libmtd.h>
#include "../include/flash_interface.h"
#include "../include/logger.h"

/**
 * @file flash_libmtd.c
 * @brief MTD backend implementation using the libmtd library.
 */

/* Module-level static state for the libmtd backend */
static libmtd_t mtd_desc;
static struct mtd_info_user mtd_info;

/**
 * @brief Initializes the libmtd backend.
 * @see flash_interface.h
 */
static int mtd_backend_init(const char *device)
{
	if (mtd_desc) {
		LOG(LOG_LEVEL_WARN, "libmtd backend already initialized.");
		return 0;
	}

	if (libmtd_open(device, &mtd_desc) < 0) {
		LOG(LOG_LEVEL_ERROR, "Failed to open MTD device: %s", device);
		return -1;
	}

	if (mtd_get_info(mtd_desc, &mtd_info) < 0) {
		LOG(LOG_LEVEL_ERROR, "Failed to get MTD device info.");
		libmtd_close(mtd_desc);
		mtd_desc = NULL;
		return -1;
	}

	/* Functional log: always print this */
	printf("MTD device '%s' opened. Size: %llu MB, Erase size: %u KB\n",
	       device, mtd_info.size / (1024 * 1024),
	       mtd_info.erasesize / 1024);
	return 0;
}

/**
 * @brief Deinitializes the libmtd backend.
 * @see flash_interface.h
 */
static void mtd_backend_deinit(void)
{
	if (mtd_desc) {
		libmtd_close(mtd_desc);
		mtd_desc = NULL;
		printf("MTD device closed.\n");
	}
}

/**
 * @brief Erases flash using libmtd.
 * @see flash_interface.h
 */
static int mtd_backend_erase(uint32_t offset, uint32_t len)
{
	struct erase_info_user einfo = {
		.start = offset,
		.length = len
	};

	if (!mtd_desc) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}

	if (mtd_erase(mtd_desc, &einfo) != 0) {
		LOG(LOG_LEVEL_ERROR, "libmtd erase failed.");
		return -1;
	}
	return 0;
}

/**
 * @brief Writes to flash using libmtd.
 * @see flash_interface.h
 */
static int mtd_backend_write(uint32_t offset, const void *data, size_t len)
{
	if (!mtd_desc) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}

	if (mtd_write(mtd_desc, offset, len, data) < 0) {
		LOG(LOG_LEVEL_ERROR, "libmtd write failed.");
		return -1;
	}
	return 0;
}

/**
 * @brief Reads from flash using libmtd.
 * @see flash_interface.h
 */
static int mtd_backend_read(uint32_t offset, void *data, size_t len)
{
	if (!mtd_desc) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}

	if (mtd_read(mtd_desc, offset, len, data) < 0) {
		LOG(LOG_LEVEL_ERROR, "libmtd read failed.");
		return -1;
	}
	return 0;
}

/**
 * @brief Gets MTD info.
 * @see flash_interface.h
 */
static int mtd_backend_get_info(struct mtd_info_user *info)
{
	if (!mtd_desc) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	memcpy(info, &mtd_info, sizeof(struct mtd_info_user));
	return 0;
}

/**
 * @brief The instance of flash_ops for the libmtd backend.
 */
const flash_ops_t libmtd_backend = {
	.init = mtd_backend_init,
	.deinit = mtd_backend_deinit,
	.erase = mtd_backend_erase,
	.write = mtd_backend_write,
	.read = mtd_backend_read,
	.get_info = mtd_backend_get_info,
};
src/backend/flash_ioctl.c#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <stdlib.h>
#include "../include/flash_interface.h"
#include "../include/logger.h"

/**
 * @file flash_ioctl.c
 * @brief MTD backend implementation using direct ioctl calls.
 */

/* Module-level static state for the ioctl backend */
static int mtd_fd = -1;
static struct mtd_info_user mtd_info;
static char *mtd_device_path;

/**
 * @brief Verifies that a region of flash has been erased correctly.
 *
 * Reads back the erased region and checks if all bytes are 0xFF.
 *
 * @param offset The start offset of the region to verify.
 * @param len The length of the region.
 * @return 0 on successful verification, -1 on failure.
 */
static int verify_erase(uint32_t offset, uint32_t len)
{
	uint8_t *buf;
	size_t i;
	int ret = -1;

	buf = malloc(len);
	if (!buf) {
		LOG(LOG_LEVEL_ERROR, "Failed to allocate memory for erase verification.");
		return -1;
	}

	if (lseek(mtd_fd, offset, SEEK_SET) < 0) {
		LOG(LOG_LEVEL_ERROR, "lseek failed for erase verification.");
		goto out_free;
	}

	if (read(mtd_fd, buf, len) != (ssize_t)len) {
		LOG(LOG_LEVEL_ERROR, "read failed for erase verification.");
		goto out_free;
	}

	for (i = 0; i < len; i++) {
		if (buf[i] != 0xFF) {
			LOG(LOG_LEVEL_ERROR,
			    "Erase verification failed at offset 0x%x (is 0x%02x, should be 0xFF).",
			    (unsigned int)(offset + i), buf[i]);
			goto out_free;
		}
	}

	LOG(LOG_LEVEL_DEBUG, "Erase verified successfully for 0x%x bytes at 0x%x.", len, offset);
	ret = 0;

out_free:
	free(buf);
	return ret;
}

/**
 * @brief Initializes the ioctl backend.
 * @see flash_interface.h
 */
static int ioctl_backend_init(const char *device)
{
	if (mtd_fd >= 0) {
		LOG(LOG_LEVEL_WARN, "ioctl backend already initialized.");
		return 0;
	}

	mtd_fd = open(device, O_RDWR);
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Failed to open MTD device: %s", device);
		return -1;
	}

	if (ioctl(mtd_fd, MEMGETINFO, &mtd_info) != 0) {
		LOG(LOG_LEVEL_ERROR, "ioctl(MEMGETINFO) failed.");
		close(mtd_fd);
		mtd_fd = -1;
		return -1;
	}

	mtd_device_path = strdup(device);

	/* Functional log: always print this */
	printf("MTD device '%s' opened. Size: %llu MB, Erase size: %u KB\n",
	       device, mtd_info.size / (1024 * 1024),
	       mtd_info.erasesize / 1024);
	return 0;
}

/**
 * @brief Deinitializes the ioctl backend.
 * @see flash_interface.h
 */
static void ioctl_backend_deinit(void)
{
	if (mtd_fd >= 0) {
		close(mtd_fd);
		mtd_fd = -1;
		free(mtd_device_path);
		mtd_device_path = NULL;
		printf("MTD device closed.\n");
	}
}

/**
 * @brief Erases flash using ioctl, with lock/unlock and verification.
 * @see flash_interface.h
 */
static int ioctl_backend_erase(uint32_t offset, uint32_t len)
{
	struct erase_info_user einfo = {
		.start = offset,
		.length = len
	};

	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}

	/* Check if the region is locked */
	LOG(LOG_LEVEL_DEBUG, "Checking lock status for offset 0x%x", offset);
	if (ioctl(mtd_fd, MEMISLOCKED, &einfo) > 0) {
		LOG(LOG_LEVEL_WARN, "Erase block at 0x%x is locked, attempting unlock.", offset);
		if (ioctl(mtd_fd, MEMUNLOCK, &einfo) != 0) {
			LOG(LOG_LEVEL_ERROR, "Failed to unlock erase block.");
			return -1;
		}
	}

	if (ioctl(mtd_fd, MEMERASE, &einfo) != 0) {
		LOG(LOG_LEVEL_ERROR, "ioctl(MEMERASE) failed.");
		return -1;
	}

	/* Verify that the erase was successful */
	if (verify_erase(offset, len) != 0) {
		LOG(LOG_LEVEL_ERROR, "Erase failed verification.");
		return -1;
	}

	return 0;
}

/**
 * @brief Writes to flash using standard file operations.
 * @see flash_interface.h
 */
static int ioctl_backend_write(uint32_t offset, const void *data, size_t len)
{
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}

	if (lseek(mtd_fd, offset, SEEK_SET) < 0) {
		LOG(LOG_LEVEL_ERROR, "lseek failed for write.");
		return -1;
	}

	if (write(mtd_fd, data, len) != (ssize_t)len) {
		LOG(LOG_LEVEL_ERROR, "write failed.");
		return -1;
	}
	return 0;
}

/**
 * @brief Reads from flash using standard file operations.
 * @see flash_interface.h
 */
static int ioctl_backend_read(uint32_t offset, void *data, size_t len)
{
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}

	if (lseek(mtd_fd, offset, SEEK_SET) < 0) {
		LOG(LOG_LEVEL_ERROR, "lseek failed for read.");
		return -1;
	}

	if (read(mtd_fd, data, len) != (ssize_t)len) {
		LOG(LOG_LEVEL_ERROR, "read failed.");
		return -1;
	}
	return 0;
}

/**
 * @brief Gets MTD info.
 * @see flash_interface.h
 */
static int ioctl_backend_get_info(struct mtd_info_user *info)
{
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	memcpy(info, &mtd_info, sizeof(struct mtd_info_user));
	return 0;
}

/**
 * @brief The instance of flash_ops for the ioctl backend.
 */
const flash_ops_t ioctl_backend = {
	.init = ioctl_backend_init,
	.deinit = ioctl_backend_deinit,
	.erase = ioctl_backend_erase,
	.write = ioctl_backend_write,
	.read = ioctl_backend_read,
	.get_info = ioctl_backend_get_info,
};
src/cli.c#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include "include/cli.h"
#include "include/config.h"
#include "include/flash_interface.h"
#include "include/logger.h"
#include "include/utils.h"

/**
 * @file cli.c
 * @brief Implements the command-line interface logic.
 */

/* Forward declarations for command handlers */
static void handle_flash_write(int argc, char *argv[]);
static void handle_flash_read(int argc, char *argv[]);
static void handle_flash_write_verify(int argc, char *argv[]);
static void handle_flash_erase(int argc, char *argv[]);

/**
 * See cli.h for documentation.
 */
void print_help(void)
{
	printf("Flash Tool CLI - Help\n");
	printf("------------------------\n");
	printf("General Commands:\n");
	printf("  help                       : Show this help message.\n");
	printf("  clr                        : Clear the terminal screen.\n");
	printf("  exit                       : Exit the application.\n\n");

	printf("Flash Write Command:\n");
	printf("  flash write <type> <pattern> <sector> <size>\n");
	printf("    <type>    : P, Z, Y (Note: Ignored, for compatibility).\n");
	printf("    <pattern> : +, -, or a hex value (e.g., 0xAA).\n");
	printf("    <sector>  : Start sector number (based on device erase block size).\n");
	printf("    <size>    : Number of bytes to write (max is sector size).\n\n");

	printf("Flash Read Command:\n");
	printf("  flash read <type> <sector> <size>\n");
	printf("    <type>    : Z, Y, O, etc. (Note: Ignored).\n");
	printf("    <sector>  : Start sector number.\n");
	printf("    <size>    : Number of bytes to read.\n\n");

	printf("Flash Write-Verify Command:\n");
	printf("  flash write-verify <type> <sector> <iter> <fail_cnt> <log> <full_util>\n");
	printf("    (This command is not fully implemented and serves as a placeholder.)\n\n");

	printf("Flash Erase Command:\n");
	printf("  flash erase <type> <start_sector> [end_sector]\n");
	printf("    <type>         : A (Auto-detect), O (128k), Y (32k), Z (4k), C (Chip Erase).\n");
	printf("    <start_sector> : Sector number based on <type> size.\n");
	printf("    [end_sector]   : Optional last sector to erase.\n");
}

/**
 * See cli.h for documentation.
 */
void cli_process_command(int argc, char *argv[])
{
	if (argc == 0)
		return;

	if (strcmp(argv[0], "help") == 0) {
		print_help();
	} else if (strcmp(argv[0], "clr") == 0) {
		printf("\033[H\033[J");
	} else if (strcmp(argv[0], "flash") == 0) {
		if (argc < 2) {
			printf("Error: 'flash' requires a subcommand.\n");
			return;
		}
		if (strcmp(argv[1], "write") == 0)
			handle_flash_write(argc, argv);
		else if (strcmp(argv[1], "read") == 0)
			handle_flash_read(argc, argv);
		else if (strcmp(argv[1], "write-verify") == 0)
			handle_flash_write_verify(argc, argv);
		else if (strcmp(argv[1], "erase") == 0)
			handle_flash_erase(argc, argv);
		else
			printf("Error: Unknown flash command '%s'.\n", argv[1]);
	} else {
		printf("Error: Unknown command '%s'.\n", argv[0]);
	}
}

/**
 * @brief Handler for the 'flash write' command.
 */
static void handle_flash_write(int argc, char *argv[])
{
	long sector_num, write_size;
	uint32_t offset;
	uint8_t *write_buf;
	struct mtd_info_user info;

	if (argc != 6) {
		printf("Usage: flash write <type> <pattern> <sector> <size>\n");
		return;
	}

	if (parse_number(argv[4], &sector_num) != 0 ||
	    parse_number(argv[5], &write_size) != 0) {
		printf("Error: Invalid number for sector or size.\n");
		return;
	}

	g_flash_backend->get_info(&info);
	if (sector_num < 0 || write_size <= 0 ||
	    write_size > info.erasesize) {
		printf("Error: Size must be > 0 and <= erase block size (%u).\n",
		       info.erasesize);
		return;
	}

	offset = sector_num * info.erasesize;
	if (offset + write_size > info.size) {
		printf("Error: Write operation exceeds flash size.\n");
		return;
	}

	write_buf = malloc(write_size);
	if (!write_buf) {
		LOG(LOG_LEVEL_ERROR, "Failed to allocate write buffer.");
		return;
	}

	if (generate_pattern(write_buf, write_size, argv[3]) != 0) {
		free(write_buf);
		return;
	}

	printf("Preparing to write %ld bytes to sector %ld (offset 0x%08x).\n",
	       write_size, sector_num, offset);

	if (g_flash_backend->write(offset, write_buf, write_size) == 0)
		printf("Write successful.\n");
	else
		printf("Write failed.\n");

	free(write_buf);
}

/**
 * @brief Handler for the 'flash read' command.
 */
static void handle_flash_read(int argc, char *argv[])
{
	long sector_num, read_size;
	uint32_t offset;
	uint8_t *read_buf;
	struct mtd_info_user info;

	if (argc != 5) {
		printf("Usage: flash read <type> <sector> <size>\n");
		return;
	}

	if (parse_number(argv[3], &sector_num) != 0 ||
	    parse_number(argv[4], &read_size) != 0) {
		printf("Error: Invalid number for sector or size.\n");
		return;
	}

	g_flash_backend->get_info(&info);
	if (sector_num < 0 || read_size <= 0) {
		printf("Error: Invalid sector or size.\n");
		return;
	}

	offset = sector_num * info.erasesize;
	if (offset + read_size > info.size) {
		printf("Error: Read operation exceeds flash size.\n");
		return;
	}

	read_buf = malloc(read_size);
	if (!read_buf) {
		LOG(LOG_LEVEL_ERROR, "Failed to allocate read buffer.");
		return;
	}

	printf("Reading %ld bytes from sector %ld (offset 0x%08x).\n",
	       read_size, sector_num, offset);

	if (g_flash_backend->read(offset, read_buf, read_size) == 0) {
		printf("Read successful. Hexdump:\n");
		hexdump("  ", read_buf, read_size);
	} else {
		printf("Read failed.\n");
	}

	free(read_buf);
}

/**
 * @brief Handler for the 'flash write-verify' command (stub).
 */
static void handle_flash_write_verify(int argc, char *argv[])
{
	(void)argc;
	(void)argv;
	printf("Command 'flash write-verify' is a complex placeholder.\n");
	printf("A full implementation would loop erase/write/read/compare cycles.\n");
}

/**
 * @brief Handler for the 'flash erase' command.
 */
static void handle_flash_erase(int argc, char *argv[])
{
	long start_sector, end_sector;
	char type;
	uint32_t erase_unit_size = 0, start_offset, total_len;
	struct mtd_info_user info;

	if (argc < 3) {
		printf("Usage: flash erase <type> <start_sector> [end_sector]\n");
		return;
	}

	type = argv[2][0];
	g_flash_backend->get_info(&info);

	if (type == 'C' || type == 'c') {
		if (argc != 3) {
			printf("Usage: flash erase C\n");
			return;
		}
		printf("Performing CHIP ERASE on MTD device. This will erase the ENTIRE flash.\n");
		printf("Are you sure? (y/N): ");
        /* Clear stdin buffer before reading char */
        int c;
        while ((c = getchar()) != '\n' && c != EOF);
		if (getchar() != 'y') {
			printf("Chip erase aborted.\n");
			return;
		}
        while ((c = getchar()) != '\n' && c != EOF); /* Clear rest of the line */

		printf("Erasing entire device (%llu bytes)...\n", info.size);
		if (g_flash_backend->erase(0, info.size) == 0)
			printf("Chip erase successful.\n");
		else
			printf("Chip erase failed.\n");
		return;
	}

	if (argc < 4 || argc > 5) {
		printf("Usage: flash erase <type> <start_sector> [end_sector]\n");
		return;
	}

	if (parse_number(argv[3], &start_sector) != 0) {
		printf("Error: Invalid start sector.\n");
		return;
	}
	
    if (argc == 5) {
        if (parse_number(argv[4], &end_sector) != 0) {
            printf("Error: Invalid end sector.\n");
            return;
        }
    } else {
        end_sector = start_sector;
    }

	if (start_sector < 0 || end_sector < start_sector) {
		printf("Error: Invalid sector range.\n");
		return;
	}

	switch (type) {
	case 'A': case 'a': erase_unit_size = info.erasesize;
		printf("Auto-detected erase size: %u bytes.\n", erase_unit_size);
		break;
	case 'O': case 'o': erase_unit_size = 131072; break;
	case 'Y': case 'y': erase_unit_size = 32768; break;
	case 'Z': case 'z': erase_unit_size = 4096; break;
	default: printf("Error: Invalid erase type '%c'.\n", type); return;
	}

	start_offset = start_sector * erase_unit_size;
	total_len = (end_sector - start_sector + 1) * erase_unit_size;

	if (start_offset + total_len > info.size) {
		printf("Error: Erase range exceeds flash size.\n");
		return;
	}

	if (start_offset % info.erasesize != 0 || total_len % info.erasesize != 0) {
		printf("Warning: Requested erase geometry does not align with device's native erase size (%u).\n", info.erasesize);
	}

	printf("Erasing %ld block(s) from offset 0x%08x...\n",
	       (end_sector - start_sector + 1), start_offset);

	if (g_flash_backend->erase(start_offset, total_len) == 0)
		printf("Erase successful.\n");
	else
		printf("Erase failed.\n");
}
src/main.c#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "include/config.h"
#include "include/cli.h"
#include "include/flash_interface.h"
#include "include/logger.h"

/* Select the backend implementation based on Makefile flags */
#ifdef USE_LIBMDT_BACKEND
extern const flash_ops_t libmtd_backend;
#elif defined(USE_IOCTL_BACKEND)
extern const flash_ops_t ioctl_backend;
#else
#error "No MTD backend specified! Define USE_LIBMDT_BACKEND or USE_IOCTL_BACKEND."
#endif

/* Global pointer to the active backend */
const flash_ops_t *g_flash_backend;

/**
 * See flash_interface.h for documentation.
 */
void backend_init(void)
{
#ifdef USE_LIBMDT_BACKEND
	g_flash_backend = &libmtd_backend;
	LOG(LOG_LEVEL_INFO, "libmtd backend selected.");
#elif defined(USE_IOCTL_BACKEND)
	g_flash_backend = &ioctl_backend;
	LOG(LOG_LEVEL_INFO, "ioctl backend selected.");
#endif
}

/**
 * @brief Main entry point for the flash tool application.
 *
 * Initializes the backend, enters a read-eval-print loop (REPL) to
 * process user commands, and cleans up on exit.
 *
 * @param argc Argument count.
 * @param argv Argument vector.
 * @return EXIT_SUCCESS on normal exit, EXIT_FAILURE on fatal error.
 */
int main(int argc, char *argv[])
{
	char input[MAX_CLI_INPUT_SIZE];
	char *args[MAX_CLI_ARGS];
	int arg_count;
	char *token;

	(void)argc;
	(void)argv;

	printf("Flash Tool Initializing...\n");

	backend_init();

	if (g_flash_backend->init(DEFAULT_MTD_DEVICE) != 0) {
		fprintf(stderr,
			"FATAL: Could not initialize flash backend. Exiting.\n");
		return EXIT_FAILURE;
	}

	printf("Initialization complete. Type 'help' for commands.\n");

	while (1) {
		printf("> ");
		fflush(stdout);

		if (fgets(input, sizeof(input), stdin) == NULL)
			break; /* EOF */

		/* Remove trailing newline */
		input[strcspn(input, "\n")] = 0;

		if (strlen(input) == 0)
			continue;

		if (strcmp(input, "exit") == 0)
			break;

		/* Tokenize input */
		arg_count = 0;
		token = strtok(input, " \t");
		while (token != NULL && arg_count < MAX_CLI_ARGS) {
			args[arg_count++] = token;
			token = strtok(NULL, " \t");
		}

		if (arg_count > 0)
			cli_process_command(arg_count, args);
	}

	printf("Exiting. Cleaning up...\n");
	g_flash_backend->deinit();

	return EXIT_SUCCESS;
}
