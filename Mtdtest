// --- flash_backend_mtd-user.c (UPDATED with mtd-utils block-looping logic) ---
// This file is compiled only if USE_LIBMTD is NOT defined.
#ifndef USE_LIBMTD

#include "flash_backend.h"
#include "logger.h"
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <stdint.h>

// For this backend, the FlashHandle is just an int file descriptor.
#define FD_FROM_HANDLE(h) ((int)(intptr_t)(h))

FlashHandle flash_open(const char *device_path) {
    // Open with O_SYNC to request cached I/O to be written to the underlying device.
    int fd = open(device_path, O_RDWR | O_SYNC);
    if (fd < 0) {
        LOG_ERROR("Failed to open MTD device '%s': %s", device_path, strerror(errno));
        return NULL;
    }
    return (FlashHandle)(intptr_t)fd;
}

void flash_close(FlashHandle handle) {
    if (handle) {
        close(FD_FROM_HANDLE(handle));
    }
}

int flash_get_info(FlashHandle handle, mtd_info_t *mtd_info) {
    if (ioctl(FD_FROM_HANDLE(handle), MEMGETINFO, mtd_info) != 0) {
        LOG_ERROR("Failed to get MTD device info: %s", strerror(errno));
        return -1;
    }
    return 0;
}

int flash_erase(FlashHandle handle, uint32_t offset, uint32_t len) {
    int fd = FD_FROM_HANDLE(handle);
    mtd_info_t mtd_info;
    if (flash_get_info(handle, &mtd_info) != 0) {
        return -1;
    }

    // 1. Unlock the entire region first.
    erase_info_t unlock_info = { .start = offset, .length = len };
    LOG_INFO("Unlocking region from 0x%08X to 0x%08X...", offset, offset + len - 1);
    if (ioctl(fd, MEMUNLOCK, &unlock_info) != 0) {
        LOG_WARN("MEMUNLOCK failed: %s. This may be acceptable if locking is not supported.", strerror(errno));
    }

    // 2. *** CRITICAL CHANGE: Loop and erase ONE BLOCK AT A TIME. ***
    // This is the core logic of the official `flash_erase` utility. It avoids
    // driver limitations on erasing large, contiguous chunks.
    uint32_t current_offset = offset;
    uint32_t end_offset = offset + len;
    while (current_offset < end_offset) {
        LOG_INFO("Erasing block at 0x%08X (size 0x%X)...", current_offset, mtd_info.erasesize);
        
        erase_info_t erase_block_info = {
            .start = current_offset,
            .length = mtd_info.erasesize
        };

        // The MEMERASE ioctl is blocking.
        if (ioctl(fd, MEMERASE, &erase_block_info) != 0) {
            LOG_ERROR("MEMERASE ioctl failed for block at 0x%08X: %s", current_offset, strerror(errno));
            // We do not attempt to re-lock, just report failure.
            return -1;
        }

        current_offset += mtd_info.erasesize;
    }

    LOG_INFO("Finished erasing range.");
    return 0;
}

int flash_write(FlashHandle handle, uint32_t offset, const uint8_t *data, size_t size) {
    int fd = FD_FROM_HANDLE(handle);

    // Use pwrite() for an atomic write to a specific offset.
    // This avoids a separate lseek() and is the method used by `nandwrite`.
    ssize_t written_bytes = pwrite(fd, data, size, offset);
    
    if (written_bytes < 0) {
        LOG_ERROR("pwrite failed at offset 0x%08X: %s", offset, strerror(errno));
        return -1;
    }
    if ((size_t)written_bytes != size) {
        LOG_WARN("Incomplete write. Wrote %zd of %zu bytes.", written_bytes, size);
        return -1;
    }
    return 0;
}

int flash_read(FlashHandle handle, uint32_t offset, uint8_t *buffer, size_t size) {
    int fd = FD_FROM_HANDLE(handle);

    // Use pread() for an atomic read from a specific offset.
    ssize_t read_bytes = pread(fd, buffer, size, offset);

    if (read_bytes < 0) {
        LOG_ERROR("pread failed at offset 0x%08X: %s", offset, strerror(errno));
        return -1;
    }
    if ((size_t)read_bytes != size) {
        LOG_WARN("Incomplete read. Read %zd of %zu bytes.", read_bytes, size);
        return -1;
    }
    return 0;
}

#endif // !USE_LIBMTD

