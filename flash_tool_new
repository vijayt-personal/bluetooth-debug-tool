meta-custom/
└── recipes-utils/
    └── flash-tool/
        ├── files/
        │   ├── flash_tool.c
        │   └── Makefile
        ├── flash-tool_0.1.bb
        └── README.md

# NXP i.MX8 Flash Tool (Native MTD Version)

This document provides instructions for the `flash_tool` CLI. This version has been significantly updated to use **native C system calls** for all flash operations, removing the dependency on external tools like `dd` or `mtd-utils`. This makes it a self-contained, efficient, and proper example of how to program MTD devices in an embedded Linux environment.

## 1. ⚠️ DANGER: Safety Warning on Restricted Locations

**Writing to the wrong memory location can permanently "brick" your device, making it unbootable.**

The flash memory on your i.MX8 board contains critical data, including the bootloader (U-Boot), kernel, and device tree. Overwriting any of these will prevent your board from booting. This tool now includes a strict check and will **abort** if you attempt to write to or erase an address below **1MB (`0x100000`)**.

**ALWAYS consult your board's memory map and documentation before writing to flash.** Be absolutely certain that the sectors you are targeting are designated for user data.

## 2. Overview

This tool performs flash operations using direct MTD (Memory Technology Device) access. It can generate data with specific patterns for writing, erase blocks, and verify writes.

**Important Note:** The `<type>` parameter (`P`, `Z`, `Y`) in the commands is included for syntax compatibility only. The Linux kernel's MTD subsystem abstracts the physical flash programming mode. This tool will perform a standard write/read operation regardless of the type specified.

## 3. Building with Yocto (Meta-Layer)

The recommended way to build and deploy this application is to create a custom Yocto meta-layer.

### Step 1: Create the Recipe Structure
Create the directory structure and place the `flash_tool.c`, `Makefile`, and `flash-tool_0.1.bb` files as shown in the project documentation.

### Step 2: Add Application to Your Image
Add `flash-tool` to your build's `conf/local.conf` file:
```
IMAGE_INSTALL_append = " flash-tool"
```
Now, when you build your Yocto image, the `flash-tool` will be compiled and installed to `/usr/bin/` on the target device.

## 4. Command Reference

All commands use hexadecimal or standard integers for `<offset>` and `<size>`.

### `flash write`
Writes data with a generated pattern to a specified location.
**Syntax:** `./flash_tool flash write <type> <pattern> <offset> <size>`

* **`<pattern>`**: `+` for ascending, `-` for descending, or a hex value like `0xA5`.

### `flash read`
Reads data from a specified location and prints it to the console as a formatted hex dump.
**Syntax:** `./flash_tool flash read <type> <offset> <size>`

**Example Output:**
```
sector=0x100000 size=32
Data read followed by sector 0x100000
offset 0x00100000 : 00 01 02 03 04 05 06 07
offset 0x00100008 : 08 09 0A 0B 0C 0D 0E 0F
offset 0x00100010 : 10 11 12 13 14 15 16 17
offset 0x00100018 : 18 19 1A 1B 1C 1D 1E 1F
```

### `flash erase` / `flash clear`
Erases a region of flash. The offset and size **must** be aligned to the flash chip's erase block size. The tool will check this and exit if the alignment is incorrect.
**Syntax:** `./flash_tool flash erase <offset> <size>`

### `flash write-verify`
Performs a write operation, then immediately reads the data back to verify its integrity.
**Syntax:** `./flash_tool flash write-verify <type> <pattern> <offset> <size>`



/*
 * flash_tool.c
 *
 * A non-interactive command-line utility for an NXP i.MX8 board.
 * This version uses native C system calls to interact directly with MTD devices,
 * serving as a proper example of flash memory programming.
 *
 * To cross-compile for the i.MX8 (ARM64 architecture):
 * aarch64-linux-gnu-gcc -o flash_tool flash_tool.c
 *
 * Author: Gemini
 * Date: August 1, 2025
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <ctype.h>
#include <mtd/mtd-user.h>

#define MTD_DEVICE_DEFAULT "/dev/mtd0"
#define BOOTLOADER_WARN_ADDR 0x100000 // 1MB

// Function prototypes
void print_help(const char *app_name);
int generate_pattern_data(const char* pattern, unsigned char* buffer, long size);
void handle_flash_write(int argc, char *argv[]);
void handle_flash_read(int argc, char *argv[]);
void handle_flash_erase(int argc, char *argv[]);
void handle_flash_write_verify(int argc, char *argv[]);

/**
 * @brief Main entry point for the flash tool.
 */
int main(int argc, char *argv[]) {
    if (argc < 2) {
        print_help(argv[0]);
        return 1;
    }

    if (strcmp(argv[1], "flash") != 0) {
        fprintf(stderr, "Error: Top-level command must be 'flash'.\n");
        print_help(argv[0]);
        return 1;
    }

    if (argc < 3) {
        fprintf(stderr, "Error: Missing flash subcommand.\n");
        print_help(argv[0]);
        return 1;
    }

    char *sub_cmd = argv[2];

    if (strcmp(sub_cmd, "write") == 0) {
        handle_flash_write(argc, argv);
    } else if (strcmp(sub_cmd, "read") == 0) {
        handle_flash_read(argc, argv);
    } else if (strcmp(sub_cmd, "erase") == 0 || strcmp(sub_cmd, "clear") == 0) {
        handle_flash_erase(argc, argv);
    } else if (strcmp(sub_cmd, "write-verify") == 0) {
        handle_flash_write_verify(argc, argv);
    } else if (strcmp(sub_cmd, "help") == 0) {
        print_help(argv[0]);
    } else {
        fprintf(stderr, "Error: Unknown flash command '%s'.\n", sub_cmd);
        print_help(argv[0]);
        return 1;
    }

    return 0;
}

/**
 * @brief Prints the help message to standard output.
 */
void print_help(const char *app_name) {
    printf("NXP i.MX8 Flash Tool (Native MTD Version)\n\n");
    printf("Usage: %s flash <command> [options]\n\n", app_name);
    printf("Available commands:\n");
    printf("  write <type> <pattern> <offset> <size>    - Write data with a specific pattern to flash.\n");
    printf("      <type>: P, Z, Y (for syntax compatibility only).\n");
    printf("      <pattern>: '+' (ascending), '-' (descending), or a hex value (e.g., 0xA5).\n");
    printf("\n");
    printf("  read <type> <offset> <size>               - Read data from flash and print formatted hex.\n");
    printf("      <type>: P, Z, Y (for syntax compatibility only).\n");
    printf("\n");
    printf("  write-verify <type> <pattern> <offset> <size> - Write data and verify it was written correctly.\n");
    printf("\n");
    printf("  erase <offset> <size>                     - Erase a region of flash.\n");
    printf("\n");
    printf("  clear <offset> <size>                     - Alias for 'erase'.\n");
    printf("\n");
    printf("  help                                      - Show this help message.\n");
}

/**
 * @brief Generates a block of data based on a specified pattern.
 * @return 0 on success, -1 on failure.
 */
int generate_pattern_data(const char* pattern, unsigned char* buffer, long size) {
    if (strcmp(pattern, "+") == 0) {
        for (long i = 0; i < size; i++) {
            buffer[i] = (unsigned char)(i & 0xFF);
        }
    } else if (strcmp(pattern, "-") == 0) {
        for (long i = 0; i < size; i++) {
            buffer[i] = (unsigned char)((0xFF - i) & 0xFF);
        }
    } else {
        char *endptr;
        long val = strtol(pattern, &endptr, 16);
        if (*endptr != '\0' || val < 0 || val > 255) {
            fprintf(stderr, "Error: Invalid hex pattern. Must be 0x00-0xFF.\n");
            return -1;
        }
        memset(buffer, (unsigned char)val, size);
    }
    return 0;
}

/**
 * @brief Handles the 'flash write' command using native MTD calls.
 */
void handle_flash_write(int argc, char *argv[]) {
    if (argc != 7) {
        fprintf(stderr, "Usage: %s flash write <type> <pattern> <offset> <size>\n", argv[0]);
        exit(1);
    }
    char *pattern = argv[4];
    char *offset_str = argv[5];
    char *size_str = argv[6];

    long offset = strtol(offset_str, NULL, 0);
    if (offset < BOOTLOADER_WARN_ADDR) {
        fprintf(stderr, "!! WARNING: Writing to a low-level address (0x%lX).\n!! This may overwrite the bootloader and brick your device.\n!! Aborting.\n", offset);
        exit(1);
    }

    long size = strtol(size_str, NULL, 0);
    if (size <= 0) {
        fprintf(stderr, "Error: Invalid size '%s'.\n", size_str);
        exit(1);
    }

    unsigned char *data_buffer = malloc(size);
    if (!data_buffer) {
        fprintf(stderr, "Error: Failed to allocate memory for data pattern.\n");
        exit(1);
    }
    if (generate_pattern_data(pattern, data_buffer, size) != 0) {
        free(data_buffer);
        exit(1);
    }

    int fd = open(MTD_DEVICE_DEFAULT, O_RDWR);
    if (fd < 0) {
        perror("Error opening MTD device");
        free(data_buffer);
        exit(1);
    }

    if (lseek(fd, offset, SEEK_SET) == (off_t)-1) {
        perror("Error seeking MTD device");
        free(data_buffer);
        close(fd);
        exit(1);
    }

    ssize_t bytes_written = write(fd, data_buffer, size);
    free(data_buffer);
    close(fd);

    if (bytes_written < 0) {
        perror("Error writing to MTD device");
        exit(1);
    } else if (bytes_written < size) {
        fprintf(stderr, "Error: Wrote only %ld of %ld bytes.\n", bytes_written, size);
        exit(1);
    }

    printf("Flash write successful.\n");
}

/**
 * @brief Handles the 'flash read' command using native MTD calls.
 */
void handle_flash_read(int argc, char *argv[]) {
    if (argc != 6) {
        fprintf(stderr, "Usage: %s flash read <type> <offset> <size>\n", argv[0]);
        exit(1);
    }
    char *offset_str = argv[4];
    char *size_str = argv[5];
    
    long offset = strtol(offset_str, NULL, 0);
    long size = strtol(size_str, NULL, 0);
    if (size <= 0) {
        fprintf(stderr, "Error: Invalid size '%s'.\n", size_str);
        exit(1);
    }
    
    printf("sector=%s size=%s\n", offset_str, size_str);

    unsigned char *data_buffer = malloc(size);
    if (!data_buffer) {
        fprintf(stderr, "Error: Failed to allocate memory for read buffer.\n");
        exit(1);
    }

    int fd = open(MTD_DEVICE_DEFAULT, O_RDONLY);
    if (fd < 0) {
        perror("Error opening MTD device");
        free(data_buffer);
        exit(1);
    }

    if (lseek(fd, offset, SEEK_SET) == (off_t)-1) {
        perror("Error seeking MTD device");
        free(data_buffer);
        close(fd);
        exit(1);
    }

    ssize_t bytes_read = read(fd, data_buffer, size);
    close(fd);

    if (bytes_read < 0) {
        perror("Error reading from MTD device");
        free(data_buffer);
        exit(1);
    }

    printf("Data read followed by sector %s\n", offset_str);
    for (long i = 0; i < bytes_read; i++) {
        if (i % 8 == 0) {
            if (i > 0) printf("\n");
            printf("offset 0x%08lX : ", offset + i);
        }
        printf("%02X ", data_buffer[i]);
    }
    printf("\n");

    free(data_buffer);
}

/**
 * @brief Handles the 'flash erase' command using a MEMERASE ioctl.
 */
void handle_flash_erase(int argc, char *argv[]) {
    if (argc != 5) {
        fprintf(stderr, "Usage: %s flash erase <offset> <size>\n", argv[0]);
        exit(1);
    }
    char *offset_str = argv[3];
    char *size_str = argv[4];

    long offset = strtol(offset_str, NULL, 0);
    if (offset < BOOTLOADER_WARN_ADDR) {
        fprintf(stderr, "!! WARNING: Erasing a low-level address (0x%lX).\n!! This may overwrite the bootloader and brick your device.\n!! Aborting.\n", offset);
        exit(1);
    }

    int fd = open(MTD_DEVICE_DEFAULT, O_RDWR);
    if (fd < 0) {
        perror("Error opening MTD device");
        exit(1);
    }

    mtd_info_t mtd_info;
    if (ioctl(fd, MEMGETINFO, &mtd_info) != 0) {
        perror("Error getting MTD device info");
        close(fd);
        exit(1);
    }

    erase_info_t erase_info;
    erase_info.start = offset;
    erase_info.length = strtol(size_str, NULL, 0);

    if (erase_info.start % mtd_info.erasesize != 0 || erase_info.length % mtd_info.erasesize != 0) {
        fprintf(stderr, "Error: Erase offset and size must be multiples of the erase block size (0x%x).\n", mtd_info.erasesize);
        close(fd);
        exit(1);
    }

    printf("Erasing 0x%x bytes at offset 0x%x...\n", erase_info.length, erase_info.start);

    if (ioctl(fd, MEMERASE, &erase_info) != 0) {
        perror("Error erasing flash");
        close(fd);
        exit(1);
    }

    close(fd);
    printf("Flash erase successful.\n");
}

/**
 * @brief Handles the 'flash write-verify' command.
 */
void handle_flash_write_verify(int argc, char *argv[]) {
    if (argc != 7) {
        fprintf(stderr, "Usage: %s flash write-verify <type> <pattern> <offset> <size>\n", argv[0]);
        exit(1);
    }
    
    // For simplicity, we call the write function first.
    // A more optimized version might combine them, but this is clearer.
    printf("--- Step 1: Writing ---\n");
    handle_flash_write(argc, argv);
    printf("--- Write complete. ---\n\n");
    
    printf("--- Step 2: Verifying ---\n");
    char *pattern = argv[4];
    char *offset_str = argv[5];
    char *size_str = argv[6];
    
    long offset = strtol(offset_str, NULL, 0);
    long size = strtol(size_str, NULL, 0);
    
    // Generate the original data again for comparison
    unsigned char *original_data = malloc(size);
    if (!original_data || generate_pattern_data(pattern, original_data, size) != 0) {
        fprintf(stderr, "Error generating original data for verification.\n");
        if (original_data) free(original_data);
        exit(1);
    }
    
    // Read back the data from flash
    unsigned char *read_back_data = malloc(size);
    if (!read_back_data) {
        fprintf(stderr, "Error allocating memory for read-back buffer.\n");
        free(original_data);
        exit(1);
    }
    
    int fd = open(MTD_DEVICE_DEFAULT, O_RDONLY);
    if (fd < 0) {
        perror("Verify Error: opening MTD device");
        free(original_data);
        free(read_back_data);
        exit(1);
    }
    lseek(fd, offset, SEEK_SET);
    ssize_t bytes_read = read(fd, read_back_data, size);
    close(fd);
    
    if (bytes_read != size) {
        fprintf(stderr, "Verify Error: Could not read back the correct number of bytes.\n");
        free(original_data);
        free(read_back_data);
        exit(1);
    }
    
    // Compare the buffers
    if (memcmp(original_data, read_back_data, size) == 0) {
        printf("Verification successful: Contents match.\n");
    } else {
        fprintf(stderr, "Verification FAILED: Data mismatch!\n");
    }
    
    free(original_data);
    free(read_back_data);
}

# Makefile for flash_tool

# Cross-compiler prefix is inherited from Yocto environment (CC)
# For manual compilation, uncomment and set this:
# CC=aarch64-linux-gnu-gcc

# Target executable
TARGET=flash_tool

# Source file
SRCS=flash_tool.c

# C flags are inherited from Yocto (CFLAGS)
# For manual compilation, uncomment and set this:
# CFLAGS=-Wall -Wextra -O2

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(SRCS)
	$(CC) $(CFLAGS) -o $(TARGET) $(SRCS)

clean:
	rm -f $(TARGET)

----

SUMMARY = "A native C-based CLI tool for flash memory operations"
DESCRIPTION = "A non-interactive command-line utility for NXP i.MX8 boards that uses native MTD system calls to read, write, and erase flash memory."
LICENSE = "CLOSED"

# The header for MTD ioctls is needed from the kernel headers. This dependency
# ensures the mtd-user.h header is available at build time without
# forcing the full mtd-utils package onto the target image.
DEPENDS = "mtd-utils-native"

# The source files are expected to be in a "files" subdirectory next to this recipe
SRC_URI = "file://flash_tool.c \
           file://Makefile \
           file://README.md \
          "

# The working directory will be where the source files are copied
S = "${WORKDIR}"

# The compile task just needs to run make.
# oe_runmake passes the correct cross-compiler (CC) and flags (CFLAGS)
# from the Yocto environment to the Makefile.
do_compile() {
	oe_runmake
}

# The install task creates the destination directory and installs the binary
do_install() {
	install -d ${D}${bindir}
	install -m 0755 ${S}/flash_tool ${D}${bindir}/flash_tool

    # Install the README for reference
    install -d ${D}${docdir}/${PN}
    install -m 0644 ${WORKDIR}/README.md ${D}${docdir}/${PN}/
}
