# BLE Device Update Service Protocol

## Overview

This document specifies the protocol for the **Device Update Service**, a robust, packet-validated service for performing Over-The-Air (OTA) firmware updates to an embedded device over BLE.

While the peripheral device will implement a state machine to manage the update process (as shown in the diagrams below), this document's primary focus is on the **communication protocol** between the Central (e.g., a mobile app) and the Peripheral. It defines the BLE service structure, the packet framing, and the Protobuf messages used for the image transfer and update flow.

* **Target Chip**: ESP32 (example)
* **Update Type**: Full Application Firmware Update

## BLE GATT Structure

This service consists of a single primary service with three characteristics.

### Service UUID

* **Device Update Service UUID**: `12345678-1234-5678-1234-56789ABCDEF0` (Example UUID - replace with your own 128-bit UUID)

### Characteristics

| Characteristic | UUID | Properties | Direction | Description |
|---|---|---|---|---|
| **Control Point** | `0xFFF1` | Write With Response | Central → Peripheral | Start, End, Abort, Info commands |
| **Data Transfer** | `0xFFF2` | Write Without Response | Central → Peripheral | Stream firmware chunks |
| **Status / Progress** | `0xFFF3` | Notify | Peripheral → Central | ACKs and Responses |

## Packet Framing

Each message is framed for integrity, synchronization, and type identification before protobuf parsing.

| Start Byte (1B) | Message Type (1B) | Length (2B, LE) | Payload (Protobuf) | CRC32 (4B, LE) | End Byte (1B) |
|---|---|---|---|---|---|
| `0xAA` | *Type* | *Length* | *Payload* | *CRC* | `0xDD` |

* **Start Byte (1B):** Constant `0xAA` for synchronization.
* **Message Type (1B):** The value from the `MessageType` enum, defined in the `.proto` file.
* **Length (2B, LE):** The length of the `Payload` field only, in Little-Endian byte order. A 2-byte length is sufficient as the max payload per packet is less than 65,535 bytes.
* **Payload (Variable):** The protobuf-encoded message corresponding to the `Message Type`.
* **CRC32 (4B, LE):** Computed on `Message Type` + `Length` + `Payload`, in Little-Endian byte order.
* **End Byte (1B):** Constant `0xDD` for frame validation.
* **Total Frame Overhead:** 9 bytes.

## Protobuf Definition (nanopb Optimized)

The `.proto` file now defines a `MessageType` enum to act as a single source of truth for the type identifier in the packet frame. This prevents synchronization issues between the client and peripheral.

```proto
syntax = "proto3";

package local_ota;

// Defines the message type identifier used in the packet frame.
enum MessageType {
    MSG_TYPE_RESERVED = 0;
    MSG_TYPE_OTA_CONTROL = 1;
    MSG_TYPE_OTA_DATA = 2;
    MSG_TYPE_OTA_ACK = 3;
    MSG_TYPE_OTA_INFO_RESPONSE = 4;
}

enum OtaStatus {
    OK = 0;
    ERROR = 1;
    INVALID_HEADER = 2;
    CRC_MISMATCH = 3;
    UNSUPPORTED_COMMAND = 4;
    TIMEOUT = 5;
    INVALID_SEQUENCE = 6;
    VALIDATION_FAILED = 7;
    COMMIT_FAILED = 8;
    INVALID_PAYLOAD = 9;
    INCORRECT_PRODUCT = 10;
    UNSUPPORTED_SCHEME = 11;
    UNSUPPORTED_UPDATE_TYPE = 12;
}

// Defines the type of data being transferred.
enum UpdateType {
    FIRMWARE_APP = 0;   // Application firmware (default)
    FILESYSTEM = 1;
    CONFIG_DATA = 2;
}

// === Control Messages (Central -> Peripheral) ===
message OtaStart {
    UpdateType update_type = 1;     // The type of data being updated.
    uint32 image_size = 2;
    string fw_version = 3;          // e.g., "1.2.3" or a date for filesystem
    string hw_version = 4;          // e.g., "1.1"
    uint32 product_id = 5;          // Unique ID for the product type
    uint32 ota_scheme_version = 6;  // Version of this OTA protocol itself
    bytes signature = 7;            // For future use: cryptographic signature
}

message OtaEnd {
    uint32 total_chunks = 1;
    bytes image_hash = 2;           // e.g., SHA-256 hash of the full image
}

message OtaAbort {
    OtaStatus reason_code = 1;
    string message = 2;
}

message OtaRequestInfo {}

// This message's type is identified by MSG_TYPE_OTA_CONTROL
message OtaControl {
    oneof control_msg {
        OtaStart start_payload = 1;
        OtaEnd end_payload = 2;
        OtaAbort abort_payload = 3;
        OtaRequestInfo request_info_payload = 4;
    }
}

// === Data Transfer Message (Central -> Peripheral) ===
// This message's type is identified by MSG_TYPE_OTA_DATA
message OtaData {
    uint32 chunk_num = 1;
    bytes chunk = 2;
}

// === Response Messages (Peripheral -> Central) ===
// This message's type is identified by MSG_TYPE_OTA_ACK
message OtaAck {
    OtaStatus status = 1;
    string message = 2;
    uint32 received_chunk_num = 3; // For DATA_ACK
}

// This message's type is identified by MSG_TYPE_OTA_INFO_RESPONSE
message OtaInfoResponse {
    string current_fw_version = 1;
    string hw_version = 2;
    uint32 product_id = 3;
    uint32 supported_ota_scheme_version = 4;
    repeated UpdateType supported_update_types = 5; // Lists the update types the device can handle.
}
```

## Protocol Message Details

### Central → Peripheral Messages

#### `OtaControl` containing `OtaRequestInfo`
* **Description:** Used by the Central to query the Peripheral's capabilities before starting an OTA.
* **Example:** An app connects to the device and sends this command to determine which `UpdateType`s the device supports.

#### `OtaControl` containing `OtaStart`
* **Description:** Used by the Central to initiate the update process after it has determined compatibility.
* **Fields:**
  * `update_type`: Specifies the kind of data being sent (e.g., application firmware, filesystem). This allows the peripheral to select the correct memory partition and handler for the data.
  * `image_size`: The total size of the image in bytes.
  * `fw_version`: The version string of the new image.
  * `hw_version`: The hardware version this firmware is compatible with.
  * `product_id`: The product identifier this firmware is for.
  * `ota_scheme_version`: The version of the OTA protocol the Central intends to use.
  * `signature`: (For future use) A cryptographic signature of the firmware image.
* **Example:** The app wants to update the filesystem. It sends `OtaStart` with `update_type = FILESYSTEM` and the other relevant metadata.

#### `OtaData`
* **Description:** The workhorse message used to stream the image, one chunk at a time.
* **Example:** The Central sends a series of `OtaData` messages in a loop.

#### `OtaControl` containing `OtaEnd`
* **Description:** Sent by the Central after it has successfully transferred all data chunks.
* **Example:** After the last `OtaData` packet is acknowledged, the Central sends this message.

#### `OtaControl` containing `OtaAbort`
* **Description:** Sent by the Central if it needs to cancel the OTA process at any time.
* **Example:** The user taps the "Cancel" button in the mobile app.

### Peripheral → Central Messages

#### `OtaInfoResponse`
* **Description:** The Peripheral's response to an `OtaRequestInfo` command.
* **Fields:**
  * `current_fw_version`, `hw_version`, `product_id`, `supported_ota_scheme_version`: Provide device identity and protocol capabilities.
  * `supported_update_types`: A list of the `UpdateType` enums the device is capable of handling.
* **Example:** The device receives `OtaRequestInfo` and replies, indicating it supports `FIRMWARE_APP` and `FILESYSTEM` updates.

#### `OtaAck`
* **Description:** A general-purpose acknowledgement message used by the Peripheral to provide feedback.
* **Example (Data ACK):** After receiving `OtaData` with `chunk_num = 10`, the Peripheral sends `OtaAck` with `received_chunk_num = 10` and `status = OK`.

## Nanopb Implementation Note

For a safe implementation with `nanopb`, it's highly recommended to specify a maximum size for all `bytes` and `string` fields. This generates static arrays instead of memory-managed callback fields.

```
# local_ota.options
local_ota.OtaData.chunk max_size:494
local_ota.OtaStart.signature max_size:64
local_ota.OtaStart.fw_version max_size:16
local_ota.OtaStart.hw_version max_size:16
local_ota.OtaEnd.image_hash max_size:32
local_ota.OtaAbort.message max_size:32
local_ota.OtaInfoResponse.current_fw_version max_size:16
local_ota.OtaInfoResponse.hw_version max_size:16
local_ota.OtaInfoResponse.supported_update_types max_count:5
local_ota.OtaAck.message max_size:32
```

## BLE Performance: MTU, Block Size, and Throughput

### MTU and Data Length
* **MTU (Maximum Transmission Unit):** The maximum size of an ATT packet, negotiated between the Central and Peripheral. Let's assume an MTU of **512 bytes** is successfully negotiated for maximum speed.
* **ATT Overhead:** 3 bytes per GATT operation.
* **Data Length:** `ATT_MTU - 3` = **509 bytes**.
* **Note on MTU Choice:** While 512 bytes is fastest, it requires more RAM on the peripheral. An MTU of 247 is a common, safer alternative.

### Block Size (Chunk Size)
The `Block Size` refers to the size of the `OtaData.chunk` field.
* **Frame Overhead:** 9 bytes.
* **Protobuf Overhead:** ~6 bytes.
* **Calculation:** `509 - 9 - 6 =` **494 bytes**.

### Throughput and Time Estimation
* **Packets per Second:** `(1000ms / 7.5ms interval) * 4 packets/interval = ~533 packets/sec`
* **Throughput (Theoretical):** `533 packets/sec * 494 bytes/chunk = ~263 KB/s`
* **Real-World Throughput:** Assuming 60% efficiency, **~155 KB/s**.
* **Estimated Time for 6MB Image:** `6,291,456 bytes / (155 * 1024 bytes/s) = ~40 seconds`.

## OTA State Machine (Peripheral)

```mermaid
stateDiagram-v2
    [*] --> Idle
    
    Idle: Waiting for OTA initiation.
    Starting: Processing START command. Validating metadata.
    Receiving: Receiving firmware data chunks.
    Validating: All data received. Validating full image integrity.
    Committing: Writing firmware to flash and preparing for reboot.
    Aborted: OTA process aborted due to error or explicit command.
    Completed: OTA successful. Device reboots.

    Idle --> Starting : Central writes OtaControl(start_payload)
    Idle --> Idle : Central writes OtaControl(request_info_payload) / Sends OtaInfoResponse

    Starting --> Receiving : Valid START / Send OtaAck(OK)
    Starting --> Aborted : Invalid START (e.g., wrong product_id or unsupported update_type) / Send OtaAck(Error)
    
    Receiving --> Receiving : Central writes OtaData / Send OtaAck(OK)
    Receiving --> Validating : Central writes OtaEnd / Send OtaAck(OK)
    Receiving --> Aborted : Data Error or Timeout / Send OtaAck(Error)

    Validating --> Committing : Validation OK (e.g., SHA-256 hash matches) / Send OtaAck(OK)
    Validating --> Aborted : Validation Failed / Send OtaAck(VALIDATION_FAILED)

    Committing --> Completed : Commit OK
    Committing --> Aborted : Commit Failed / Send OtaAck(COMMIT_FAILED)

    Aborted --> Idle : Reset OTA State

    Completed --> [*] : Reboot Device
```

### State Machine Flow Description
* **Idle:** Waits for a command. Can handle an `OtaRequestInfo` by responding with its capabilities (including supported update types) and returning to Idle, or can handle an `OtaStart` to begin the update.
* **Starting:** Has received an `OtaStart` command. It validates all metadata, including the `update_type`, `product_id`, and `ota_scheme_version`. If valid, it sends an `OtaAck(OK)` and moves to `Receiving`. If not, it sends an `OtaAck` with an error and aborts.
* **Receiving:** Receives `OtaData` packets and writes them to the correct OTA partition based on the `update_type` received in the `OtaStart` command.
* **Validating, Committing, Completed, Aborted:** These states function as previously described.

## Unified OTA Message Sequence

```mermaid
sequenceDiagram
    participant Central
    participant Peripheral

    note over Central, Peripheral: App connects to device.
    
    Central->>Peripheral: OtaControl(request_info_payload)
    Peripheral-->>Central: OtaInfoResponse {..., supported_update_types: [FIRMWARE_APP, FILESYSTEM]}
    
    note over Central: App sees that FILESYSTEM updates are supported and decides to proceed.

    Central->>Peripheral: OtaControl(start_payload {update_type: FILESYSTEM, ...})
    
    alt Peripheral Accepts OTA Start
        Peripheral-->>Central: OtaAck(OK)
        
        loop For each data chunk
            Central->>Peripheral: OtaData(chunk_num, chunk)
            
            alt Chunk transfer successful
                Peripheral-->>Central: OtaAck(OK, received_chunk_num=chunk_num)
            else Chunk transfer failed (e.g., CRC error)
                Peripheral-->>Central: OtaAck(CRC_MISMATCH, received_chunk_num=chunk_num)
                note over Central: Central retries sending the failed chunk.
            end
        end
        
        Central->>Peripheral: OtaControl(end_payload)
        Peripheral-->>Central: OtaAck(OK)
        
        note over Peripheral: Validates full filesystem image using SHA-256 hash.
    
        alt Validation & Commit Successful
            Peripheral-->>Central: OtaAck(OK, "Validation OK, Committing")
            note over Peripheral: Commits filesystem update and prepares for reboot.
        else Validation or Commit Failed
            Peripheral-->>Central: OtaAck(VALIDATION_FAILED)
        end

    else Peripheral Rejects OTA Start
        Peripheral-->>Central: OtaAck(INCORRECT_PRODUCT or UNSUPPORTED_UPDATE_TYPE)
        note over Central: Aborts OTA.
    end
```

## Protocol Extensibility for Cloud OTA

This document defines a **local transport protocol** for transferring a firmware image over BLE. The source of the image (local file vs. cloud download) is handled by the Central (mobile app).

This design cleanly separates the `Cloud -> Phone` transfer from the `Phone -> Device` transfer.
