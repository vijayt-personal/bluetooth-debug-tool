# BLE OTA Update Design (Simplified Transfer Focus)

## Overview

This design implements a robust, packet-validated OTA (Over-The-Air) firmware update process over BLE. It assumes the underlying BLE link is secure and focuses on the protocol for reliably transferring the firmware image. The peripheral exposes a GATT service with three characteristics and communicates using a structured Protobuf format wrapped with framing.

* **Target Chip**: ESP32 (example)
* **Update Type**: Full Application Firmware Update

## BLE GATT Structure

| Characteristic | UUID | Properties | Direction | Description |
|---|---|---|---|---|
| **Control Point** | `0xFFF1` | Write With Response | Central → Peripheral | Start, End, Abort, Info commands |
| **Data Transfer** | `0xFFF2` | Write Without Response | Central → Peripheral | Stream firmware chunks |
| **Status / Progress** | `0xFFF3` | Notify | Peripheral → Central | ACKs and Responses |

## Packet Framing

Each message is framed for integrity, synchronization, and type identification before protobuf parsing.

| Start Byte (1B) | Message Type (1B) | Length (4B) | Payload (Protobuf) | CRC32 (4B) | End Byte (1B) |
|---|---|---|---|---|---|
| `0xAA` | *Type* | *Length* | *Payload* | *CRC* | `0xDD` |

* **Start Byte (1B):** Constant `0xAA` for synchronization.
* **Message Type (1B):** An enum defining the type of the protobuf payload (e.g., `0x01`=OtaControl, `0x02`=OtaData, `0x03`=OtaAck, `0x04`=OtaInfoResponse).
* **Length (4B):** The length of the `Payload` field only. A 4-byte length is generous; 2 bytes may be sufficient depending on MTU.
* **Payload (Variable):** The protobuf-encoded message.
* **CRC32 (4B):** Computed on `Message Type` + `Length` + `Payload`.
* **End Byte (1B):** Constant `0xDD` for frame validation.
* **Total Frame Overhead:** 11 bytes.

## Protobuf Definition (nanopb Optimized)

With the message type defined in the frame, the top-level `OtaMessage` wrapper is no longer needed. The individual messages are now the payloads. The package name `local_ota` clarifies that this specific protocol is for direct, local transfers.

```proto
syntax = "proto3";

package local_ota;

enum OtaStatus {
    OK = 0;
    ERROR = 1;
    INVALID_HEADER = 2;
    CRC_MISMATCH = 3;
    UNSUPPORTED_COMMAND = 4;
    TIMEOUT = 5;
    INVALID_SEQUENCE = 6;
    VALIDATION_FAILED = 7;
    COMMIT_FAILED = 8;
    INVALID_PAYLOAD = 9;
    INCORRECT_PRODUCT = 10;
    UNSUPPORTED_SCHEME = 11;
}

// === Control Messages (Central -> Peripheral) ===
message OtaStart {
    uint32 image_size = 1;
    string fw_version = 2;          // e.g., "1.2.3"
    string hw_version = 3;          // e.g., "1.1"
    uint32 product_id = 4;          // Unique ID for the product type
    uint32 ota_scheme_version = 5;  // Version of this OTA protocol itself
    bytes signature = 6;            // For future use: cryptographic signature
}

message OtaEnd {
    uint32 total_chunks = 1;
    bytes image_hash = 2;           // e.g., SHA-256 hash of the full image
}

message OtaAbort {
    OtaStatus reason_code = 1;
    string message = 2;
}

message OtaRequestInfo {}

message OtaControl {
    oneof control_msg {
        OtaStart start_payload = 1;
        OtaEnd end_payload = 2;
        OtaAbort abort_payload = 3;
        OtaRequestInfo request_info_payload = 4;
    }
}

// === Data Transfer Message (Central -> Peripheral) ===
message OtaData {
    uint32 chunk_num = 1;
    bytes chunk = 2;
}

// === Response Messages (Peripheral -> Central) ===
message OtaAck {
    OtaStatus status = 1;
    string message = 2;
    uint32 received_chunk_num = 3; // For DATA_ACK
}

message OtaInfoResponse {
    string current_fw_version = 1;
    string hw_version = 2;
    uint32 product_id = 3;
    uint32 supported_ota_scheme_version = 4;
}
```

## Nanopb Implementation Note

For a safe implementation with `nanopb`, it's highly recommended to specify a maximum size for all `bytes` and `string` fields. This generates static arrays instead of memory-managed callback fields.

```
# local_ota.options
local_ota.OtaData.chunk max_size:492
local_ota.OtaStart.signature max_size:64
local_ota.OtaStart.fw_version max_size:16
local_ota.OtaStart.hw_version max_size:16
local_ota.OtaEnd.image_hash max_size:32
local_ota.OtaAbort.message max_size:32
local_ota.OtaInfoResponse.current_fw_version max_size:16
local_ota.OtaInfoResponse.hw_version max_size:16
local_ota.OtaAck.message max_size:32
```

## Protocol Extensibility for Cloud OTA

This document defines a **local transport protocol** for transferring a firmware image over BLE. It does not define how the image is obtained by the Central (e.g., the mobile app). This modularity allows for different update sources:

* **Local OTA:** The user downloads a `.bin` file to their phone and uses the app to push it to the device using this protocol.
* **Cloud-based OTA:**
    1.  The mobile app authenticates with a cloud service.
    2.  It checks for new firmware updates for the connected device.
    3.  If an update is available, the app downloads the firmware image from the cloud (e.g., via HTTPS from a storage bucket).
    4.  Once the image is downloaded to the phone, the app then acts as a Central and uses this **exact same local BLE OTA protocol** to transfer the image from the phone to the device.

This design cleanly separates the `Cloud -> Phone` transfer from the `Phone -> Device` transfer.

## BLE Performance: MTU, Block Size, and Throughput

### MTU and Data Length

* **MTU (Maximum Transmission Unit):** The maximum size of an ATT packet, negotiated between the Central and Peripheral. The default is 23 bytes. Let's assume an MTU of **512 bytes** is successfully negotiated for maximum speed.
* **ATT Overhead:** Each GATT operation (`Write Without Response` or `Notify`) uses 3 bytes for its own header (Opcode + Handle).
* **Data Length:** The maximum amount of application data per BLE packet is `ATT_MTU - 3`. For an MTU of 512, this is **509 bytes**.
* **Note on MTU Choice:** While a 512-byte MTU offers the best speed, it requires the peripheral (ESP32) to allocate larger memory buffers for the BLE stack. This is a critical trade-off to consider, as it reduces available RAM for other application tasks. An MTU of 247 is a common alternative that provides a good balance of speed and memory stability.

### Block Size (Chunk Size)

The `Block Size` refers to the size of the `OtaData.chunk` field. It must be small enough to fit within a single BLE packet along with the protocol framing.

* **Frame Overhead:** 11 bytes (as defined in Packet Framing).
* **Protobuf Overhead:** For `OtaData`, we have the `chunk_num` field (a `uint32` varint, ~1-5 bytes) plus field tags. Let's estimate **6 bytes**.
* **Calculation:** `Max Data per Packet - Frame Overhead - Protobuf Overhead = Chunk Size`
* **Example:** `509 bytes - 11 bytes - 6 bytes =` **492 bytes**. A `max_size` of **492 bytes** is a reasonable choice.

### Throughput and Time Estimation

The fastest OTA method uses `Write Without Response` from the Central and `Notify` from the Peripheral for ACKs.

* **Connection Interval:** The time between connection events. A short interval (e.g., **7.5ms**) is needed for high speed.
* **Packets per Interval:** Modern BLE stacks can often send multiple packets per connection interval. Let's assume an average of **4 packets per interval** is achievable.
* **Packets per Second:** `(1000ms / 7.5ms) * 4 packets = ~533 packets/sec`
* **Throughput (Theoretical):** `533 packets/sec * 492 bytes/chunk = ~262 KB/s`
* **Real-World Throughput:** Due to RF interference, OS scheduling, and other overhead, a realistic throughput is often **50-70%** of the theoretical maximum. Let's assume **~150 KB/s**.
* **Estimated Time for 6MB Image:**
  * `6 * 1024 * 1024 bytes = 6,291,456 bytes`
  * `6,291,456 bytes / (150 * 1024 bytes/s) = ~41 seconds`
  * **Result:** A 6MB OTA update would take approximately **40-50 seconds** under ideal conditions with a large MTU.

## OTA State Machine (Peripheral)

```mermaid
stateDiagram-v2
    [*] --> Idle
    
    Idle: Waiting for OTA initiation.
    Starting: Processing START command. Validating metadata.
    Receiving: Receiving firmware data chunks.
    Validating: All data received. Validating full image integrity.
    Committing: Writing firmware to flash and preparing for reboot.
    Aborted: OTA process aborted due to error or explicit command.
    Completed: OTA successful. Device reboots.

    Idle --> Starting : Central writes OtaControl(start_payload)
    Idle --> Idle : Central writes OtaControl(request_info_payload) / Sends OtaInfoResponse

    Starting --> Receiving : Valid START / Send OtaAck(OK)
    Starting --> Aborted : Invalid START (e.g., wrong product_id) / Send OtaAck(Error)
    
    Receiving --> Receiving : Central writes OtaData(chunk) / Send OtaAck(OK)
    Receiving --> Validating : Central writes OtaControl(end_payload) / Send OtaAck(OK)
    Receiving --> Aborted : Data Error or Timeout / Send OtaAck(Error)

    Validating --> Committing : Validation OK (e.g., SHA-256 hash matches) / Send OtaAck(OK)
    Validating --> Aborted : Validation Failed / Send OtaAck(VALIDATION_FAILED)

    Committing --> Completed : Commit OK
    Committing --> Aborted : Commit Failed / Send OtaAck(COMMIT_FAILED)

    Aborted --> Idle : Reset OTA State

    Completed --> [*] : Reboot Device
```

## Unified OTA Message Sequence

This diagram shows the complete OTA flow, from capability discovery through to firmware transfer.

```mermaid
sequenceDiagram
    participant Central
    participant Peripheral

    note over Central, Peripheral: App connects to device.
    
    Central->>Peripheral: OtaControl(request_info_payload)
    Peripheral-->>Central: OtaInfoResponse {current_fw_version, hw_version, product_id, supported_ota_scheme_version}
    
    note over Central: App checks info and decides to proceed.

    Central->>Peripheral: OtaControl(start_payload)
    
    alt Peripheral Accepts OTA Start
        Peripheral-->>Central: OtaAck(OK)
        
        loop For each data chunk
            Central->>Peripheral: OtaData(chunk_num, chunk)
            
            alt Chunk transfer successful
                Peripheral-->>Central: OtaAck(OK, received_chunk_num=chunk_num)
            else Chunk transfer failed (e.g., CRC error)
                Peripheral-->>Central: OtaAck(CRC_MISMATCH, received_chunk_num=chunk_num)
                note over Central: Central retries sending the failed chunk.
            end
        end
        
        Central->>Peripheral: OtaControl(end_payload)
        Peripheral-->>Central: OtaAck(OK)
        
        note over Peripheral: Validates full image using SHA-256 hash.
    
        alt Validation & Commit Successful
            Peripheral-->>Central: OtaAck(OK, "Validation OK, Committing")
            note over Peripheral: Commits firmware and prepares for reboot.
        else Validation or Commit Failed
            Peripheral-->>Central: OtaAck(VALIDATION_FAILED)
        end

    else Peripheral Rejects OTA Start
        Peripheral-->>Central: OtaAck(INCORRECT_PRODUCT or UNSUPPORTED_SCHEME)
        note over Central: Aborts OTA.
    end
