/**
 * @file semver.h
 * @brief Defines the SemVer class for parsing and comparing semantic version strings.
 */

#ifndef SEMVER_H_
#define SEMVER_H_

#include <compare>
#include <optional>
#include <string>
#include <string_view>

/**
 * @class SemVer
 * @brief A class to parse, validate, and compare semantic version strings
 * according to the Semantic Versioning 2.0.0 specification.
 *
 * This class handles parsing of version strings into major, minor, patch,
 * pre-release, and build metadata components. It provides robust, type-safe
 * comparison and validation. Invalid version strings are handled gracefully
 * and can be identified using the IsValid() method.
 */
class SemVer {
 public:
  /**
   * @brief Constructs a SemVer object from a version string.
   * @param version_string The version string to parse (e.g., "1.2.3-rc.1+build.42").
   */
  explicit SemVer(std::string_view version_string);

  /**
   * @brief Checks if the original string was successfully parsed as a valid
   * semantic version.
   * @return True if the version string is valid SemVer 2.0.0, false otherwise.
   */
  bool IsValid() const;

  /**
   * @brief Returns the original, verbatim string used to construct the object.
   * @return A const reference to the original version string.
   */
  const std::string& GetOriginalString() const;

  /**
   * @brief Returns a clean, normalized string representation of the parsed version.
   * @details If parsing was successful, a normalized string is generated from the
   * components (e.g., "1.2" becomes "1.2.0"). If parsing failed,
   * this returns the original, invalid string.
   * @return The normalized version string.
   */
  std::string ToString() const;

  /**
   * @brief Three-way comparison operator.
   * @details Compares two SemVer objects based on SemVer 2.0.0 precedence rules.
   * Build metadata is ignored for comparison. A valid SemVer object is
   * always considered greater than an invalid one.
   * @param other The SemVer object to compare against.
   * @return A std::strong_ordering value.
   */
  auto operator<=>(const SemVer& other) const;

  /**
   * @brief Equality comparison operator.
   * @param other The SemVer object to compare against.
   * @return True if the versions are equal in precedence, false otherwise.
   */
  bool operator==(const SemVer& other) const;

  // Parsed version components. These members will only contain values if
  // IsValid() returns true. They are public for easy access after validation.
  std::optional<int> major;
  std::optional<int> minor;
  std::optional<int> patch;
  std::optional<std::string_view> pre_release_tag;
  std::optional<std::string_view> build_metadata;

 private:
  /**
   * @brief Performs a SemVer-compliant comparison of two pre-release tags.
   * @param left The left-hand side pre-release tag.
   * @param right The right-hand side pre-release tag.
   * @return A std::strong_ordering value based on precedence rules.
   */
  static std::strong_ordering ComparePreReleaseTags(
      const std::optional<std::string_view>& left,
      const std::optional<std::string_view>& right);

  std::string original_string_;
  bool is_valid_semver_ = false;
};

#endif  // SEMVER_H_

-------------------

#include "semver.h"

#include <algorithm>
#include <charconv>
#include <system_error>
#include <tuple>
#include <vector>

SemVer::SemVer(std::string_view version_string)
    : original_string_(version_string) {
  if (version_string.empty()) {
    return;
  }

  std::string_view main = version_string;

  // Isolate build metadata first (part after '+').
  if (auto pos = main.find('+'); pos != std::string_view::npos) {
    build_metadata = main.substr(pos + 1);
    main = main.substr(0, pos);
  }

  // Isolate pre-release tag (part after '-').
  if (auto pos = main.find('-'); pos != std::string_view::npos) {
    pre_release_tag = main.substr(pos + 1);
    main = main.substr(0, pos);
  }

  std::vector<std::string_view> parts;
  parts.reserve(3);
  size_t start = 0;
  for (size_t i = 0; i <= main.length(); ++i) {
    if (i == main.length() || main[i] == '.') {
      std::string_view part = main.substr(start, i - start);
      if (part.empty()) return;                               // Malformed: "1..2"
      if (part.length() > 1 && part[0] == '0') return;       // Malformed: "1.02.3"
      parts.push_back(part);
      start = i + 1;
    }
  }

  if (parts.size() > 3 || parts.empty()) {
    return;  // Must have 1, 2, or 3 parts.
  }

  int temp_major, temp_minor = 0, temp_patch = 0;

  if (std::from_chars(parts[0].data(), parts[0].data() + parts[0].size(),
                      temp_major)
          .ec != std::errc())
    return;
  if (parts.size() >= 2 &&
      std::from_chars(parts[1].data(), parts[1].data() + parts[1].size(),
                      temp_minor)
              .ec != std::errc())
    return;
  if (parts.size() == 3 &&
      std::from_chars(parts[2].data(), parts[2].data() + parts[2].size(),
                      temp_patch)
              .ec != std::errc())
    return;

  // Success! Assign values and set validity flag.
  major = temp_major;
  minor = temp_minor;
  patch = temp_patch;
  is_valid_semver_ = true;
}

bool SemVer::IsValid() const { return is_valid_semver_; }

const std::string& SemVer::GetOriginalString() const {
  return original_string_;
}

std::string SemVer::ToString() const {
  if (!is_valid_semver_) {
    return original_string_;
  }
  std::string result = std::to_string(major.value()) + "." +
                       std::to_string(minor.value()) + "." +
                       std::to_string(patch.value());
  if (pre_release_tag) {
    result += "-";
    result.append(*pre_release_tag);
  }
  if (build_metadata) {
    result += "+";
    result.append(*build_metadata);
  }
  return result;
}

auto SemVer::operator<=>(const SemVer& other) const {
  if (is_valid_semver_ != other.is_valid_semver_) {
    return is_valid_semver_ <=> other.is_valid_semver_;
  }

  if (!is_valid_semver_) {
    return original_string_ <=> other.original_string_;
  }

  // Both are valid, proceed with full SemVer comparison.
  if (auto comp =
          std::tie(major, minor, patch) <=>
          std::tie(other.major, other.minor, other.patch);
      comp != 0) {
    return comp;
  }

  return ComparePreReleaseTags(pre_release_tag, other.pre_release_tag);
}

bool SemVer::operator==(const SemVer& other) const {
  return (*this <=> other) == 0;
}

std::strong_ordering SemVer::ComparePreReleaseTags(
    const std::optional<std::string_view>& left,
    const std::optional<std::string_view>& right) {
  if (left && !right) return std::strong_ordering::less;
  if (!left && right) return std::strong_ordering::greater;
  if (!left && !right) return std::strong_ordering::equal;

  auto split = [](std::string_view strv, std::vector<std::string_view>& out) {
    size_t start = 0;
    for (size_t i = 0; i <= strv.length(); ++i) {
      if (i == strv.length() || strv[i] == '.') {
        out.push_back(strv.substr(start, i - start));
        start = i + 1;
      }
    }
  };

  std::vector<std::string_view> left_parts, right_parts;
  split(*left, left_parts);
  split(*right, right_parts);

  size_t common_count = std::min(left_parts.size(), right_parts.size());
  for (size_t i = 0; i < common_count; ++i) {
    const auto& l_part = left_parts[i];
    const auto& r_part = right_parts[i];

    if (l_part == r_part) continue;

    unsigned long long l_num, r_num;
    bool l_is_num =
        std::from_chars(l_part.data(), l_part.data() + l_part.size(), l_num)
            .ec == std::errc();
    bool r_is_num =
        std::from_chars(r_part.data(), r_part.data() + r_part.size(), r_num)
            .ec == std::errc();

    if (l_is_num && r_is_num) return l_num <=> r_num;
    if (l_is_num) return std::strong_ordering::less;
    if (r_is_num) return std::strong_ordering::greater;
    return l_part <=> r_part;
  }

  return left_parts.size() <=> right_parts.size();
}
