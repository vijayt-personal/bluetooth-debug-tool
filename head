// ... previous includes and constants ...

/**
 * @class HttpsClient
 * @brief Provides a C++ wrapper for HTTPS communication, abstracting the underlying implementation.
 *
 * Handles GET, POST, PUT, PATCH, HEAD requests with optional server verification.
 * Supports persistent connections and streaming via callbacks for request/response bodies (not applicable for HEAD).
 * Uses fixed-size buffers (defined by constexpr limits) for URL construction and header processing
 * to minimize heap usage within the wrapper. A temporary std::vector (heap) is used
 * internally for the chunk buffer during streaming uploads.
 * Follows Google C++ Style naming conventions.
 * The header file is platform-agnostic.
 *
 * @note Network operations performed by this client are BLOCKING the calling task.
 * For non-blocking application behavior, instantiate and call HttpsClient methods
 * from a dedicated FreeRTOS task.
 * @warning Uses std::vector for stream upload buffer; heap allocation failure during
 * its resize() operation will likely cause program termination (abort) in typical
 * embedded builds where C++ exceptions are disabled (`-fno-exceptions`). Ensure sufficient
 * heap is available.
 */
class HttpsClient {
public:
  /**
   * @brief Status codes returned by HttpsClient methods and callbacks. Platform-agnostic.
   */
  enum class Status {
    kOk = 0,             ///< Operation successful.
    kFail,               ///< Generic failure.
    kInvalidArgument,    ///< Invalid argument provided to the HttpsClient method.
    kNotInitialized,     ///< Client handle is not initialized (Open not called or failed/closed).
    kAlreadyInitialized, ///< Open() called when already open.
    kNoMemory,           ///< Memory allocation failed (e.g., from underlying libs or internal vector).
    kTimeout,            ///< Operation timed out.
    kNetworkError,       ///< Lower-level network error (DNS, TCP, socket, etc.).
    kConnectionError,    ///< Failed to establish connection or connection lost.
    kTlsError,           ///< TLS handshake or encryption/decryption error.
    kHttpError,          ///< HTTP protocol error (parsing, redirects handled internally, etc.).
    kResponseError,      ///< Error indicated by HTTP status code (e.g., 4xx, 5xx). (Method might still return kOk)
    kStreamError,        ///< Error during request or response streaming (e.g., callback error, unexpected EOF).
    kBufferTooSmall,     ///< Provided buffer/limit was too small (e.g., URL length, Header length).
    kUnsupported         ///< Feature or operation not supported by the implementation.
  };

  /**
   * @brief Standard HTTP methods supported by the client. Platform-agnostic.
   */
  enum class HttpMethod {
      kGet,
      kPost,
      kPut,
      kPatch,
      kHead // Added HEAD method
      // Add kDelete, kOptions etc. here if needed and implemented
  };

  /**
   * @brief Callback function type for receiving response body data in chunks.
   * @param data Pointer to the data chunk received. Not null-terminated. May not be valid after callback returns.
   * @param len Length of the data chunk in bytes.
   * @param user_context User-provided context pointer (from Config::user_context).
   * @return HttpsClient::Status Should return HttpsClient::Status::kOk on success.
   * Returning any other status will signal an error and attempt to abort the request.
   */
  using DataReceivedCallback =
      std::function<Status(const char* data, size_t len, void* user_context)>;

  /**
   * @brief Callback function type for providing request body data in chunks for streaming uploads.
   * @param buffer Buffer to write the chunk data into.
   * @param max_len Maximum number of bytes that can be written into the buffer (equals configured TX buffer size).
   * @param user_context User-provided context pointer (from Config::user_context).
   * @return int The number of bytes written into the buffer (must be <= max_len).
   * Return 0 to indicate the end of data (EOF). All data specified by Content-Length must have been sent.
   * Return a negative value to indicate an error condition, which will abort the upload.
   */
  using DataProviderCallback =
      std::function<int(char* buffer, size_t max_len, void* user_context)>;


  /**
   * @brief Configuration structure used when calling Open(). Contains platform-agnostic settings.
   */
  struct Config {
    /** @brief RX buffer size for underlying implementation. Affects max chunk size for received data/headers. Must be > 0. */
    size_t buffer_size_rx_bytes;
    /** @brief TX buffer size for underlying implementation. Affects stream upload chunk buffer size. Must be > 0. */
    size_t buffer_size_tx_bytes;
    /** @brief Set to true to enable server certificate verification (recommended). */
    bool verify_server = true;
    /** @brief Pointer to the server's root CA certificate(s) in PEM format (required if verify_server is true). Null otherwise. String must persist. */
    const char* server_cert_pem = nullptr;
    /** @brief Connection and request timeout in milliseconds. */
    int timeout_ms = 10000;
    /** @brief TCP Keep-Alive idle time in seconds before sending probes. */
    int keep_alive_idle_sec = 5;
    /** @brief TCP Keep-Alive interval in seconds between probes. */
    int keep_alive_interval_sec = 5;
    /** @brief TCP Keep-Alive number of probes before timing out. */
    int keep_alive_count = 3;
    /** @brief Optional user context pointer passed unmodified to all callbacks. */
    void* user_context = nullptr;
  };

  /**
   * @brief Structure to hold response information obtained after a request.
   */
  struct ResponseInfo {
      /** @brief HTTP status code returned by the server (e.g., 200, 404). */
      int status_code = 0;
      /** @brief Content-Length value from the response headers (-1 if not present or chunked). */
      long long content_length = -1; // For HEAD, this should indicate the size of the body IF a GET were performed
      /** @brief Flag indicating if the server sent a 'Connection: close' header. */
      bool connection_close = false;
      // Add other relevant headers if needed, e.g., Content-Type, Last-Modified for HEAD
      // std::string content_type;
      // std::string last_modified;
  };

  /** @brief Type alias for HTTP request headers map. Keys/Values should be valid views. */
  using Headers = std::map<std::string_view, std::string_view>;

  /**
   * @brief Default constructor. Initializes the client state.
   */
  HttpsClient();

  /**
   * @brief Destructor. Ensures resources are released by calling Close().
   */
  ~HttpsClient();

  // Disable copy/move semantics to prevent issues with resource handling.
  HttpsClient(const HttpsClient&) = delete;
  HttpsClient& operator=(const HttpsClient&) = delete;
  HttpsClient(HttpsClient&&) = delete;
  HttpsClient& operator=(HttpsClient&&) = delete;

  // --- Public API ---

  /**
   * @brief Initializes the client, allocates underlying resources based on the platform. BLOCKING.
   * @param config Configuration settings for this client instance. Buffer sizes must be specified.
   * @return Status::kOk on success, appropriate error status otherwise.
   */
  Status Open(const Config& config);

  /**
   * @brief Closes any open connection and releases all associated resources. BLOCKING (potentially).
   * Safe to call even if already closed or never opened.
   * @return Status::kOk on success (even if already closed), appropriate error status on cleanup failure.
   */
  Status Close();

  /**
   * @brief Performs an HTTP GET request using the full URL. BLOCKING.
   * @param url The **full** URL for the request (e.g., "https://example.com/data"). Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers. Keys/Values must be <= respective max length constants.
   * @param on_data_received Callback function for response body chunks. Can be nullptr if body is ignored.
   * @param response_info Optional pointer to store response details (status code, content length).
   * @return Status::kOk if the request cycle completed without transport/protocol errors. Check response_info->status_code for HTTP success (2xx).
   */
  Status Get(std::string_view url, const Headers& headers,
             DataReceivedCallback on_data_received,
             ResponseInfo* response_info = nullptr);

  /**
   * @brief Performs an HTTP HEAD request using the full URL. BLOCKING.
   * Response body is not expected or processed.
   * @param url The **full** URL for the request. Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers. Keys/Values must be <= respective max length constants.
   * @param response_info Optional pointer to store response details (status code, content length, other headers).
   * @return Status::kOk if the request cycle completed without transport/protocol errors. Check response_info->status_code for HTTP success (2xx).
   */
  Status Head(std::string_view url, const Headers& headers,
              ResponseInfo* response_info = nullptr);

  /**
   * @brief Performs an HTTP POST request using the full URL. BLOCKING.
   * @param url The **full** URL for the request. Must be <= kHttpsClientMaxUrlLength.
   * @param headers Map of additional request headers (should include 'Content-Type'). Keys/Values must be <= respective max length constants.
   * @param post_data The entire request body data.
   * @param on_data_received Callback for response body chunks (can be nullptr).
   * @param response_info Optional pointer to store response details.
   * @return Status::kOk if request cycle completed, check response_info->status_code for HTTP success.
   */
  Status Post(std::string_view url, const Headers& headers,
              std::string_view post_data,
              DataReceivedCallback on_data_received,
              ResponseInfo* response_info = nullptr);

// ... rest of the HttpsClient class declaration (Put, Patch, PostStream, PutStream, etc.)
// ... private members and helpers ...
};

#endif // HTTPS_CLIENT_H

----------------------------

  // ... previous includes ...
#include "https_client.h" // Include the platform-agnostic header

#include <cstring> // For memcpy, strlen, strcasecmp
#include <cstdio>  // For snprintf
#include <array>   // For stack arrays for headers/URL
#include <vector>  // For temporary chunk buffer (heap allocated)
#include <new>     // For std::nothrow (though not needed for client_handle_ alloc)

// --- ESP-IDF Specific Includes ---
#include "esp_http_client.h"
#include "esp_log.h"
#include "esp_err.h"
#include "errno.h" // Potentially useful for more detailed socket errors

// Logging Tag
static const char* TAG = "HttpsClient";

// --- Platform Specific Mappings and Definitions ---

/**
 * @brief Maps the platform-agnostic HttpsClient::HttpMethod to the ESP-IDF specific esp_http_client_method_t.
 * @param method The HttpsClient::HttpMethod value.
 * @return The corresponding esp_http_client_method_t value. Defaults to GET for unknown values.
 */
static esp_http_client_method_t MapHttpMethodToEspMethod(HttpsClient::HttpMethod method) {
    switch (method) {
        case HttpsClient::HttpMethod::kGet:    return HTTP_METHOD_GET;
        case HttpsClient::HttpMethod::kPost:   return HTTP_METHOD_POST;
        case HttpsClient::HttpMethod::kPut:    return HTTP_METHOD_PUT;
        case HttpsClient::HttpMethod::kPatch:  return HTTP_METHOD_PATCH;
        case HttpsClient::HttpMethod::kHead:  return HTTP_METHOD_HEAD; // Added HEAD
        default:
            ESP_LOGW(TAG, "Unsupported HttpMethod enum value (%d), defaulting to GET.", static_cast<int>(method));
            return HTTP_METHOD_GET;
    }
}

// ... MapEspErrorToStatus, PlatformEventHandler, HttpsClient Constructor, Destructor, Open, Close ...

// --- Private Member Function Implementations ---
// PerformRequestInternal remains largely the same.
// The esp_http_client library handles HEAD requests appropriately
// (i.e., it doesn't expect a body, and PlatformEventHandler won't try to call
// on_data_received if it's nullptr).

HttpsClient::Status HttpsClient::PerformRequestInternal(
                                        std::string_view url,
                                        HttpMethod method,
                                        const Headers& headers,
                                        std::string_view request_body, // Will be empty for HEAD
                                        ResponseInfo* response_info) {
    // Check and cast void* handle
    if (!client_handle_) { ESP_LOGE(TAG,"PerformRequest: Client not open."); return Status::kNotInitialized; }
    esp_http_client_handle_t actual_esp_handle = reinterpret_cast<esp_http_client_handle_t>(client_handle_);
    if (!actual_esp_handle) { ESP_LOGE(TAG,"PerformRequest: Invalid internal handle state."); return Status::kNotInitialized; }

    esp_err_t err = ESP_OK;

    // Copy full URL to C-string buffer on stack
    std::array<char, kHttpsClientMaxUrlLength> url_buffer;
    int written_len = snprintf(url_buffer.data(), url_buffer.size(), "%.*s", (int)url.length(), url.data());
    if (written_len < 0 || (size_t)written_len >= url_buffer.size()) {
         ESP_LOGE(TAG, "PerformRequest: Provided URL exceeds maximum length (%zu).", url_buffer.size() - 1);
         return Status::kBufferTooSmall;
    }

    // Reset response info struct before request
    current_request_ctx_.response_info_ptr = response_info;
    if (response_info != nullptr) {
        response_info->status_code = 0;
        response_info->content_length = -1;
        response_info->connection_close = false;
    }

    // Set URL (using the copied buffer)
    err = esp_http_client_set_url(actual_esp_handle, url_buffer.data());
    if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_url failed: %d", err); return MapEspErrorToStatus(err); }

    // Set Method (using mapped value)
    err = esp_http_client_set_method(actual_esp_handle, MapHttpMethodToEspMethod(method));
    if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_method failed: %d", err); return MapEspErrorToStatus(err); }

    // Set Headers using temporary stack arrays
    std::array<char, kHttpsClientMaxHeaderKeyLen> header_key_buffer;
    std::array<char, kHttpsClientMaxHeaderValueLen> header_value_buffer;
    for (const auto& header_pair : headers) { // Renamed 'header' to 'header_pair' to avoid conflict with esp_http_client.h
        written_len = snprintf(header_key_buffer.data(), header_key_buffer.size(), "%.*s", (int)header_pair.first.length(), header_pair.first.data());
        if (written_len < 0 || (size_t)written_len >= header_key_buffer.size()) { ESP_LOGW(TAG, "Header key truncated: %.*s", (int)header_pair.first.length(), header_pair.first.data()); }
        written_len = snprintf(header_value_buffer.data(), header_value_buffer.size(), "%.*s", (int)header_pair.second.length(), header_pair.second.data());
        if (written_len < 0 || (size_t)written_len >= header_value_buffer.size()) { ESP_LOGW(TAG, "Header value truncated: %.*s", (int)header_pair.second.length(), header_pair.second.data()); }

        err = esp_http_client_set_header(actual_esp_handle, header_key_buffer.data(), header_value_buffer.data());
        if (err != ESP_OK) { ESP_LOGE(TAG, "Failed to set header '%s': %d", header_key_buffer.data(), err); return MapEspErrorToStatus(err); }
    }

    // For HEAD requests, request_body will be empty, so esp_http_client_set_post_field is not called.
    // For other methods like POST, PUT, PATCH with empty bodies:
    if (!request_body.empty()) {
         err = esp_http_client_set_post_field(actual_esp_handle, request_body.data(), request_body.length());
         if (err != ESP_OK) { ESP_LOGE(TAG, "esp_http_client_set_post_field failed: %d", err); return MapEspErrorToStatus(err); }
         // Ensure Content-Type is set if not already present for POST/PUT/PATCH with body
          // For HEAD, this block is skipped.
         if (method == HttpMethod::kPost || method == HttpMethod::kPut || method == HttpMethod::kPatch) {
            char* ct_header = nullptr;
            if (esp_http_client_get_header(actual_esp_handle, "Content-Type", &ct_header) != ESP_OK) {
                  ESP_LOGD(TAG, "PerformRequest: Setting default Content-Type for non-empty body.");
                  esp_http_client_set_header(actual_esp_handle, "Content-Type", "application/octet-stream");
            }
        }
    } else if (method == HttpMethod::kPost || method == HttpMethod::kPut || method == HttpMethod::kPatch) {
        // Handle POST/PUT/PATCH with empty body (e.g., set Content-Length: 0 if not already set)
        char* cl_header = nullptr; char* te_header = nullptr;
        bool cl_present = esp_http_client_get_header(actual_esp_handle, "Content-Length", &cl_header) == ESP_OK;
        bool te_present = esp_http_client_get_header(actual_esp_handle, "Transfer-Encoding", &te_header) == ESP_OK;
        // Only set Content-Length: 0 if neither Content-Length nor Transfer-Encoding are present.
        if (!cl_present && !te_present) {
            ESP_LOGD(TAG, "PerformRequest: Setting Content-Length: 0 for empty body on POST/PUT/PATCH.");
            esp_http_client_set_header(actual_esp_handle, "Content-Length", "0");
        }
    }
    // Note: For GET and HEAD, request_body is empty, and the above conditions for POST/PUT/PATCH are not met.
    // The esp_http_client does not require Content-Length for GET/HEAD.

    // Perform request
    err = esp_http_client_perform(actual_esp_handle);
    Status status = MapEspErrorToStatus(err);

    // If the perform operation itself failed (e.g., connection error), get the underlying esp_err
    if (err != ESP_OK) {
        // Try to get the HTTP status code if the error was after headers were received
        // but before the body was fully processed (less likely for HEAD but good practice).
        // If response_info is available, populate it.
        if (response_info != nullptr && actual_esp_handle != nullptr) {
            response_info->status_code = esp_http_client_get_status_code(actual_esp_handle); // May be 0 or an error code
            response_info->content_length = esp_http_client_get_content_length(actual_esp_handle); // May be -1
        }
        ESP_LOGE(TAG, "PerformRequest failed: %s. ESP-IDF err: %d (%s). HTTP Status: %d",
                 StatusToString(status), err, esp_err_to_name(err),
                 (response_info != nullptr) ? response_info->status_code : esp_http_client_get_status_code(actual_esp_handle));
    } else {
        // Retrieve response info - check pointers before accessing
        if (response_info != nullptr && actual_esp_handle != nullptr) {
             response_info->status_code = esp_http_client_get_status_code(actual_esp_handle);
             response_info->content_length = esp_http_client_get_content_length(actual_esp_handle);
            // Note: For HEAD, content_length should reflect what a GET would have returned.
            // The PlatformEventHandler already populates response_info->connection_close
        }
        // Log final outcome
        if (status == Status::kOk && response_info != nullptr) {
            ESP_LOGI(TAG, "PerformRequest OK - Method: %d, Status: %d, Length: %lld", static_cast<int>(method), response_info->status_code, response_info->content_length);
        } else if (status == Status::kOk) { // response_info was nullptr
            ESP_LOGI(TAG, "PerformRequest OK - Method: %d, Status: %d, Length: %lld", static_cast<int>(method), esp_http_client_get_status_code(actual_esp_handle), esp_http_client_get_content_length(actual_esp_handle));
        }
         // If esp_http_client_perform returned ESP_OK, but the HTTP status code indicates an error (4xx, 5xx)
        // our `status` is kOk. The caller should check response_info->status_code.
        // We could potentially set `status` to `kResponseError` here if desired, but current design returns kOk for transport success.
    }

    current_request_ctx_.response_info_ptr = nullptr; // Clear after use
    return status;
}


// ... PerformStreamUploadInternal ... (remains the same)


// --- Public Method Implementations ---

HttpsClient::Status HttpsClient::Get(std::string_view url, const Headers& headers,
                                     DataReceivedCallback on_data_received,
                                     ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(url, HttpMethod::kGet, headers, "", response_info);
}

HttpsClient::Status HttpsClient::Head(std::string_view url, const Headers& headers,
                                    ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = nullptr; // No body expected for HEAD
    return PerformRequestInternal(url, HttpMethod::kHead, headers, "", response_info);
}

HttpsClient::Status HttpsClient::Post(std::string_view url, const Headers& headers,
                                      std::string_view post_data,
                                      DataReceivedCallback on_data_received,
                                      ResponseInfo* response_info) {
    current_request_ctx_.on_data_received = on_data_received;
    return PerformRequestInternal(url, HttpMethod::kPost, headers, post_data, response_info);
}
// ... Put, Patch, PostStream, PutStream implementations ...

// StatusToString (Fully Implemented - no changes needed)
// ...

---------------------

  #include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"

#include "https_client.h" // Include the final client class
#include <vector>
#include <string>
#include <cstring>
#include <cstdlib> // For std::to_string

static const char* kMainAppTag = "HTTP_BINARY_CHECK";

// Dummy WiFi connection setup (replace with your actual implementation)
static void wifi_init_sta() {
    // Simplified: In a real app, you'd initialize netif, event loop,
    // register event handlers, and connect.
    // This is just to make the example runnable with the assumption of prior connection.
    ESP_LOGI(kMainAppTag, "Assuming WiFi is already connected or will connect shortly.");
    // Example:
    // ESP_ERROR_CHECK(esp_netif_init());
    // ESP_ERROR_CHECK(esp_event_loop_create_default());
    // esp_netif_create_default_wifi_sta();
    // wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    // ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    // ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    // ESP_ERROR_CHECK(esp_wifi_start());
    // wifi_config_t wifi_config = { .sta = { .ssid = "YOUR_SSID", .password = "YOUR_PASSWORD" }};
    // ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config) );
    // ESP_ERROR_CHECK(esp_wifi_connect());
    vTaskDelay(pdMS_TO_TICKS(5000)); // Simulate connection time
}


// Callbacks (only OnDataReceivedCollect used for the subsequent GET example)
HttpsClient::Status OnDataReceivedCollect(const char* data, size_t len, void* user_context) {
    std::string* response_buffer = static_cast<std::string*>(user_context);
    try {
        response_buffer->append(data, len);
    } catch (const std::bad_alloc&) {
        ESP_LOGE(kMainAppTag, "Memory allocation failed in OnDataReceivedCollect");
        return HttpsClient::Status::kNoMemory;
    }
    ESP_LOGD(kMainAppTag, "Collected %zu bytes, total %zu", len, response_buffer->length());
    return HttpsClient::Status::kOk;
}


extern "C" void app_main(void) {
    ESP_ERROR_CHECK(nvs_flash_init());
    ESP_ERROR_CHECK(esp_netif_init()); // Initialize TCP/IP adapter
    ESP_ERROR_CHECK(esp_event_loop_create_default()); // Create default event loop

    wifi_init_sta(); // Connect to WiFi (replace with your actual WiFi setup)
    ESP_LOGI(kMainAppTag, "WiFi Connected (Assumed for example)");

    HttpsClient https_client;
    HttpsClient::Config client_config = {};

    client_config.buffer_size_rx_bytes = 2048;
    client_config.buffer_size_tx_bytes = 1024;
    client_config.verify_server = false; // For simplicity. For production, set to true and provide cert.
                                         // For public URLs like google.com, if verify_server is true,
                                         // ESP-IDF needs the appropriate CA certs in its cert store
                                         // or you provide one via server_cert_pem.
    client_config.timeout_ms = 20000;

    HttpsClient::Status op_status = https_client.Open(client_config);
    if (op_status != HttpsClient::Status::kOk) {
        ESP_LOGE(kMainAppTag, "HttpsClient Open failed: %s", HttpsClient::StatusToString(op_status));
        return;
    }

    // --- Use Case: Get Content-Length of a binary file before downloading ---
    ESP_LOGI(kMainAppTag, "\n*** Use Case: Get Content-Length of a binary file ***");

    // URL of a known binary file (e.g., an image)
    // You can replace this with any binary file URL you want to test.
    const char* binary_url = "https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png";
    // Alternative for testing if google.com is blocked or for specific size: "https://httpbin.org/bytes/10240" (for a 10KB file)

    HttpsClient::ResponseInfo head_resp_info;
    HttpsClient::Headers head_headers = {
        {"User-Agent", "ESP-IDF HttpsClient BinaryCheck/1.0"}
    };

    ESP_LOGI(kMainAppTag, "Performing HEAD request to: %s", binary_url);
    op_status = https_client.Head(binary_url, head_headers, &head_resp_info);

    long long binary_content_length = -1;

    if (op_status == HttpsClient::Status::kOk) {
        ESP_LOGI(kMainAppTag, "HEAD request successful.");
        ESP_LOGI(kMainAppTag, "HTTP Status Code: %d", head_resp_info.status_code);
        ESP_LOGI(kMainAppTag, "Reported Content-Length: %lld bytes", head_resp_info.content_length);
        // You can also inspect other headers if you modify ResponseInfo to store them,
        // e.g., Content-Type, Last-Modified, ETag.
        // ESP_LOGI(kMainAppTag, "Connection Close Header: %s", head_resp_info.connection_close ? "true" : "false");

        if (head_resp_info.status_code == 200) { // 200 OK is typical for successful HEAD
            binary_content_length = head_resp_info.content_length;
            if (binary_content_length > 0) {
                ESP_LOGI(kMainAppTag, "The binary file is reported to be %lld bytes long.", binary_content_length);
                // Now you can make a decision:
                if (binary_content_length > 50000) { // Example threshold: 50KB
                    ESP_LOGW(kMainAppTag, "File size (%lld bytes) exceeds threshold. Skipping download for this example.", binary_content_length);
                } else {
                    ESP_LOGI(kMainAppTag, "File size is acceptable. Proceeding to GET the file (example).");
                    // Placeholder for GET request
                }
            } else if (binary_content_length == 0) {
                ESP_LOGI(kMainAppTag, "The binary file is reported to be 0 bytes long (empty file).");
            } else {
                ESP_LOGW(kMainAppTag, "Content-Length is not positive or not reported, though HEAD was successful.");
            }
        } else {
            ESP_LOGW(kMainAppTag, "HEAD request completed, but HTTP status is %d (not 200 OK). File might not be accessible as expected.", head_resp_info.status_code);
        }
    } else {
        ESP_LOGE(kMainAppTag, "HEAD request failed: %s", HttpsClient::StatusToString(op_status));
        if (head_resp_info.status_code != 0) {
             ESP_LOGE(kMainAppTag, "Underlying HTTP Status Code (if available): %d", head_resp_info.status_code);
        }
    }

    // --- Optional: Proceed to GET the file if size is known and acceptable ---
    if (binary_content_length > 0 && binary_content_length <= 50000) { // Example condition from above
        ESP_LOGI(kMainAppTag, "\n*** Attempting to GET the binary file: %s ***", binary_url);

        std::string file_data_buffer;
        // Optional: Pre-allocate if you are confident about the memory.
        // Be cautious with large files on memory-constrained devices.
        // try {
        //     file_data_buffer.reserve(binary_content_length);
        //     ESP_LOGI(kMainAppTag, "Reserved %lld bytes for file data.", binary_content_length);
        // } catch (const std::bad_alloc& e) {
        //     ESP_LOGE(kMainAppTag, "Failed to reserve memory for file: %s. String will grow dynamically.", e.what());
        // }

        HttpsClient::ResponseInfo get_resp_info;
        HttpsClient::Headers get_headers = {
            {"User-Agent", "ESP-IDF HttpsClient BinaryDownload/1.0"}
        };

        op_status = https_client.Get(binary_url, get_headers,
                                     [&](const char* d, size_t l, void* c){ return OnDataReceivedCollect(d, l, &file_data_buffer); },
                                     &get_resp_info);

        if (op_status == HttpsClient::Status::kOk && get_resp_info.status_code == 200) {
            ESP_LOGI(kMainAppTag, "GET request successful. HTTP Status: %d", get_resp_info.status_code);
            ESP_LOGI(kMainAppTag, "Downloaded %zu bytes. Expected: %lld bytes.", file_data_buffer.length(), binary_content_length);
            ESP_LOGI(kMainAppTag, "Actual Content-Length from GET response: %lld bytes", get_resp_info.content_length);

            // You now have the file content in file_data_buffer
            // For a real binary, you might write it to flash or process it.
            // For this example, just log a small part or confirm size.
            if (file_data_buffer.length() == (size_t)binary_content_length) {
                ESP_LOGI(kMainAppTag, "Downloaded file size matches expected size.");
            } else {
                ESP_LOGW(kMainAppTag, "Downloaded file size (%zu) does NOT match expected size (%lld) from HEAD!", file_data_buffer.length(), binary_content_length);
            }
            // ESP_LOGI(kMainAppTag, "First 16 bytes (hex):");
            // for(size_t i = 0; i < std::min(file_data_buffer.length(), (size_t)16); ++i) {
            //     printf("%02x ", (unsigned char)file_data_buffer[i]);
            // }
            // printf("\n");

        } else {
            ESP_LOGE(kMainAppTag, "GET request failed: %s, HTTP Status: %d", HttpsClient::StatusToString(op_status), get_resp_info.status_code);
        }
    }


    ESP_LOGI(kMainAppTag, "\nClosing client.");
    op_status = https_client.Close();
    if (op_status != HttpsClient::Status::kOk) {
        ESP_LOGE(kMainAppTag, "HttpsClient Close failed: %s", HttpsClient::StatusToString(op_status));
    }

    ESP_LOGI(kMainAppTag, "Binary check example finished.");
}
