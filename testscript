{
    "device_address": "XX:XX:XX:XX:XX:XX",
    "firmware_file": "firmware.bin",
    "product_id": 12345,
    "ota_scheme_version": 1,
    "new_fw_version": "2.0.1",
    "compatible_hw_version": "1.1"
}

--------------------------------------------

# local_ota_pb2.py
# This is a mock version of the file that would be generated by protoc.
# It provides the necessary classes and enums for the simulation.

from google.protobuf.internal import enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from typing import ClassVar, Optional

# --- Enums ---
class OtaStatus:
    OK = 0
    ERROR = 1
    INVALID_HEADER = 2
    CRC_MISMATCH = 3
    UNSUPPORTED_COMMAND = 4
    TIMEOUT = 5
    INVALID_SEQUENCE = 6
    VALIDATION_FAILED = 7
    COMMIT_FAILED = 8
    INVALID_PAYLOAD = 9
    INCORRECT_PRODUCT = 10
    UNSUPPORTED_SCHEME = 11

# --- Message Classes ---
# In a real project, these would be fully-featured classes generated by protoc.
# For this simulation, we create simple classes that have a SerializeToString method.

class OtaStart(_message.Message):
    def __init__(self, image_size=0, fw_version="", hw_version="", product_id=0, ota_scheme_version=0, signature=b''):
        self.image_size = image_size
        self.fw_version = fw_version
        self.hw_version = hw_version
        self.product_id = product_id
        self.ota_scheme_version = ota_scheme_version
        self.signature = signature
    def SerializeToString(self):
        # A real implementation would serialize this to protobuf format.
        # We are keeping it simple for the simulation.
        return b'start_payload'

class OtaEnd(_message.Message):
    def __init__(self, total_chunks=0, image_hash=b''):
        self.total_chunks = total_chunks
        self.image_hash = image_hash
    def SerializeToString(self):
        return b'end_payload'

class OtaRequestInfo(_message.Message):
    def SerializeToString(self):
        return b'request_info_payload'

class OtaControl(_message.Message):
    def __init__(self, start_payload=None, end_payload=None, abort_payload=None, request_info_payload=None):
        self.start_payload = start_payload
        self.end_payload = end_payload
        self.abort_payload = abort_payload
        self.request_info_payload = request_info_payload
    def SerializeToString(self):
        if self.start_payload: return self.start_payload.SerializeToString()
        if self.end_payload: return self.end_payload.SerializeToString()
        if self.request_info_payload: return self.request_info_payload.SerializeToString()
        return b''

class OtaData(_message.Message):
    def __init__(self, chunk_num=0, chunk=b''):
        self.chunk_num = chunk_num
        self.chunk = chunk
    def SerializeToString(self):
        return self.chunk

class OtaAck(_message.Message):
    def __init__(self, status=0, message="", received_chunk_num=0):
        self.status = status
        self.message = message
        self.received_chunk_num = received_chunk_num
    @classmethod
    def FromString(cls, s):
        # A real implementation would parse the protobuf bytes.
        # For simulation, we'll assume any ack is OK.
        return cls(status=OtaStatus.OK, received_chunk_num=1)

class OtaInfoResponse(_message.Message):
    def __init__(self, current_fw_version="1.0.0", hw_version="1.0", product_id=12345, supported_ota_scheme_version=1):
        self.current_fw_version = current_fw_version
        self.hw_version = hw_version
        self.product_id = product_id
        self.supported_ota_scheme_version = supported_ota_scheme_version
    @classmethod
    def FromString(cls, s):
        # For simulation, return a default valid response
        return cls()

------------------------------------------------

# ble_manager.py
import asyncio
from bleak import BleakClient
from bleak.exc import BleakError

class BLEManager:
    """Handles the connection and raw communication for a BLE device."""
    def __init__(self, address):
        self.address = address
        self.client = BleakClient(address)

    async def connect(self):
        """Establishes a connection to the BLE device."""
        try:
            print(f"Attempting to connect to {self.address}...")
            await self.client.connect()
            print(f"Connected: {self.client.is_connected}")
            return self.client.is_connected
        except (BleakError, asyncio.TimeoutError) as e:
            print(f"Error connecting: {e}")
            return False

    async def disconnect(self):
        """Disconnects from the BLE device."""
        if self.client and self.client.is_connected:
            await self.client.disconnect()
            print("Disconnected.")

    async def start_notify(self, uuid, callback):
        """Enables notifications for a characteristic."""
        print(f"Subscribing to notifications on {uuid}...")
        await self.client.start_notify(uuid, callback)

    async def stop_notify(self, uuid):
        """Disables notifications for a characteristic."""
        await self.client.stop_notify(uuid)

    async def write_characteristic(self, uuid, data, with_response=False):
        """Writes data to a characteristic."""
        await self.client.write_gatt_char(uuid, data, response=with_response)

--------------------------------

# ota_protocol.py
import asyncio
import hashlib
import zlib
import os
import local_ota_pb2 as ota_pb

# --- GATT UUIDs and Constants ---
CONTROL_POINT_UUID = "0000fff1-0000-1000-8000-00805f9b34fb"
DATA_TRANSFER_UUID = "0000fff2-0000-1000-8000-00805f9b34fb"
STATUS_PROGRESS_UUID = "0000fff3-0000-1000-8000-00805f9b34fb"

START_BYTE = 0xAA
END_BYTE = 0xDD
CHUNK_SIZE = 492

class MessageType:
    OtaControl = 0x01
    OtaData = 0x02
    OtaAck = 0x03
    OtaInfoResponse = 0x04

class OTAProtocol:
    """Implements the logic for the OTA update protocol."""
    def __init__(self, ble_manager, config):
        self.ble = ble_manager
        self.config = config
        self.last_notification = None
        self.notification_event = asyncio.Event()

    def _build_frame(self, msg_type, protobuf_payload):
        # (This method is identical to the one in the original script)
        payload_bytes = protobuf_payload.SerializeToString()
        length = len(payload_bytes)
        header_payload = msg_type.to_bytes(1, 'little') + length.to_bytes(4, 'little') + payload_bytes
        crc = zlib.crc32(header_payload)
        return (
            START_BYTE.to_bytes(1, 'little') +
            header_payload +
            crc.to_bytes(4, 'little') +
            END_BYTE.to_bytes(1, 'little')
        )

    def notification_handler(self, sender, data):
        """Parses incoming notifications and sets an event."""
        print(f"<- Notif received: {data.hex()}")
        if data[0] != START_BYTE or data[-1] != END_BYTE:
            print("Error: Invalid frame received.")
            return

        msg_type = data[1]
        payload_len = int.from_bytes(data[2:6], 'little')
        payload = data[6:6 + payload_len]

        if msg_type == MessageType.OtaAck:
            self.last_notification = ota_pb.OtaAck.FromString(payload)
            print(f"ACK: Status={self.last_notification.status}, Chunk={self.last_notification.received_chunk_num}")
        elif msg_type == MessageType.OtaInfoResponse:
            self.last_notification = ota_pb.OtaInfoResponse.FromString(payload)
            print(f"Info: FW={self.last_notification.current_fw_version}, HW={self.last_notification.hw_version}")
        
        self.notification_event.set()

    async def _send_and_wait_for_ack(self, frame, description):
        """Sends a command and waits for a notification ACK."""
        self.notification_event.clear()
        print(f"-> {description}")
        await self.ble.write_characteristic(CONTROL_POINT_UUID, frame, with_response=True)
        try:
            await asyncio.wait_for(self.notification_event.wait(), timeout=10.0)
        except asyncio.TimeoutError:
            raise Exception(f"Timeout: No ACK received after sending {description}")

        if not isinstance(self.last_notification, ota_pb.OtaAck) or self.last_notification.status != ota_pb.OtaStatus.OK:
            raise Exception(f"Error: Peripheral sent NACK or invalid response for {description}")
        
        print(f"ACK received for {description}.")

    async def perform_ota(self):
        """Executes the full OTA update process."""
        try:
            # 1. Subscribe to notifications
            await self.ble.start_notify(STATUS_PROGRESS_UUID, self.notification_handler)

            # 2. Start OTA
            firmware_size = os.path.getsize(self.config['firmware_file'])
            start_msg = ota_pb.OtaStart(
                image_size=firmware_size,
                fw_version=self.config['new_fw_version'],
                hw_version=self.config['compatible_hw_version'],
                product_id=self.config['product_id'],
                ota_scheme_version=self.config['ota_scheme_version']
            )
            control_msg = ota_pb.OtaControl(start_payload=start_msg)
            start_frame = self._build_frame(MessageType.OtaControl, control_msg)
            await self._send_and_wait_for_ack(start_frame, "OTA Start")

            # 3. Transfer Firmware Data
            print("--- Starting firmware transfer ---")
            with open(self.config['firmware_file'], 'rb') as f:
                chunk_num = 0
                while True:
                    chunk = f.read(CHUNK_SIZE)
                    if not chunk:
                        break
                    chunk_num += 1
                    data_msg = ota_pb.OtaData(chunk_num=chunk_num, chunk=chunk)
                    frame = self._build_frame(MessageType.OtaData, data_msg)
                    print(f"-> Sending chunk {chunk_num}/{firmware_size // CHUNK_SIZE + 1}")
                    await self.ble.write_characteristic(DATA_TRANSFER_UUID, frame, with_response=False)
                    # Add a small delay to prevent buffer overflow on the peripheral
                    await asyncio.sleep(0.01)
            print("--- Firmware transfer complete ---")

            # 4. End OTA
            with open(self.config['firmware_file'], 'rb') as f:
                image_hash = hashlib.sha256(f.read()).digest()
            end_msg = ota_pb.OtaEnd(total_chunks=chunk_num, image_hash=image_hash)
            control_msg = ota_pb.OtaControl(end_payload=end_msg)
            end_frame = self._build_frame(MessageType.OtaControl, control_msg)
            await self._send_and_wait_for_ack(end_frame, "OTA End")

            print("\nOTA process completed successfully! Peripheral is now validating and committing.")
            return True

        except Exception as e:
            print(f"\nAn error occurred during OTA: {e}")
            return False
        finally:
            await self.ble.stop_notify(STATUS_PROGRESS_UUID)
