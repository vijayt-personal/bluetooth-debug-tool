================ Flash Tool v0.1A command-line interface (CLI) utility for reading, writing, erasing, andverifying MTD (Memory Technology Device) flash chips on embedded Linux systemsbuilt with Yocto.This tool provides two backends for interacting with the MTD subsystem:libmtd: Uses the high-level library from mtd-utils.ioctl: Uses direct low-level ioctl calls, similar to flash_erase, etc.The active backend is selected by editing src/include/config.h before compiling.Table of ContentsFeaturesUsageBuild InstructionsCommand ReferenceSample Usage and OutputFeaturesCompile-Time Backend Selection: Choose between libmtd and ioctl by editing the config.h header file.Optional Device Selection: Specify the target MTD device at launch (e.g., -d /dev/mtd1).Graceful Shutdown: Handles Ctrl+C (SIGINT) and SIGTERM to prevent flash corruption during long operations.Rich Command Set: Supports write, read, erase (sector and chip), and a powerful batched write-verify.Robust Erase: Auto-detects MTD erase size (A type) and handles block locking/unlocking (ioctl backend).Dual Logging: Functional logs for user feedback and controlled logs for debugging.Linux Kernel Coding Style: Code is formatted for readability and maintainability.Usage./flash_tool [-d /dev/mtdX]Options:-d <device>: Optional. Specify the path to the MTD device. If not provided, the default from config.h (e.g., /dev/mtd0) will be used.Build Instructions(Instructions are in the Build System file).Command ReferenceGeneral Commands:help: Displays the help message.clr: Clears the terminal screen.exit: Exits the application.Write Command:flash write <type> <pattern> <sector> <size><type>: P, Z, Y (ignored, for compatibility).<pattern>: + (ascending), - (descending), or a hex value (e.g., 0xAA).<sector>: The MTD erase block number to start writing to.<size>: Number of bytes to write. Max is the MTD erase block size.Read Command:flash read <type> <sector> <size><type>: Z, Y, O, etc. (ignored).<sector>: The MTD erase block number to read from.<size>: Number of bytes to read.Erase Command:flash erase <type> <start_sector> [end_sector]<type>:A: Auto-detect and use the device's native erase block size.O: Assumes 128KiB sectors for addressing.Y: Assumes 32KiB sectors for addressing.Z: Assumes 4KiB sectors for addressing.C: Chip Erase. Erases the entire device. No sector args needed.<start_sector>: The first sector to erase (based on the <type> size).[end_sector]: Optional. If omitted, only start_sector is erased.Write-Verify Command:flash write-verify <type> <pattern> <sector> <iter> <fail_cnt> <log> <full_util><pattern>   : +, -, 0x.. (or a placeholder if using a file).<sector>    : Start sector number.<iter>      : Iteration count (0 for infinite).<fail_cnt>  : Stop after this many failures (0 for infinite).<log>       : 0=Disable failure details, 1=Enable failure details.<full_util> : 0=Use one sector, 1=Use all available sectors.Sample Usage and OutputStarting the tool on a specific device:# ./flash_tool -d /dev/mtd1
Flash Tool Initializing...
[INFO]  libmtd backend selected.
MTD device '/dev/mtd1' opened. Size: 64 MB, Erase size: 128 KB
Initialization complete. Type 'help' for commands.
>
Erasing a single sector:> flash erase A 10
Auto-detected erase size: 131072 bytes.
Erasing 1 block(s) from offset 0x00a00000...
Erase successful.
Writing a pattern and reading it back:> flash write P + 10 256
Preparing to write 256 bytes to sector 10 (offset 0x00a00000).
Write successful.

> flash read Y 10 64
Reading 64 bytes from sector 10 (offset 0x00a00000).
Read successful. Hexdump:
  0x00000000: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  |................|
  0x00000010: 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F  |................|
  0x00000020: 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F  | !"#$%&'()*+,-./|
  0x00000030: 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F  |0123456789:;<=>?|
Running a batched write-verify test on two sectors:> flash write-verify P + 20 1 0 1 1
Test range: Sector 20 to 511.
Use a file for the data source instead of a pattern? (y/N): n
Using generated pattern '+' (65536 bytes).
Starting write-verify. Press Ctrl+C to stop.

--- Cycle 1 ---
Phase 1: Erasing all sectors in range...
  Erasing sector 20...
  Erasing sector 21...
  ...
Phase 2: Writing all sectors in range...
  Writing sector 20...
  Writing sector 21...
  ...
Phase 3: Verifying all sectors in range...
  Verifying sector 20... OK
  Verifying sector 21... OK
  ...
Target iteration count reached.

--- Write-Verify Summary ---
Cycles Completed: 1
Total Failures (all types): 0
--------------------------
Write-verify test that finds a failure with logging enabled:> flash write-verify P + 30 1 1 1 0
Test range: Sector 30 to 30.
Use a file for the data source instead of a pattern? (y/N): n
Using generated pattern '+' (65536 bytes).
Starting write-verify. Press Ctrl+C to stop.

--- Cycle 1 ---
Phase 1: Erasing all sectors in range...
  Erasing sector 30...
Phase 2: Writing all sectors in range...
  Writing sector 30...
Phase 3: Verifying all sectors in range...
  Verifying sector 30... VERIFY FAILED!
    FAIL: Iter=1, FailCount=1, Sector=30, Index=0x42, Expected=0x42, Actual=0xDE

Maximum failure count reached.

--- Write-Verify Summary ---
Cycles Completed: 0
Total Failures (all types): 1
--------------------------
Interrupting a long test with Ctrl+C:> flash write-verify P + 0 0 0 0 1
Test range: Sector 0 to 511.
...
--- Cycle 1 ---
Phase 1: Erasing all sectors in range...
  Erasing sector 0...
  Erasing sector 1...
^C
Operation interrupted by user.

--- Write-Verify Summary ---
Cycles Completed: 0
Total Failures (all types): 0
--------------------------
Shutdown signal received. Exiting gracefully.
Exiting. Cleaning up...
MTD device closed.


/****************************************************************************
 * FILE: src/include/config.h
 ****************************************************************************/
#ifndef CONFIG_H
#define CONFIG_H

#include "logger.h"

/**
 * @file config.h
 * @brief Central configuration file for the flash tool.
 */

/*
 * @brief Backend Selection
 *
 * Uncomment ONE of the following lines to select the backend at compile time.
 * - BACKEND_LIBMDT: Uses the high-level libmtd library (recommended, default).
 * - BACKEND_IOCTL:  Uses low-level direct ioctl calls.
 */
#define BACKEND_LIBMDT
/* #define BACKEND_IOCTL */


#define DEFAULT_MTD_DEVICE      "/dev/mtd0"
#define MAX_CLI_INPUT_SIZE      1024
#define MAX_CLI_ARGS            16
#define LOG_LEVEL               LOG_LEVEL_INFO

#endif /* CONFIG_H */


/****************************************************************************
 * FILE: src/include/logger.h
 ****************************************************************************/
#ifndef LOGGER_H
#define LOGGER_H

#include <stdio.h>

/**
 * @file logger.h
 * @brief A dual-mode logging utility.
 */

typedef enum {
	LOG_LEVEL_DEBUG,
	LOG_LEVEL_INFO,
	LOG_LEVEL_WARN,
	LOG_LEVEL_ERROR
} log_level_t;

#define LOG(level, fmt, ...) \
	do { \
		if (level >= LOG_LEVEL) { \
			logger_log(level, __FILE__, __LINE__, fmt, ##__VA_ARGS__); \
		} \
	} while (0)

void logger_log(log_level_t level, const char *file, int line,
		const char *fmt, ...);

#endif /* LOGGER_H */


/****************************************************************************
 * FILE: src/include/utils.h
 ****************************************************************************/
#ifndef UTILS_H
#define UTILS_H

#include <stdint.h>
#include <stddef.h>

/**
 * @file utils.h
 * @brief Declaration of various helper functions.
 */

void hexdump(const char *prefix, const void *data, size_t size);
int generate_pattern(uint8_t *buffer, size_t size, const char *pattern);
int parse_number(const char *str, long *val);
int get_user_confirmation(const char *prompt);

#endif /* UTILS_H */


/****************************************************************************
 * FILE: src/include/flash_interface.h
 ****************************************************************************/
#ifndef FLASH_INTERFACE_H
#define FLASH_INTERFACE_H

#include <stdint.h>
#include <stddef.h>
#include <mtd/mtd-user.h>

/**
 * @file flash_interface.h
 * @brief Defines the abstract interface for flash backend operations.
 */

typedef struct flash_ops {
	int (*init)(const char *device);
	void (*deinit)(void);
	int (*erase)(uint32_t offset, uint32_t len);
	int (*write)(uint32_t offset, const void *data, size_t len);
	int (*read)(uint32_t offset, void *data, size_t len);
	int (*get_info)(struct mtd_info_user *info);
} flash_ops_t;

extern const flash_ops_t *g_flash_backend;

void backend_init(void);

#endif /* FLASH_INTERFACE_H */


/****************************************************************************
 * FILE: src/include/cli.h
 ****************************************************************************/
#ifndef CLI_H
#define CLI_H

/**
 * @file cli.h
 * @brief Declarations for the command-line interface.
 */

void cli_process_command(int argc, char *argv[]);
void print_help(void);

#endif /* CLI_H */


/****************************************************************************
 * FILE: src/backend/flash_libmtd.c
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <libmtd.h>
#include "../include/flash_interface.h"
#include "../include/logger.h"

/**
 * @file flash_libmtd.c
 * @brief MTD backend implementation using the libmtd library.
 */

static libmtd_t mtd_desc;
static struct mtd_info_user mtd_info;

static int mtd_backend_init(const char *device)
{
	if (mtd_desc) {
		LOG(LOG_LEVEL_WARN, "libmtd backend already initialized.");
		return 0;
	}
	if (libmtd_open(device, &mtd_desc) < 0) {
		LOG(LOG_LEVEL_ERROR, "Failed to open MTD device: %s", device);
		return -1;
	}
	if (mtd_get_info(mtd_desc, &mtd_info) < 0) {
		LOG(LOG_LEVEL_ERROR, "Failed to get MTD device info.");
		libmtd_close(mtd_desc);
		mtd_desc = NULL;
		return -1;
	}
	printf("MTD device '%s' opened. Size: %llu MB, Erase size: %u KB\n",
	       device, mtd_info.size / (1024 * 1024),
	       mtd_info.erasesize / 1024);
	return 0;
}

static void mtd_backend_deinit(void)
{
	if (mtd_desc) {
		libmtd_close(mtd_desc);
		mtd_desc = NULL;
		printf("MTD device closed.\n");
	}
}

static int mtd_backend_erase(uint32_t offset, uint32_t len)
{
	struct erase_info_user einfo = { .start = offset, .length = len };
	if (!mtd_desc) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	if (mtd_erase(mtd_desc, &einfo) != 0) {
		LOG(LOG_LEVEL_ERROR, "libmtd erase failed.");
		return -1;
	}
	return 0;
}

static int mtd_backend_write(uint32_t offset, const void *data, size_t len)
{
	if (!mtd_desc) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	if (mtd_write(mtd_desc, offset, len, data) < 0) {
		LOG(LOG_LEVEL_ERROR, "libmtd write failed.");
		return -1;
	}
	return 0;
}

static int mtd_backend_read(uint32_t offset, void *data, size_t len)
{
	if (!mtd_desc) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	if (mtd_read(mtd_desc, offset, len, data) < 0) {
		LOG(LOG_LEVEL_ERROR, "libmtd read failed.");
		return -1;
	}
	return 0;
}

static int mtd_backend_get_info(struct mtd_info_user *info)
{
	if (!mtd_desc) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	memcpy(info, &mtd_info, sizeof(struct mtd_info_user));
	return 0;
}

const flash_ops_t libmtd_backend = {
	.init = mtd_backend_init,
	.deinit = mtd_backend_deinit,
	.erase = mtd_backend_erase,
	.write = mtd_backend_write,
	.read = mtd_backend_read,
	.get_info = mtd_backend_get_info,
};


/****************************************************************************
 * FILE: src/backend/flash_ioctl.c
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <stdlib.h>
#include "../include/flash_interface.h"
#include "../include/logger.h"

/**
 * @file flash_ioctl.c
 * @brief MTD backend implementation using direct ioctl calls.
 */

static int mtd_fd = -1;
static struct mtd_info_user mtd_info;
static char *mtd_device_path;

static int verify_erase(uint32_t offset, uint32_t len)
{
	uint8_t *buf;
	size_t i;
	int ret = -1;
	buf = malloc(len);
	if (!buf) {
		LOG(LOG_LEVEL_ERROR, "Failed to allocate memory for erase verification.");
		return -1;
	}
	if (lseek(mtd_fd, offset, SEEK_SET) < 0) {
		LOG(LOG_LEVEL_ERROR, "lseek failed for erase verification.");
		goto out_free;
	}
	if (read(mtd_fd, buf, len) != (ssize_t)len) {
		LOG(LOG_LEVEL_ERROR, "read failed for erase verification.");
		goto out_free;
	}
	for (i = 0; i < len; i++) {
		if (buf[i] != 0xFF) {
			LOG(LOG_LEVEL_ERROR,
			    "Erase verification failed at offset 0x%x (is 0x%02x, should be 0xFF).",
			    (unsigned int)(offset + i), buf[i]);
			goto out_free;
		}
	}
	LOG(LOG_LEVEL_DEBUG, "Erase verified successfully for 0x%x bytes at 0x%x.", len, offset);
	ret = 0;
out_free:
	free(buf);
	return ret;
}

static int ioctl_backend_init(const char *device)
{
	if (mtd_fd >= 0) {
		LOG(LOG_LEVEL_WARN, "ioctl backend already initialized.");
		return 0;
	}
	mtd_fd = open(device, O_RDWR);
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Failed to open MTD device: %s", device);
		return -1;
	}
	if (ioctl(mtd_fd, MEMGETINFO, &mtd_info) != 0) {
		LOG(LOG_LEVEL_ERROR, "ioctl(MEMGETINFO) failed.");
		close(mtd_fd);
		mtd_fd = -1;
		return -1;
	}
	mtd_device_path = strdup(device);
	printf("MTD device '%s' opened. Size: %llu MB, Erase size: %u KB\n",
	       device, mtd_info.size / (1024 * 1024),
	       mtd_info.erasesize / 1024);
	return 0;
}

static void ioctl_backend_deinit(void)
{
	if (mtd_fd >= 0) {
		close(mtd_fd);
		mtd_fd = -1;
		free(mtd_device_path);
		mtd_device_path = NULL;
		printf("MTD device closed.\n");
	}
}

static int ioctl_backend_erase(uint32_t offset, uint32_t len)
{
	struct erase_info_user einfo = { .start = offset, .length = len };
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	LOG(LOG_LEVEL_DEBUG, "Checking lock status for offset 0x%x", offset);
	if (ioctl(mtd_fd, MEMISLOCKED, &einfo) > 0) {
		LOG(LOG_LEVEL_WARN, "Erase block at 0x%x is locked, attempting unlock.", offset);
		if (ioctl(mtd_fd, MEMUNLOCK, &einfo) != 0) {
			LOG(LOG_LEVEL_ERROR, "Failed to unlock erase block.");
			return -1;
		}
	}
	if (ioctl(mtd_fd, MEMERASE, &einfo) != 0) {
		LOG(LOG_LEVEL_ERROR, "ioctl(MEMERASE) failed.");
		return -1;
	}
	if (verify_erase(offset, len) != 0) {
		LOG(LOG_LEVEL_ERROR, "Erase failed verification.");
		return -1;
	}
	return 0;
}

static int ioctl_backend_write(uint32_t offset, const void *data, size_t len)
{
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	if (lseek(mtd_fd, offset, SEEK_SET) < 0) {
		LOG(LOG_LEVEL_ERROR, "lseek failed for write.");
		return -1;
	}
	if (write(mtd_fd, data, len) != (ssize_t)len) {
		LOG(LOG_LEVEL_ERROR, "write failed.");
		return -1;
	}
	return 0;
}

static int ioctl_backend_read(uint32_t offset, void *data, size_t len)
{
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	if (lseek(mtd_fd, offset, SEEK_SET) < 0) {
		LOG(LOG_LEVEL_ERROR, "lseek failed for read.");
		return -1;
	}
	if (read(mtd_fd, data, len) != (ssize_t)len) {
		LOG(LOG_LEVEL_ERROR, "read failed.");
		return -1;
	}
	return 0;
}

static int ioctl_backend_get_info(struct mtd_info_user *info)
{
	if (mtd_fd < 0) {
		LOG(LOG_LEVEL_ERROR, "Backend not initialized.");
		return -1;
	}
	memcpy(info, &mtd_info, sizeof(struct mtd_info_user));
	return 0;
}

const flash_ops_t ioctl_backend = {
	.init = ioctl_backend_init,
	.deinit = ioctl_backend_deinit,
	.erase = ioctl_backend_erase,
	.write = ioctl_backend_write,
	.read = ioctl_backend_read,
	.get_info = ioctl_backend_get_info,
};


/****************************************************************************
 * FILE: src/logger.c
 ****************************************************************************/
#include <stdio.h>
#include <stdarg.h>
#include <time.h>
#include "include/logger.h"
#include "include/config.h"

/**
 * @file logger.c
 * @brief Implementation of the controlled logging system.
 */

void logger_log(log_level_t level, const char *file, int line,
		const char *fmt, ...)
{
	if (level < LOG_LEVEL)
		return;

	switch (level) {
	case LOG_LEVEL_DEBUG:
		fprintf(stderr, "[DEBUG] ");
		break;
	case LOG_LEVEL_INFO:
		fprintf(stderr, "[INFO]  ");
		break;
	case LOG_LEVEL_WARN:
		fprintf(stderr, "[WARN]  ");
		break;
	case LOG_LEVEL_ERROR:
		fprintf(stderr, "[ERROR] (%s:%d): ", file, line);
		break;
	}

	va_list args;
	va_start(args, fmt);
	vfprintf(stderr, fmt, args);
	va_end(args);
	fprintf(stderr, "\n");
}


/****************************************************************************
 * FILE: src/utils.c
 ****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "include/utils.h"
#include "include/logger.h"

/**
 * @file utils.c
 * @brief Implementation of helper functions.
 */

int parse_number(const char *str, long *val)
{
	char *endptr;
	if (!str || !val) return -1;
	*val = strtol(str, &endptr, 0);
	if (*endptr != '\0') {
		LOG(LOG_LEVEL_ERROR, "Invalid character in number: '%s'", str);
		return -1;
	}
	return 0;
}

int generate_pattern(uint8_t *buffer, size_t size, const char *pattern)
{
	size_t i;
	long val;
	if (strcmp(pattern, "+") == 0) {
		LOG(LOG_LEVEL_DEBUG, "Generating ascending pattern");
		for (i = 0; i < size; i++) buffer[i] = i & 0xFF;
	} else if (strcmp(pattern, "-") == 0) {
		LOG(LOG_LEVEL_DEBUG, "Generating descending pattern");
		for (i = 0; i < size; i++) buffer[i] = 0xFF - (i & 0xFF);
	} else {
		LOG(LOG_LEVEL_DEBUG, "Generating user-defined hex pattern: %s", pattern);
		if (parse_number(pattern, &val) != 0 || val < 0 || val > 0xFF) {
			LOG(LOG_LEVEL_ERROR, "Invalid hex pattern '%s'. Must be 0x00-0xFF.", pattern);
			return -1;
		}
		memset(buffer, (int)val, size);
	}
	return 0;
}

void hexdump(const char *prefix, const void *data, size_t size)
{
	const unsigned char *p = data;
	size_t i, j;
	for (i = 0; i < size; i += 16) {
		if (prefix) printf("%s", prefix);
		printf("0x%08zX: ", i);
		for (j = 0; j < 16; j++) {
			if (i + j < size) printf("%02X ", p[i + j]);
			else printf("   ");
		}
		printf(" |");
		for (j = 0; j < 16; j++) {
			if (i + j < size) printf("%c", isprint(p[i + j]) ? p[i + j] : '.');
		}
		printf("|\n");
	}
}

int get_user_confirmation(const char *prompt)
{
	int c;
	printf("%s", prompt);
	fflush(stdout);
	c = getchar();
	if (c == 'y' || c == 'Y') {
		while (getchar() != '\n');
		return 1;
	}
	if (c != '\n') {
		while (getchar() != '\n');
	}
	return 0;
}


/****************************************************************************
 * FILE: src/cli.c
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include "include/cli.h"
#include "include/config.h"
#include "include/flash_interface.h"
#include "include/logger.h"
#include "include/utils.h"

// Declare the external global flag from main.c
extern volatile sig_atomic_t g_shutdown_flag;

static void handle_flash_write(int argc, char *argv[]);
static void handle_flash_read(int argc, char *argv[]);
static void handle_flash_write_verify(int argc, char *argv[]);
static void handle_flash_erase(int argc, char *argv[]);

void print_help(void)
{
	printf("Flash Tool CLI\n");
	printf("------------------------\n");
	printf("Usage: ./flash_tool [-d /dev/mtdX]\n\n");
	printf("General Commands:\n");
	printf("  help                       : Show this help message.\n");
	printf("  clr                        : Clear the terminal screen.\n");
	printf("  exit                       : Exit the application.\n\n");

	printf("Flash Write Command:\n");
	printf("  flash write <type> <pattern> <sector> <size>\n");
	printf("    <type>    : P, Z, Y (Note: Ignored, for compatibility).\n");
	printf("    <pattern> : +, -, or a hex value (e.g., 0xAA).\n");
	printf("    <sector>  : Start sector number (based on device erase block size).\n");
	printf("    <size>    : Number of bytes to write (max is sector size).\n\n");

	printf("Flash Read Command:\n");
	printf("  flash read <type> <sector> <size>\n");
	printf("    <type>    : Z, Y, O, etc. (Note: Ignored).\n");
	printf("    <sector>  : Start sector number.\n");
	printf("    <size>    : Number of bytes to read.\n\n");

	printf("Flash Write-Verify Command:\n");
	printf("  flash write-verify <type> <pattern> <sector> <iter> <fail_cnt> <log> <full_util>\n");
	printf("    <pattern>   : +, -, 0x.. (or a placeholder if using a file).\n");
    printf("    <sector>    : Start sector number.\n");
    printf("    <iter>      : Iteration count (0 for infinite).\n");
    printf("    <fail_cnt>  : Stop after this many failures (0 for infinite).\n");
    printf("    <log>       : 0=Disable failure details, 1=Enable failure details.\n");
    printf("    <full_util> : 0=Use one sector, 1=Use all available sectors.\n\n");

	printf("Flash Erase Command:\n");
	printf("  flash erase <type> <start_sector> [end_sector]\n");
	printf("    <type>         : A (Auto-detect), O (128k), Y (32k), Z (4k), C (Chip Erase).\n");
	printf("    <start_sector> : Sector number based on <type> size.\n");
	printf("    [end_sector]   : Optional last sector to erase.\n");
}

void cli_process_command(int argc, char *argv[])
{
	if (argc == 0) return;
	if (strcmp(argv[0], "help") == 0) {
		print_help();
	} else if (strcmp(argv[0], "clr") == 0) {
		printf("\033[H\033[J");
	} else if (strcmp(argv[0], "flash") == 0) {
		if (argc < 2) {
			printf("Error: 'flash' requires a subcommand.\n");
			return;
		}
		if (strcmp(argv[1], "write") == 0) handle_flash_write(argc, argv);
		else if (strcmp(argv[1], "read") == 0) handle_flash_read(argc, argv);
		else if (strcmp(argv[1], "write-verify") == 0) handle_flash_write_verify(argc, argv);
		else if (strcmp(argv[1], "erase") == 0) handle_flash_erase(argc, argv);
		else printf("Error: Unknown flash command '%s'.\n", argv[1]);
	} else {
		printf("Error: Unknown command '%s'.\n", argv[0]);
	}
}

static void handle_flash_write(int argc, char *argv[])
{
	long sector_num, write_size;
	uint32_t offset;
	uint8_t *write_buf;
	struct mtd_info_user info;
	if (argc != 6) {
		printf("Usage: flash write <type> <pattern> <sector> <size>\n");
		return;
	}
	if (parse_number(argv[4], &sector_num) != 0 || parse_number(argv[5], &write_size) != 0) {
		printf("Error: Invalid number for sector or size.\n");
		return;
	}
	g_flash_backend->get_info(&info);
	if (sector_num < 0 || write_size <= 0 || write_size > info.erasesize) {
		printf("Error: Size must be > 0 and <= erase block size (%u).\n", info.erasesize);
		return;
	}
	offset = sector_num * info.erasesize;
	if (offset + write_size > info.size) {
		printf("Error: Write operation exceeds flash size.\n");
		return;
	}
	write_buf = malloc(write_size);
	if (!write_buf) {
		LOG(LOG_LEVEL_ERROR, "Failed to allocate write buffer.");
		return;
	}
	if (generate_pattern(write_buf, write_size, argv[3]) != 0) {
		free(write_buf);
		return;
	}
	printf("Preparing to write %ld bytes to sector %ld (offset 0x%08x).\n", write_size, sector_num, offset);
	if (g_flash_backend->write(offset, write_buf, write_size) == 0)
		printf("Write successful.\n");
	else
		printf("Write failed.\n");
	free(write_buf);
}

static void handle_flash_read(int argc, char *argv[])
{
	long sector_num, read_size;
	uint32_t offset;
	uint8_t *read_buf;
	struct mtd_info_user info;
	if (argc != 5) {
		printf("Usage: flash read <type> <sector> <size>\n");
		return;
	}
	if (parse_number(argv[3], &sector_num) != 0 || parse_number(argv[4], &read_size) != 0) {
		printf("Error: Invalid number for sector or size.\n");
		return;
	}
	g_flash_backend->get_info(&info);
	if (sector_num < 0 || read_size <= 0) {
		printf("Error: Invalid sector or size.\n");
		return;
	}
	offset = sector_num * info.erasesize;
	if (offset + read_size > info.size) {
		printf("Error: Read operation exceeds flash size.\n");
		return;
	}
	read_buf = malloc(read_size);
	if (!read_buf) {
		LOG(LOG_LEVEL_ERROR, "Failed to allocate read buffer.");
		return;
	}
	printf("Reading %ld bytes from sector %ld (offset 0x%08x).\n", read_size, sector_num, offset);
	if (g_flash_backend->read(offset, read_buf, read_size) == 0) {
		printf("Read successful. Hexdump:\n");
		hexdump("  ", read_buf, read_size);
	} else {
		printf("Read failed.\n");
	}
	free(read_buf);
}

static void handle_flash_write_verify(int argc, char *argv[])
{
	long start_sector, end_sector, iter_count, max_fails, enable_log, full_util;
	uint8_t *source_buf = NULL, *verify_buf = NULL;
	size_t data_size = 0;
	struct mtd_info_user info;
	unsigned long current_iter = 0, total_fail_count = 0;
	long s;
	int stop_flag = 0;
	if (argc != 8) {
		printf("Usage: flash write-verify <type> <pattern> <sector> <iter> <fail_cnt> <log> <full_util>\n");
		return;
	}
	if (parse_number(argv[4], &start_sector) != 0 || parse_number(argv[5], &iter_count) != 0 ||
	    parse_number(argv[6], &max_fails) != 0 || parse_number(argv[7], &enable_log) != 0 ||
	    parse_number(argv[8], &full_util) != 0) {
		printf("Error: Invalid number in arguments.\n");
		return;
	}
	g_flash_backend->get_info(&info);
	long total_sectors = info.size / info.erasesize;
	if (start_sector < 0 || start_sector >= total_sectors) {
		printf("Error: Invalid start sector %ld. Must be 0-%ld.\n", start_sector, total_sectors - 1);
		return;
	}
	if (full_util) {
		end_sector = total_sectors - 1;
	} else {
		end_sector = start_sector;
	}
	printf("Test range: Sector %ld to %ld.\n", start_sector, end_sector);
	if (get_user_confirmation("Use a file for the data source instead of a pattern? (y/N): ")) {
		char filename[256];
		FILE *fp;
		printf("Enter filename: ");
		if (fgets(filename, sizeof(filename), stdin) == NULL) {
			printf("Error reading filename.\n");
			return;
		}
		filename[strcspn(filename, "\n")] = 0;
		fp = fopen(filename, "rb");
		if (!fp) {
			printf("Error: Cannot open file '%s'.\n", filename);
			return;
		}
		fseek(fp, 0, SEEK_END);
		data_size = ftell(fp);
		fseek(fp, 0, SEEK_SET);
		if (data_size > info.erasesize) {
			printf("Error: File size (%zu) > erase size (%u).\n", data_size, info.erasesize);
			fclose(fp);
			return;
		}
		source_buf = malloc(data_size);
		if (!source_buf || fread(source_buf, 1, data_size, fp) != data_size) {
			printf("Error: Failed to read file into memory.\n");
			fclose(fp);
			free(source_buf);
			return;
		}
		fclose(fp);
		printf("Using data from '%s' (%zu bytes).\n", filename, data_size);
	} else {
		data_size = info.erasesize;
		source_buf = malloc(data_size);
		if (!source_buf) {
			printf("Error: Failed to allocate memory for pattern.\n");
			return;
		}
		if (generate_pattern(source_buf, data_size, argv[3]) != 0) {
			free(source_buf);
			return;
		}
		printf("Using generated pattern '%s' (%zu bytes).\n", argv[3], data_size);
	}
	verify_buf = malloc(data_size);
	if (!verify_buf) {
		printf("Error: Failed to allocate verify buffer.\n");
		free(source_buf);
		return;
	}
	printf("Starting write-verify. Press Ctrl+C to stop.\n");
	while (!stop_flag && !g_shutdown_flag) {
		current_iter++;
		printf("\n--- Cycle %lu ---\n", current_iter);
		if (iter_count > 0 && current_iter > (unsigned long)iter_count) {
			printf("Target iteration count reached.\n");
			current_iter--;
			break;
		}
		printf("Phase 1: Erasing all sectors in range...\n");
		for (s = start_sector; s <= end_sector && !stop_flag && !g_shutdown_flag; s++) {
			uint32_t offset = s * info.erasesize;
			printf("  Erasing sector %ld...\n", s);
			if (g_flash_backend->erase(offset, info.erasesize) != 0) {
				printf("    ERASE FAILED!\n");
				total_fail_count++;
				if (max_fails > 0 && total_fail_count >= (unsigned long)max_fails) stop_flag = 1;
			}
		}
		printf("Phase 2: Writing all sectors in range...\n");
		for (s = start_sector; s <= end_sector && !stop_flag && !g_shutdown_flag; s++) {
			uint32_t offset = s * info.erasesize;
			printf("  Writing sector %ld...\n", s);
			if (g_flash_backend->write(offset, source_buf, data_size) != 0) {
				printf("    WRITE FAILED!\n");
				total_fail_count++;
				if (max_fails > 0 && total_fail_count >= (unsigned long)max_fails) stop_flag = 1;
			}
		}
		printf("Phase 3: Verifying all sectors in range...\n");
		for (s = start_sector; s <= end_sector && !stop_flag && !g_shutdown_flag; s++) {
			uint32_t offset = s * info.erasesize;
			printf("  Verifying sector %ld...", s);
			fflush(stdout);
			if (g_flash_backend->read(offset, verify_buf, data_size) != 0) {
				printf(" READ FAILED!\n");
				total_fail_count++;
				if (max_fails > 0 && total_fail_count >= (unsigned long)max_fails) stop_flag = 1;
				continue;
			}
			if (memcmp(source_buf, verify_buf, data_size) != 0) {
				printf(" VERIFY FAILED!\n");
				total_fail_count++;
				if (enable_log) {
					size_t i;
					for (i = 0; i < data_size; i++) {
						if (source_buf[i] != verify_buf[i]) {
							printf("    FAIL: Iter=%lu, FailCount=%lu, Sector=%ld, Index=0x%zX, Expected=0x%02X, Actual=0x%02X\n",
							       current_iter, total_fail_count, s, i, source_buf[i], verify_buf[i]);
							break;
						}
					}
				}
				if (max_fails > 0 && total_fail_count >= (unsigned long)max_fails) stop_flag = 1;
			} else {
				printf(" OK\n");
			}
		}
	}
	if (g_shutdown_flag) {
		printf("\nOperation interrupted by user.\n");
	} else if (stop_flag) {
		printf("\nMaximum failure count reached.\n");
	}
	printf("\n--- Write-Verify Summary ---\n");
	printf("Cycles Completed: %lu\n", current_iter > 0 ? current_iter - 1 : 0);
	printf("Total Failures (all types): %lu\n", total_fail_count);
	printf("--------------------------\n");
	free(source_buf);
	free(verify_buf);
}

static void handle_flash_erase(int argc, char *argv[])
{
	long start_sector, end_sector;
	char type;
	uint32_t erase_unit_size = 0, start_offset, total_len;
	struct mtd_info_user info;
	if (argc < 3) {
		printf("Usage: flash erase <type> <start_sector> [end_sector]\n");
		return;
	}
	type = argv[2][0];
	g_flash_backend->get_info(&info);
	if (type == 'C' || type == 'c') {
		if (argc != 3) {
			printf("Usage: flash erase C\n");
			return;
		}
		if (get_user_confirmation("Performing CHIP ERASE. This will erase the ENTIRE flash. Are you sure? (y/N): ")) {
			printf("Erasing entire device (%llu bytes)...\n", info.size);
			if (g_flash_backend->erase(0, info.size) == 0)
				printf("Chip erase successful.\n");
			else
				printf("Chip erase failed.\n");
		} else {
			printf("Chip erase aborted.\n");
		}
		return;
	}
	if (argc < 4 || argc > 5) {
		printf("Usage: flash erase <type> <start_sector> [end_sector]\n");
		return;
	}
	if (parse_number(argv[3], &start_sector) != 0) {
		printf("Error: Invalid start sector.\n");
		return;
	}
    if (argc == 5) {
        if (parse_number(argv[4], &end_sector) != 0) {
            printf("Error: Invalid end sector.\n");
            return;
        }
    } else {
        end_sector = start_sector;
    }
	if (start_sector < 0 || end_sector < start_sector) {
		printf("Error: Invalid sector range.\n");
		return;
	}
	switch (type) {
	case 'A': case 'a': erase_unit_size = info.erasesize;
		printf("Auto-detected erase size: %u bytes.\n", erase_unit_size);
		break;
	case 'O': case 'o': erase_unit_size = 131072; break;
	case 'Y': case 'y': erase_unit_size = 32768; break;
	case 'Z': case 'z': erase_unit_size = 4096; break;
	default: printf("Error: Invalid erase type '%c'.\n", type); return;
	}
	start_offset = start_sector * erase_unit_size;
	total_len = (end_sector - start_sector + 1) * erase_unit_size;
	if (start_offset + total_len > info.size) {
		printf("Error: Erase range exceeds flash size.\n");
		return;
	}
	if (start_offset % info.erasesize != 0 || total_len % info.erasesize != 0) {
		printf("Warning: Requested erase geometry does not align with device's native erase size (%u).\n", info.erasesize);
	}
	printf("Erasing %ld block(s) from offset 0x%08x...\n", (end_sector - start_sector + 1), start_offset);
	if (g_flash_backend->erase(start_offset, total_len) == 0)
		printf("Erase successful.\n");
	else
		printf("Erase failed.\n");
}


/****************************************************************************
 * FILE: src/main.c
 ****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include "include/config.h"
#include "include/cli.h"
#include "include/flash_interface.h"
#include "include/logger.h"

// Declare the external backend structs from the implementation files
extern const flash_ops_t libmtd_backend;
extern const flash_ops_t ioctl_backend;

// Global pointer to the active backend, to be assigned in backend_init()
const flash_ops_t *g_flash_backend;

// Global flag for signal handling
volatile sig_atomic_t g_shutdown_flag = 0;

/**
 * @brief Initializes the global g_flash_backend pointer based on config.h
 */
void backend_init(void)
{
#if defined(BACKEND_LIBMDT)
	g_flash_backend = &libmtd_backend;
	LOG(LOG_LEVEL_INFO, "libmtd backend selected.");
#elif defined(BACKEND_IOCTL)
	g_flash_backend = &ioctl_backend;
	LOG(LOG_LEVEL_INFO, "ioctl backend selected.");
#else
#error "No MTD backend specified in config.h! Define BACKEND_LIBMDT or BACKEND_IOCTL."
#endif
}

/**
 * @brief Signal handler to gracefully shut down the application.
 */
static void signal_handler(int signum)
{
	(void)signum;
	g_shutdown_flag = 1;
}

int main(int argc, char *argv[])
{
	char input[MAX_CLI_INPUT_SIZE];
	char *args[MAX_CLI_ARGS];
	int arg_count;
	char *token;
	char *device_path = DEFAULT_MTD_DEVICE;
	int i;

	// Register signal handlers for graceful shutdown
	signal(SIGINT, signal_handler);
	signal(SIGTERM, signal_handler);

	// Parse command-line options
	for (i = 1; i < argc; i++) {
		if (strcmp(argv[i], "-d") == 0) {
			if (i + 1 < argc) {
				device_path = argv[i + 1];
				i++; // Skip the path argument
			} else {
				fprintf(stderr, "Error: -d option requires a device path.\n");
				return EXIT_FAILURE;
			}
		} else {
			fprintf(stderr, "Error: Unknown option '%s'.\n", argv[i]);
			return EXIT_FAILURE;
		}
	}

	printf("Flash Tool Initializing...\n");
	backend_init();

	if (g_flash_backend->init(device_path) != 0) {
		fprintf(stderr, "FATAL: Could not initialize flash backend for device %s. Exiting.\n", device_path);
		return EXIT_FAILURE;
	}

	printf("Initialization complete. Type 'help' for commands.\n");

	while (!g_shutdown_flag) {
		printf("> ");
		fflush(stdout);

		if (fgets(input, sizeof(input), stdin) == NULL)
			break;

		if (g_shutdown_flag) break; // Check again after blocking call

		input[strcspn(input, "\n")] = 0;

		if (strlen(input) == 0)
			continue;

		if (strcmp(input, "exit") == 0)
			break;

		arg_count = 0;
		token = strtok(input, " \t");
		while (token != NULL && arg_count < MAX_CLI_ARGS) {
			args[arg_count++] = token;
			token = strtok(NULL, " \t");
		}

		if (arg_count > 0)
			cli_process_command(arg_count, args);
	}
    
    if (g_shutdown_flag) {
        printf("\nShutdown signal received. Exiting gracefully.\n");
    }

	printf("Exiting. Cleaning up...\n");
	g_flash_backend->deinit();

	return EXIT_SUCCESS;
}

This document outlines the project's folder structure and provides the necessary build files.

### 1. Folder Structure

Create the following directory layout for your project.

flash-tool/├── bsp/│   └── recipes-utils/│       └── flash-tool/│           └── flash-tool_0.1.bb├── src/│   ├── include/│   │   ├── cli.h│   │   ├── config.h│   │   ├── flash_interface.h│   │   ├── logger.h│   │   └── utils.h│   ├── backend/│   │   ├── flash_libmtd.c│   │   └── flash_ioctl.c│   ├── cli.c│   ├── main.c│   ├── logger.c│   └── utils.c├── Makefile└── README.txt
---
### 2. Makefile

```makefile
#
# Makefile for the MTD Flash Tool
#

# Compiler and core flags
CC ?= $(CROSS_COMPILE)gcc
CFLAGS := -Wall -Wextra -std=c99 -I$(CURDIR)/src/include -g
LDFLAGS := -lmtd

# Target executable
TARGET := flash_tool

# Source files - now includes both backends
SRCS := $(wildcard src/*.c) $(wildcard src/backend/*.c)
OBJS := $(patsubst src/%.c,obj/%.o,$(SRCS))

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(OBJS)
	@echo "  LD      $@"
	@$(CC) $(OBJS) -o $@ $(LDFLAGS)

obj/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "  CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

clean:
	@echo "  CLEAN"
	@rm -rf $(TARGET) obj/
3. Yocto Recipe (flash-tool_0.1.bb)SUMMARY = "Command-line utility for MTD flash operations"
DESCRIPTION = "A tool to read, write, and erase MTD flash devices, \
with support for both libmtd and direct ioctl backends. \
Backend is selected via the config.h header."
LICENSE = "GPL-2.0-only"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/GPL-2.0-only;md5=801f80980d17102532565de542a6cc66"

# This recipe assumes the source code is placed next to it in a 'flash-tool' subdir
SRC_URI = "file://flash-tool/"

S = "${WORKDIR}/flash-tool"

# The tool depends on mtd-utils for the libmtd library
DEPENDS = "mtd-utils"

# The Makefile now builds both backends, and the C code selects
# which one to use based on config.h. No EXTRA_OEMAKE is needed.

do_compile() {
	oe_runmake
}

do_install() {
	install -d ${D}${bindir}
	install -m 0755 ${S}/flash_tool ${D}${bindir}
}
